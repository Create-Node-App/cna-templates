---
description: Advanced TanStack Query (React Query) patterns for robust data fetching, caching strategies, optimistic updates, and real-time synchronization.
globs: '**/*.{ts,tsx,js,jsx}'
---

# TanStack Query Advanced Patterns

## Query Architecture & Organization

**Structured query key management:**
```typescript
// ✅ Hierarchical query key factory
export const queryKeys = {
  users: ['users'] as const,
  user: (id: string) => [...queryKeys.users, id] as const,
  userPosts: (id: string) => [...queryKeys.user(id), 'posts'] as const,
  userProfile: (id: string) => [...queryKeys.user(id), 'profile'] as const,
  
  posts: ['posts'] as const,
  post: (id: string) => [...queryKeys.posts, id] as const,
  postsByCategory: (category: string) => [...queryKeys.posts, { category }] as const,
  infinitePosts: (filters: PostFilters) => [...queryKeys.posts, 'infinite', filters] as const,
} as const

// ✅ Type-safe query client setup
import { QueryClient, QueryCache, MutationCache } from '@tanstack/react-query'

export const queryClient = new QueryClient({
  queryCache: new QueryCache({
    onError: (error, query) => {
      // Global error handling
      console.error('Query error:', { error, queryKey: query.queryKey })
      
      if (error instanceof ApiError && error.status === 401) {
        // Handle authentication errors
        queryClient.clear()
        window.location.href = '/login'
      }
    },
  }),
  mutationCache: new MutationCache({
    onError: (error, variables, context, mutation) => {
      console.error('Mutation error:', { error, variables, context })
    },
  }),
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
      retry: (failureCount, error) => {
        if (error instanceof ApiError) {
          return error.status >= 500 && failureCount < 3
        }
        return failureCount < 3
      },
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: 1,
    },
  },
})
```

## Advanced Query Patterns

**Complex data fetching with dependencies:**
```typescript
import { useQuery, useQueries, useInfiniteQuery } from '@tanstack/react-query'

// ✅ Dependent queries with proper typing
export function useUserWithPosts(userId: string) {
  const userQuery = useQuery({
    queryKey: queryKeys.user(userId),
    queryFn: () => fetchUser(userId),
    enabled: !!userId,
  })
  
  const postsQuery = useQuery({
    queryKey: queryKeys.userPosts(userId),
    queryFn: () => fetchUserPosts(userId),
    enabled: !!userQuery.data?.id, // Depends on user query success
    staleTime: 2 * 60 * 1000, // Posts are more dynamic
  })
  
  return {
    user: userQuery.data,
    posts: postsQuery.data,
    isLoading: userQuery.isLoading || postsQuery.isLoading,
    error: userQuery.error || postsQuery.error,
    isError: userQuery.isError || postsQuery.isError,
    // Combined refetch function
    refetch: () => Promise.all([userQuery.refetch(), postsQuery.refetch()]),
  }
}

// ✅ Parallel queries with error isolation
export function useMultipleUsers(userIds: string[]) {
  return useQueries({
    queries: userIds.map(id => ({
      queryKey: queryKeys.user(id),
      queryFn: () => fetchUser(id),
      staleTime: 5 * 60 * 1000,
      // Each query fails independently
      retry: 2,
    })),
    combine: (results) => {
      return {
        users: results.map(result => result.data).filter(Boolean),
        isLoading: results.some(result => result.isLoading),
        errors: results.map(result => result.error).filter(Boolean),
        isError: results.some(result => result.isError),
      }
    }
  })
}

// ✅ Advanced infinite query with cursor-based pagination
interface PostsResponse {
  posts: Post[]
  nextCursor?: string
  hasNextPage: boolean
}

export function useInfinitePosts(filters: PostFilters = {}) {
  return useInfiniteQuery({
    queryKey: queryKeys.infinitePosts(filters),
    queryFn: ({ pageParam }) => 
      fetchPosts({ ...filters, cursor: pageParam }),
    initialPageParam: undefined,
    getNextPageParam: (lastPage: PostsResponse) => 
      lastPage.hasNextPage ? lastPage.nextCursor : undefined,
    getPreviousPageParam: (firstPage: PostsResponse) => 
      firstPage.previousCursor,
    // ✅ Transform data for easier consumption
    select: (data) => ({
      posts: data.pages.flatMap(page => page.posts),
      hasNextPage: data.pages[data.pages.length - 1]?.hasNextPage ?? false,
    }),
    staleTime: 1 * 60 * 1000, // 1 minute for real-time feel
    maxPages: 10, // Prevent memory leaks
  })
}
```

## Mutation Patterns & Optimistic Updates

**Advanced mutation patterns with rollback:**
```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'

// ✅ Optimistic update with rollback
export function useUpdatePost() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: ({ postId, updates }: { postId: string; updates: Partial<Post> }) =>
      updatePost(postId, updates),
    
    onMutate: async ({ postId, updates }) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: queryKeys.post(postId) })
      
      // Snapshot previous value
      const previousPost = queryClient.getQueryData(queryKeys.post(postId))
      
      // Optimistically update
      queryClient.setQueryData(queryKeys.post(postId), (old: Post | undefined) => 
        old ? { ...old, ...updates } : undefined
      )
      
      // Update in lists too
      queryClient.setQueriesData(
        { queryKey: queryKeys.posts },
        (oldData: Post[] | undefined) =>
          oldData?.map(post => 
            post.id === postId ? { ...post, ...updates } : post
          )
      )
      
      return { previousPost, postId }
    },
    
    onError: (error, variables, context) => {
      // Rollback optimistic update
      if (context?.previousPost) {
        queryClient.setQueryData(
          queryKeys.post(context.postId), 
          context.previousPost
        )
      }
    },
    
    onSettled: (data, error, variables) => {
      // Always refetch to ensure consistency
      queryClient.invalidateQueries({ queryKey: queryKeys.post(variables.postId) })
      queryClient.invalidateQueries({ queryKey: queryKeys.posts })
    },
  })
}

// ✅ Complex mutation with multiple updates
export function useCreatePostWithTags() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: async (newPost: CreatePostData) => {
      // Create post and update tags in sequence
      const post = await createPost(newPost)
      await Promise.all(
        newPost.tags.map(tag => updateTagUsageCount(tag.id))
      )
      return post
    },
    
    onSuccess: (newPost, variables) => {
      // Add to infinite queries
      queryClient.setQueriesData(
        { queryKey: queryKeys.posts },
        (oldData: any) => {
          if (!oldData) return { pages: [{ posts: [newPost] }] }
          
          const firstPage = oldData.pages[0]
          return {
            ...oldData,
            pages: [
              { ...firstPage, posts: [newPost, ...firstPage.posts] },
              ...oldData.pages.slice(1),
            ],
          }
        }
      )
      
      // Invalidate related queries
      queryClient.invalidateQueries({ 
        queryKey: queryKeys.postsByCategory(newPost.category) 
      })
      
      variables.tags.forEach(tag => {
        queryClient.invalidateQueries({ 
          queryKey: ['tags', tag.id] 
        })
      })
    },
  })
}
```

## Advanced Caching Strategies

**Cache management and synchronization:**
```typescript
// ✅ Cache warming and preloading
export function usePrefetchStrategies() {
  const queryClient = useQueryClient()
  
  const prefetchUser = useCallback((userId: string) => {
    queryClient.prefetchQuery({
      queryKey: queryKeys.user(userId),
      queryFn: () => fetchUser(userId),
      staleTime: 5 * 60 * 1000,
    })
  }, [queryClient])
  
  const prefetchUserPosts = useCallback((userId: string) => {
    queryClient.prefetchQuery({
      queryKey: queryKeys.userPosts(userId),
      queryFn: () => fetchUserPosts(userId),
      staleTime: 2 * 60 * 1000,
    })
  }, [queryClient])
  
  return { prefetchUser, prefetchUserPosts }
}

// ✅ Background sync with WebSockets
export function useRealTimeSync() {
  const queryClient = useQueryClient()
  
  useEffect(() => {
    const ws = new WebSocket(process.env.REACT_APP_WS_URL!)
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data)
      
      switch (data.type) {
        case 'POST_UPDATED':
          queryClient.setQueryData(
            queryKeys.post(data.postId),
            (oldData: Post | undefined) => 
              oldData ? { ...oldData, ...data.updates } : undefined
          )
          break
          
        case 'POST_DELETED':
          queryClient.removeQueries({ 
            queryKey: queryKeys.post(data.postId) 
          })
          // Remove from lists
          queryClient.setQueriesData(
            { queryKey: queryKeys.posts },
            (oldData: Post[] | undefined) =>
              oldData?.filter(post => post.id !== data.postId)
          )
          break
          
        case 'NEW_POST':
          // Add to relevant caches
          queryClient.setQueriesData(
            { queryKey: queryKeys.postsByCategory(data.post.category) },
            (oldData: Post[] | undefined) =>
              oldData ? [data.post, ...oldData] : [data.post]
          )
          break
      }
    }
    
    return () => ws.close()
  }, [queryClient])
}

// ✅ Selective cache invalidation
export function useCacheInvalidation() {
  const queryClient = useQueryClient()
  
  const invalidateUserData = useCallback((userId: string) => {
    return queryClient.invalidateQueries({ 
      queryKey: queryKeys.user(userId) 
    })
  }, [queryClient])
  
  const invalidateAllPosts = useCallback(() => {
    return queryClient.invalidateQueries({ 
      queryKey: queryKeys.posts 
    })
  }, [queryClient])
  
  const clearUserCache = useCallback((userId: string) => {
    queryClient.removeQueries({ 
      queryKey: queryKeys.user(userId) 
    })
  }, [queryClient])
  
  return {
    invalidateUserData,
    invalidateAllPosts,
    clearUserCache,
  }
}
```

## Error Handling & Retry Logic

**Sophisticated error handling patterns:**
```typescript
// ✅ Custom error handling hook
export function useQueryErrorHandler() {
  return {
    onError: useCallback((error: unknown, query: any) => {
      if (error instanceof ApiError) {
        switch (error.status) {
          case 401:
            // Redirect to login
            window.location.href = '/login'
            break
          case 403:
            // Show access denied message
            toast.error('Access denied')
            break
          case 500:
            // Show generic error
            toast.error('Server error occurred')
            break
          default:
            toast.error(error.message || 'An error occurred')
        }
      }
    }, []),
    
    retry: useCallback((failureCount: number, error: unknown) => {
      if (error instanceof ApiError) {
        // Don't retry client errors
        if (error.status >= 400 && error.status < 500) {
          return false
        }
        
        // Exponential backoff for server errors
        if (error.status >= 500) {
          return failureCount < 3
        }
      }
      
      return failureCount < 2
    }, []),
  }
}

// ✅ Network-aware queries
export function useNetworkAwareQuery<T>(
  queryKey: any[],
  queryFn: () => Promise<T>,
  options: any = {}
) {
  const [isOnline, setIsOnline] = useState(navigator.onLine)
  
  useEffect(() => {
    const handleOnline = () => setIsOnline(true)
    const handleOffline = () => setIsOnline(false)
    
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
    
    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])
  
  return useQuery({
    queryKey,
    queryFn,
    enabled: isOnline,
    refetchOnReconnect: 'always',
    staleTime: isOnline ? options.staleTime : Infinity,
    ...options,
  })
}
```

## Performance Optimization

**Query performance best practices:**
```typescript
// ✅ Suspense integration
import { useSuspenseQuery } from '@tanstack/react-query'

export function UserProfileSuspense({ userId }: { userId: string }) {
  const { data: user } = useSuspenseQuery({
    queryKey: queryKeys.user(userId),
    queryFn: () => fetchUser(userId),
  })
  
  // No need for loading states - handled by Suspense boundary
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  )
}

// ✅ Query result transformation and memoization
export function usePostsWithCommentCount() {
  return useQuery({
    queryKey: ['posts', 'with-comment-count'],
    queryFn: async () => {
      const [posts, comments] = await Promise.all([
        fetchPosts(),
        fetchAllComments(),
      ])
      
      // Transform data on the client
      return posts.map(post => ({
        ...post,
        commentCount: comments.filter(c => c.postId === post.id).length,
      }))
    },
    // ✅ Memoize expensive transformations
    select: useCallback((data: any[]) => 
      data.sort((a, b) => b.commentCount - a.commentCount), []
    ),
    staleTime: 5 * 60 * 1000,
  })
}

// ✅ Query deduplication and batching
export function useUserBatch(userIds: string[]) {
  return useQuery({
    queryKey: ['users', 'batch', ...userIds.sort()],
    queryFn: () => fetchUsersBatch(userIds),
    enabled: userIds.length > 0,
    // Batch multiple user requests
    staleTime: 30 * 1000,
  })
}
```