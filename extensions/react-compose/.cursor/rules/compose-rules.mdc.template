---
description: Advanced React composition patterns and Docker containerization strategies for scalable component architecture and orchestrated development environments.
globs: '**/*.{ts,tsx,js,jsx}, docker-compose*.{yml,yaml}'
---

# Advanced React Composition & Docker Orchestration

## Enterprise Component Composition

**Higher-order components and render props with advanced composition patterns:**
```tsx
// ✅ Advanced Higher-Order Component patterns
import React, { ComponentType, ReactElement, ReactNode, useMemo, useRef } from 'react'
import { createContext, useContext, useState, useEffect, useCallback } from 'react'

// ✅ Generic HOC factory with proper TypeScript support
type HOCProps<T = {}> = T & {
  children?: ReactNode
}

interface WithLoadingProps {
  isLoading?: boolean
  loadingComponent?: ReactElement
  errorComponent?: ReactElement
  error?: Error | null
}

export function withLoading<P extends object>(
  WrappedComponent: ComponentType<P>
): ComponentType<P & WithLoadingProps> {
  const WithLoadingComponent = (props: P & WithLoadingProps) => {
    const { 
      isLoading = false, 
      loadingComponent = <div>Loading...</div>,
      errorComponent,
      error,
      ...restProps 
    } = props

    if (error && errorComponent) {
      return errorComponent
    }

    if (isLoading) {
      return loadingComponent
    }

    return <WrappedComponent {...(restProps as P)} />
  }

  WithLoadingComponent.displayName = `withLoading(${WrappedComponent.displayName || WrappedComponent.name})`
  return WithLoadingComponent
}

// ✅ Compound component pattern with context
interface TabsContextValue {
  activeTab: string
  setActiveTab: (tab: string) => void
  registerTab: (tab: string) => void
  unregisterTab: (tab: string) => void
}

const TabsContext = createContext<TabsContextValue | undefined>(undefined)

const useTabs = () => {
  const context = useContext(TabsContext)
  if (!context) {
    throw new Error('useTabs must be used within a Tabs component')
  }
  return context
}

interface TabsProps {
  defaultTab?: string
  onTabChange?: (tab: string) => void
  children: ReactNode
  className?: string
}

export const Tabs: React.FC<TabsProps> & {
  List: typeof TabList
  Tab: typeof Tab
  Panels: typeof TabPanels
  Panel: typeof TabPanel
} = ({ defaultTab, onTabChange, children, className }) => {
  const [activeTab, setActiveTab] = useState(defaultTab || '')
  const [registeredTabs, setRegisteredTabs] = useState<Set<string>>(new Set())

  const registerTab = useCallback((tab: string) => {
    setRegisteredTabs(prev => new Set([...prev, tab]))
    if (!activeTab && !defaultTab) {
      setActiveTab(tab)
    }
  }, [activeTab, defaultTab])

  const unregisterTab = useCallback((tab: string) => {
    setRegisteredTabs(prev => {
      const newSet = new Set(prev)
      newSet.delete(tab)
      return newSet
    })
  }, [])

  const handleTabChange = useCallback((tab: string) => {
    setActiveTab(tab)
    onTabChange?.(tab)
  }, [onTabChange])

  const contextValue: TabsContextValue = {
    activeTab,
    setActiveTab: handleTabChange,
    registerTab,
    unregisterTab
  }

  return (
    <TabsContext.Provider value={contextValue}>
      <div className={`tabs ${className || ''}`}>
        {children}
      </div>
    </TabsContext.Provider>
  )
}

const TabList: React.FC<{ children: ReactNode; className?: string }> = ({ 
  children, 
  className 
}) => {
  return (
    <div className={`tab-list ${className || ''}`} role="tablist">
      {children}
    </div>
  )
}

interface TabProps {
  id: string
  children: ReactNode
  disabled?: boolean
  className?: string
}

const Tab: React.FC<TabProps> = ({ id, children, disabled = false, className }) => {
  const { activeTab, setActiveTab, registerTab, unregisterTab } = useTabs()

  useEffect(() => {
    registerTab(id)
    return () => unregisterTab(id)
  }, [id, registerTab, unregisterTab])

  const handleClick = useCallback(() => {
    if (!disabled) {
      setActiveTab(id)
    }
  }, [disabled, id, setActiveTab])

  const isActive = activeTab === id

  return (
    <button
      className={`tab ${isActive ? 'active' : ''} ${disabled ? 'disabled' : ''} ${className || ''}`}
      onClick={handleClick}
      disabled={disabled}
      role="tab"
      aria-selected={isActive}
      aria-controls={`panel-${id}`}
      id={`tab-${id}`}
    >
      {children}
    </button>
  )
}

const TabPanels: React.FC<{ children: ReactNode; className?: string }> = ({ 
  children, 
  className 
}) => {
  return (
    <div className={`tab-panels ${className || ''}`}>
      {children}
    </div>
  )
}

interface TabPanelProps {
  id: string
  children: ReactNode
  className?: string
  lazy?: boolean
}

const TabPanel: React.FC<TabPanelProps> = ({ id, children, className, lazy = false }) => {
  const { activeTab } = useTabs()
  const hasBeenActive = useRef(false)
  
  const isActive = activeTab === id
  
  if (isActive) {
    hasBeenActive.current = true
  }

  if (lazy && !hasBeenActive.current) {
    return null
  }

  return (
    <div
      className={`tab-panel ${isActive ? 'active' : 'inactive'} ${className || ''}`}
      role="tabpanel"
      aria-labelledby={`tab-${id}`}
      id={`panel-${id}`}
      hidden={!isActive}
    >
      {children}
    </div>
  )
}

// Assign compound components
Tabs.List = TabList
Tabs.Tab = Tab
Tabs.Panels = TabPanels
Tabs.Panel = TabPanel

// ✅ Render prop pattern with advanced functionality
interface DataFetcherProps<T> {
  url: string
  children: (state: {
    data: T | null
    loading: boolean
    error: Error | null
    refetch: () => void
  }) => ReactElement
  onSuccess?: (data: T) => void
  onError?: (error: Error) => void
  retryCount?: number
  retryDelay?: number
}

export function DataFetcher<T = any>({ 
  url, 
  children, 
  onSuccess, 
  onError,
  retryCount = 3,
  retryDelay = 1000
}: DataFetcherProps<T>) {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)
  const [retries, setRetries] = useState(0)

  const fetchData = useCallback(async () => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch(url)
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const result = await response.json()
      setData(result)
      onSuccess?.(result)
    } catch (err) {
      const error = err instanceof Error ? err : new Error('Unknown error')
      
      if (retries < retryCount) {
        setTimeout(() => {
          setRetries(prev => prev + 1)
          fetchData()
        }, retryDelay * Math.pow(2, retries)) // Exponential backoff
      } else {
        setError(error)
        onError?.(error)
      }
    } finally {
      setLoading(false)
    }
  }, [url, onSuccess, onError, retries, retryCount, retryDelay])

  useEffect(() => {
    fetchData()
  }, [fetchData])

  const refetch = useCallback(() => {
    setRetries(0)
    fetchData()
  }, [fetchData])

  return children({ data, loading, error, refetch })
}

// ✅ Advanced composition with custom hooks
interface FormField {
  name: string
  value: any
  error?: string
  touched: boolean
  onChange: (value: any) => void
  onBlur: () => void
  validate?: (value: any) => string | undefined
}

interface FormState {
  values: Record<string, any>
  errors: Record<string, string>
  touched: Record<string, boolean>
  isSubmitting: boolean
  isValid: boolean
}

export function useForm<T extends Record<string, any>>(initialValues: T) {
  const [state, setState] = useState<FormState>({
    values: initialValues,
    errors: {},
    touched: {},
    isSubmitting: false,
    isValid: true
  })

  const setFieldValue = useCallback((name: string, value: any) => {
    setState(prev => ({
      ...prev,
      values: { ...prev.values, [name]: value }
    }))
  }, [])

  const setFieldError = useCallback((name: string, error: string) => {
    setState(prev => ({
      ...prev,
      errors: { ...prev.errors, [name]: error }
    }))
  }, [])

  const setFieldTouched = useCallback((name: string, touched = true) => {
    setState(prev => ({
      ...prev,
      touched: { ...prev.touched, [name]: touched }
    }))
  }, [])

  const validateField = useCallback((name: string, value: any, validator?: (value: any) => string | undefined) => {
    if (validator) {
      const error = validator(value)
      if (error) {
        setFieldError(name, error)
        return false
      } else {
        setState(prev => ({
          ...prev,
          errors: { ...prev.errors, [name]: '' }
        }))
      }
    }
    return true
  }, [setFieldError])

  const getFieldProps = useCallback((name: string, validator?: (value: any) => string | undefined): FormField => ({
    name,
    value: state.values[name],
    error: state.errors[name],
    touched: state.touched[name],
    onChange: (value: any) => {
      setFieldValue(name, value)
      if (state.touched[name]) {
        validateField(name, value, validator)
      }
    },
    onBlur: () => {
      setFieldTouched(name, true)
      validateField(name, state.values[name], validator)
    },
    validate: validator
  }), [state, setFieldValue, setFieldTouched, validateField])

  const validateForm = useCallback((validators: Record<string, (value: any) => string | undefined>) => {
    let isValid = true
    const newErrors: Record<string, string> = {}

    Object.entries(validators).forEach(([fieldName, validator]) => {
      const error = validator(state.values[fieldName])
      if (error) {
        newErrors[fieldName] = error
        isValid = false
      }
    })

    setState(prev => ({
      ...prev,
      errors: newErrors,
      isValid
    }))

    return isValid
  }, [state.values])

  const reset = useCallback(() => {
    setState({
      values: initialValues,
      errors: {},
      touched: {},
      isSubmitting: false,
      isValid: true
    })
  }, [initialValues])

  return {
    state,
    getFieldProps,
    validateForm,
    reset,
    setFieldValue,
    setFieldError,
    setFieldTouched
  }
}

// ✅ Form component using composition
interface FormProps {
  onSubmit: (values: any) => Promise<void> | void
  validation?: Record<string, (value: any) => string | undefined>
  initialValues?: Record<string, any>
  children: (form: ReturnType<typeof useForm>) => ReactElement
}

export const Form: React.FC<FormProps> = ({ 
  onSubmit, 
  validation = {}, 
  initialValues = {}, 
  children 
}) => {
  const form = useForm(initialValues)

  const handleSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!form.validateForm(validation)) {
      return
    }

    form.state.isSubmitting = true
    
    try {
      await onSubmit(form.state.values)
    } catch (error) {
      console.error('Form submission error:', error)
    } finally {
      form.state.isSubmitting = false
    }
  }, [form, validation, onSubmit])

  return (
    <form onSubmit={handleSubmit}>
      {children(form)}
    </form>
  )
}

// ✅ Modal composition pattern
interface ModalContextValue {
  isOpen: boolean
  open: () => void
  close: () => void
}

const ModalContext = createContext<ModalContextValue | undefined>(undefined)

export const useModal = () => {
  const context = useContext(ModalContext)
  if (!context) {
    throw new Error('useModal must be used within a Modal component')
  }
  return context
}

interface ModalProps {
  children: ReactNode
  onClose?: () => void
}

export const Modal: React.FC<ModalProps> & {
  Trigger: typeof ModalTrigger
  Content: typeof ModalContent
  Header: typeof ModalHeader
  Body: typeof ModalBody
  Footer: typeof ModalFooter
  Close: typeof ModalClose
} = ({ children, onClose }) => {
  const [isOpen, setIsOpen] = useState(false)

  const open = useCallback(() => setIsOpen(true), [])
  const close = useCallback(() => {
    setIsOpen(false)
    onClose?.()
  }, [onClose])

  const contextValue: ModalContextValue = {
    isOpen,
    open,
    close
  }

  return (
    <ModalContext.Provider value={contextValue}>
      {children}
      {isOpen && <ModalOverlay />}
    </ModalContext.Provider>
  )
}

const ModalTrigger: React.FC<{ children: ReactElement }> = ({ children }) => {
  const { open } = useModal()
  
  return React.cloneElement(children, {
    onClick: (e: React.MouseEvent) => {
      children.props.onClick?.(e)
      open()
    }
  })
}

const ModalContent: React.FC<{ children: ReactNode; className?: string }> = ({ 
  children, 
  className 
}) => {
  const { isOpen, close } = useModal()

  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        close()
      }
    }

    if (isOpen) {
      document.addEventListener('keydown', handleEscape)
      document.body.style.overflow = 'hidden'
    }

    return () => {
      document.removeEventListener('keydown', handleEscape)
      document.body.style.overflow = 'unset'
    }
  }, [isOpen, close])

  if (!isOpen) return null

  return (
    <div className="modal-content-wrapper">
      <div 
        className={`modal-content ${className || ''}`}
        onClick={(e) => e.stopPropagation()}
      >
        {children}
      </div>
    </div>
  )
}

const ModalOverlay: React.FC = () => {
  const { close } = useModal()
  
  return (
    <div 
      className="modal-overlay"
      onClick={close}
    />
  )
}

const ModalHeader: React.FC<{ children: ReactNode; className?: string }> = ({ 
  children, 
  className 
}) => (
  <div className={`modal-header ${className || ''}`}>
    {children}
  </div>
)

const ModalBody: React.FC<{ children: ReactNode; className?: string }> = ({ 
  children, 
  className 
}) => (
  <div className={`modal-body ${className || ''}`}>
    {children}
  </div>
)

const ModalFooter: React.FC<{ children: ReactNode; className?: string }> = ({ 
  children, 
  className 
}) => (
  <div className={`modal-footer ${className || ''}`}>
    {children}
  </div>
)

const ModalClose: React.FC<{ children: ReactElement }> = ({ children }) => {
  const { close } = useModal()
  
  return React.cloneElement(children, {
    onClick: (e: React.MouseEvent) => {
      children.props.onClick?.(e)
      close()
    }
  })
}

// Assign compound components
Modal.Trigger = ModalTrigger
Modal.Content = ModalContent
Modal.Header = ModalHeader
Modal.Body = ModalBody
Modal.Footer = ModalFooter
Modal.Close = ModalClose
```

## Advanced Docker Compose Configuration

**Production-ready containerized development environment:**
```yaml
# ✅ Production-optimized Docker Compose
# docker-compose.yml
version: '3.8'

services:
  # ✅ React application service
  app:
    build:
      context: .
      dockerfile: Dockerfile
      target: ${BUILD_TARGET:-development}
      args:
        - NODE_ENV=${NODE_ENV:-development}
        - API_URL=${API_URL:-http://localhost:3001}
        - BUILD_VERSION=${BUILD_VERSION:-latest}
    container_name: ${COMPOSE_PROJECT_NAME:-react-app}_app
    restart: unless-stopped
    ports:
      - "${APP_PORT:-3000}:3000"
    environment:
      - NODE_ENV=${NODE_ENV:-development}
      - REACT_APP_API_URL=${API_URL:-http://localhost:3001}
      - REACT_APP_VERSION=${BUILD_VERSION:-latest}
      - REACT_APP_ENVIRONMENT=${NODE_ENV:-development}
    volumes:
      # Development hot reload
      - ./src:/app/src:cached
      - ./public:/app/public:cached
      - ./package.json:/app/package.json:ro
      - ./package-lock.json:/app/package-lock.json:ro
      # Exclude node_modules for performance
      - /app/node_modules
      - react_app_node_modules:/app/node_modules
    networks:
      - app-network
    depends_on:
      api:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.app.rule=Host(\`${APP_DOMAIN:-localhost}\`)"
      - "traefik.http.services.app.loadbalancer.server.port=3000"
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3

  # ✅ API service
  api:
    build:
      context: ./api
      dockerfile: Dockerfile
      target: ${API_BUILD_TARGET:-development}
    container_name: ${COMPOSE_PROJECT_NAME:-react-app}_api
    restart: unless-stopped
    ports:
      - "${API_PORT:-3001}:3001"
    environment:
      - NODE_ENV=${NODE_ENV:-development}
      - DATABASE_URL=${DATABASE_URL:-postgresql://postgres:password@postgres:5432/app_db}
      - REDIS_URL=${REDIS_URL:-redis://redis:6379}
      - JWT_SECRET=${JWT_SECRET:-your-secret-key}
      - CORS_ORIGIN=${CORS_ORIGIN:-http://localhost:3000}
    volumes:
      - ./api/src:/app/src:cached
      - ./api/package.json:/app/package.json:ro
      - /app/node_modules
      - api_node_modules:/app/node_modules
    networks:
      - app-network
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # ✅ PostgreSQL database
  postgres:
    image: postgres:15-alpine
    container_name: ${COMPOSE_PROJECT_NAME:-react-app}_postgres
    restart: unless-stopped
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    environment:
      - POSTGRES_DB=${POSTGRES_DB:-app_db}
      - POSTGRES_USER=${POSTGRES_USER:-postgres}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-password}
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init:/docker-entrypoint-initdb.d:ro
      - ./database/backups:/backups
    networks:
      - app-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $${POSTGRES_USER} -d $${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 256M

  # ✅ Redis cache
  redis:
    image: redis:7-alpine
    container_name: ${COMPOSE_PROJECT_NAME:-react-app}_redis
    restart: unless-stopped
    ports:
      - "${REDIS_PORT:-6379}:6379"
    command: redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf:ro
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M

  # ✅ Nginx reverse proxy
  nginx:
    image: nginx:alpine
    container_name: ${COMPOSE_PROJECT_NAME:-react-app}_nginx
    restart: unless-stopped
    ports:
      - "${NGINX_HTTP_PORT:-80}:80"
      - "${NGINX_HTTPS_PORT:-443}:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - nginx_cache:/var/cache/nginx
      - nginx_logs:/var/log/nginx
    networks:
      - app-network
    depends_on:
      - app
      - api
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3

  # ✅ Development tools
  adminer:
    image: adminer:latest
    container_name: ${COMPOSE_PROJECT_NAME:-react-app}_adminer
    restart: unless-stopped
    ports:
      - "${ADMINER_PORT:-8080}:8080"
    environment:
      - ADMINER_DEFAULT_SERVER=postgres
    networks:
      - app-network
    depends_on:
      - postgres
    profiles:
      - dev
      - debug

  # ✅ Redis admin interface
  redis-commander:
    image: rediscommander/redis-commander:latest
    container_name: ${COMPOSE_PROJECT_NAME:-react-app}_redis_commander
    restart: unless-stopped
    ports:
      - "${REDIS_COMMANDER_PORT:-8081}:8081"
    environment:
      - REDIS_HOSTS=local:redis:6379
    networks:
      - app-network
    depends_on:
      - redis
    profiles:
      - dev
      - debug

  # ✅ Log aggregation
  fluent-bit:
    image: fluent/fluent-bit:latest
    container_name: ${COMPOSE_PROJECT_NAME:-react-app}_fluent_bit
    restart: unless-stopped
    volumes:
      - ./fluent-bit/fluent-bit.conf:/fluent-bit/etc/fluent-bit.conf:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - app-network
    profiles:
      - monitoring

  # ✅ Metrics collection
  prometheus:
    image: prom/prometheus:latest
    container_name: ${COMPOSE_PROJECT_NAME:-react-app}_prometheus
    restart: unless-stopped
    ports:
      - "${PROMETHEUS_PORT:-9090}:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus_data:/prometheus
    networks:
      - app-network
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
      - '--storage.tsdb.retention.time=200h'
      - '--web.enable-lifecycle'
    profiles:
      - monitoring

  # ✅ Metrics visualization
  grafana:
    image: grafana/grafana:latest
    container_name: ${COMPOSE_PROJECT_NAME:-react-app}_grafana
    restart: unless-stopped
    ports:
      - "${GRAFANA_PORT:-3001}:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD:-admin}
      - GF_USERS_ALLOW_SIGN_UP=false
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards:ro
      - ./monitoring/grafana/datasources:/etc/grafana/provisioning/datasources:ro
    networks:
      - app-network
    depends_on:
      - prometheus
    profiles:
      - monitoring

# ✅ Network configuration
networks:
  app-network:
    driver: bridge
    ipam:
      driver: default
      config:
        - subnet: 172.20.0.0/16

# ✅ Volume management
volumes:
  postgres_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ./volumes/postgres
  redis_data:
    driver: local
  react_app_node_modules:
    driver: local
  api_node_modules:
    driver: local
  nginx_cache:
    driver: local
  nginx_logs:
    driver: local
  prometheus_data:
    driver: local
  grafana_data:
    driver: local

# ✅ Production override
# docker-compose.prod.yml
version: '3.8'

services:
  app:
    build:
      target: production
    environment:
      - NODE_ENV=production
    volumes: []  # Remove development volumes
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '2.0'
          memory: 2G

  api:
    build:
      target: production
    environment:
      - NODE_ENV=production
    volumes: []  # Remove development volumes
    deploy:
      replicas: 2

  nginx:
    volumes:
      - ./nginx/prod.conf:/etc/nginx/nginx.conf:ro

  # Remove development services
  adminer:
    profiles:
      - disabled

  redis-commander:
    profiles:
      - disabled
```

## Multi-Stage Dockerfile

**Optimized containerization with security and performance:**
```dockerfile
# ✅ Multi-stage production Dockerfile
# Dockerfile
ARG NODE_VERSION=18-alpine
FROM node:${NODE_VERSION} as base

# ✅ Security: Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S reactapp -u 1001

# Set working directory
WORKDIR /app

# ✅ Install system dependencies
RUN apk add --no-cache \
    libc6-compat \
    && rm -rf /var/cache/apk/*

# ✅ Development stage
FROM base as development

# Copy package files
COPY package*.json ./
RUN npm ci --only=development && npm cache clean --force

# Copy source code
COPY . .

# Change ownership to nodejs user
RUN chown -R reactapp:nodejs /app
USER reactapp

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# Start development server
CMD ["npm", "start"]

# ✅ Build stage
FROM base as builder

# Copy package files
COPY package*.json ./

# Install all dependencies including devDependencies
RUN npm ci --include=dev && npm cache clean --force

# Copy source code
COPY . .

# Build arguments
ARG REACT_APP_API_URL
ARG REACT_APP_VERSION
ARG REACT_APP_ENVIRONMENT

# Set build environment variables
ENV REACT_APP_API_URL=${REACT_APP_API_URL}
ENV REACT_APP_VERSION=${REACT_APP_VERSION}
ENV REACT_APP_ENVIRONMENT=${REACT_APP_ENVIRONMENT}
ENV NODE_ENV=production

# Build application
RUN npm run build && \
    npm run test:ci && \
    npm prune --production

# ✅ Production stage
FROM nginx:alpine as production

# Install curl for health checks
RUN apk add --no-cache curl

# Copy built application
COPY --from=builder /app/build /usr/share/nginx/html

# Copy nginx configuration
COPY nginx/nginx.conf /etc/nginx/nginx.conf
COPY nginx/default.conf /etc/nginx/conf.d/default.conf

# Create nginx user
RUN addgroup -g 101 -S nginx || true && \
    adduser -S -D -H -u 101 -h /var/cache/nginx -s /sbin/nologin -G nginx -g nginx nginx || true

# Set proper permissions
RUN chown -R nginx:nginx /usr/share/nginx/html && \
    chown -R nginx:nginx /var/cache/nginx && \
    chown -R nginx:nginx /var/log/nginx && \
    chown -R nginx:nginx /etc/nginx/conf.d

# Switch to non-root user
USER nginx

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

# Labels for metadata
LABEL maintainer="your-email@example.com" \
      version="1.0.0" \
      description="Production React Application"

# Start nginx
CMD ["nginx", "-g", "daemon off;"]

# ✅ Testing stage
FROM builder as testing

# Install testing dependencies
RUN npm install -g jest @testing-library/react @testing-library/jest-dom

# Copy test configuration
COPY jest.config.js ./
COPY src/__tests__ ./src/__tests__

# Run tests
RUN npm run test:ci

# ✅ Security scanning stage
FROM builder as security-scan

# Install security scanner
RUN npm install -g audit-ci snyk

# Run security audits
RUN npm audit --audit-level high
RUN npm run security:scan || true

CMD ["echo", "Security scan completed"]
```

## Development Workflow Automation

**Advanced development and deployment automation:**
```bash
#!/bin/bash
# ✅ Development workflow script
# scripts/dev-workflow.sh

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
COMPOSE_FILE="docker-compose.yml"
COMPOSE_DEV_FILE="docker-compose.dev.yml"
COMPOSE_PROD_FILE="docker-compose.prod.yml"
PROJECT_NAME="react-compose-app"

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if Docker is running
check_docker() {
    if ! docker info > /dev/null 2>&1; then
        log_error "Docker is not running. Please start Docker and try again."
        exit 1
    fi
}

# Load environment variables
load_env() {
    if [ -f .env ]; then
        export $(cat .env | grep -v '^#' | xargs)
        log_info "Loaded environment variables from .env"
    else
        log_warning ".env file not found. Using defaults."
    fi
}

# Initialize project
init() {
    log_info "Initializing project..."
    
    # Create necessary directories
    mkdir -p {volumes/postgres,logs,nginx/conf.d,monitoring/grafana/dashboards,database/init}
    
    # Create .env if it doesn't exist
    if [ ! -f .env ]; then
        cp .env.example .env
        log_info "Created .env file from example"
    fi
    
    # Set proper permissions
    chmod +x scripts/*.sh
    
    log_success "Project initialized successfully"
}

# Development environment
dev() {
    log_info "Starting development environment..."
    check_docker
    load_env
    
    docker-compose -f $COMPOSE_FILE -f $COMPOSE_DEV_FILE \
        --profile dev \
        up --build --remove-orphans -d
    
    # Wait for services to be ready
    log_info "Waiting for services to be ready..."
    sleep 10
    
    # Show running services
    docker-compose ps
    
    log_success "Development environment is ready!"
    log_info "App: http://localhost:${APP_PORT:-3000}"
    log_info "API: http://localhost:${API_PORT:-3001}"
    log_info "Adminer: http://localhost:${ADMINER_PORT:-8080}"
    log_info "Redis Commander: http://localhost:${REDIS_COMMANDER_PORT:-8081}"
}

# Production environment
prod() {
    log_info "Starting production environment..."
    check_docker
    load_env
    
    docker-compose -f $COMPOSE_FILE -f $COMPOSE_PROD_FILE \
        up --build --remove-orphans -d
    
    log_success "Production environment is ready!"
}

# Stop all services
stop() {
    log_info "Stopping all services..."
    docker-compose down --remove-orphans
    log_success "All services stopped"
}

# Clean up everything
clean() {
    log_info "Cleaning up containers, networks, and volumes..."
    docker-compose down --volumes --remove-orphans --rmi local
    docker system prune -f
    log_success "Cleanup completed"
}

# View logs
logs() {
    SERVICE=${1:-app}
    log_info "Showing logs for service: $SERVICE"
    docker-compose logs -f $SERVICE
}

# Run tests
test() {
    log_info "Running tests..."
    docker-compose run --rm app npm test
    log_success "Tests completed"
}

# Database operations
db_migrate() {
    log_info "Running database migrations..."
    docker-compose exec api npm run db:migrate
    log_success "Database migrations completed"
}

db_seed() {
    log_info "Seeding database..."
    docker-compose exec api npm run db:seed
    log_success "Database seeded"
}

db_backup() {
    BACKUP_FILE="backup_$(date +%Y%m%d_%H%M%S).sql"
    log_info "Creating database backup: $BACKUP_FILE"
    docker-compose exec postgres pg_dump -U ${POSTGRES_USER:-postgres} ${POSTGRES_DB:-app_db} > ./database/backups/$BACKUP_FILE
    log_success "Database backup created: $BACKUP_FILE"
}

db_restore() {
    if [ -z "$1" ]; then
        log_error "Please specify backup file: ./dev-workflow.sh db:restore backup_file.sql"
        exit 1
    fi
    
    log_info "Restoring database from: $1"
    docker-compose exec postgres psql -U ${POSTGRES_USER:-postgres} ${POSTGRES_DB:-app_db} < ./database/backups/$1
    log_success "Database restored from: $1"
}

# Health checks
health() {
    log_info "Checking service health..."
    
    services=("app" "api" "postgres" "redis")
    
    for service in "${services[@]}"; do
        if docker-compose ps $service | grep -q "healthy\|Up"; then
            log_success "$service is healthy"
        else
            log_error "$service is not healthy"
        fi
    done
}

# Performance monitoring
monitor() {
    log_info "Starting monitoring stack..."
    docker-compose --profile monitoring up -d prometheus grafana
    
    log_success "Monitoring stack started!"
    log_info "Prometheus: http://localhost:${PROMETHEUS_PORT:-9090}"
    log_info "Grafana: http://localhost:${GRAFANA_PORT:-3001} (admin/admin)"
}

# Update services
update() {
    log_info "Updating services..."
    docker-compose pull
    docker-compose up --build -d --remove-orphans
    log_success "Services updated"
}

# Show help
help() {
    echo "React Compose Development Workflow"
    echo ""
    echo "Usage: $0 [command]"
    echo ""
    echo "Commands:"
    echo "  init          Initialize project structure"
    echo "  dev           Start development environment"
    echo "  prod          Start production environment"
    echo "  stop          Stop all services"
    echo "  clean         Clean up containers, networks, and volumes"
    echo "  logs [service] View logs (default: app)"
    echo "  test          Run tests"
    echo "  health        Check service health"
    echo "  monitor       Start monitoring stack"
    echo "  update        Update services"
    echo ""
    echo "Database commands:"
    echo "  db:migrate    Run database migrations"
    echo "  db:seed       Seed database with test data"
    echo "  db:backup     Create database backup"
    echo "  db:restore    Restore database from backup"
    echo ""
}

# Main command dispatcher
case "${1:-help}" in
    init)
        init
        ;;
    dev)
        dev
        ;;
    prod)
        prod
        ;;
    stop)
        stop
        ;;
    clean)
        clean
        ;;
    logs)
        logs $2
        ;;
    test)
        test
        ;;
    db:migrate)
        db_migrate
        ;;
    db:seed)
        db_seed
        ;;
    db:backup)
        db_backup
        ;;
    db:restore)
        db_restore $2
        ;;
    health)
        health
        ;;
    monitor)
        monitor
        ;;
    update)
        update
        ;;
    help|*)
        help
        ;;
esac
```

## Component Usage Examples

**Real-world usage of composition patterns:**
```tsx
// ✅ Usage examples
import React from 'react'

// ✅ Tabs composition example
const ExampleApp: React.FC = () => {
  return (
    <div className="app">
      <h1>Component Composition Examples</h1>
      
      {/* ✅ Tabs with compound components */}
      <Tabs defaultTab="profile" onTabChange={(tab) => console.log('Tab changed:', tab)}>
        <Tabs.List>
          <Tabs.Tab id="profile">Profile</Tabs.Tab>
          <Tabs.Tab id="settings">Settings</Tabs.Tab>
          <Tabs.Tab id="billing" disabled>Billing</Tabs.Tab>
        </Tabs.List>
        
        <Tabs.Panels>
          <Tabs.Panel id="profile">
            <UserProfile />
          </Tabs.Panel>
          <Tabs.Panel id="settings" lazy>
            <UserSettings />
          </Tabs.Panel>
          <Tabs.Panel id="billing">
            <BillingInfo />
          </Tabs.Panel>
        </Tabs.Panels>
      </Tabs>

      {/* ✅ Modal composition */}
      <Modal onClose={() => console.log('Modal closed')}>
        <Modal.Trigger>
          <button>Open Modal</button>
        </Modal.Trigger>
        
        <Modal.Content>
          <Modal.Header>
            <h2>Confirm Action</h2>
            <Modal.Close>
              <button>×</button>
            </Modal.Close>
          </Modal.Header>
          
          <Modal.Body>
            <p>Are you sure you want to perform this action?</p>
          </Modal.Body>
          
          <Modal.Footer>
            <Modal.Close>
              <button>Cancel</button>
            </Modal.Close>
            <button>Confirm</button>
          </Modal.Footer>
        </Modal.Content>
      </Modal>

      {/* ✅ Data fetching with render props */}
      <DataFetcher<User[]>
        url="/api/users"
        onSuccess={(users) => console.log('Users loaded:', users.length)}
        onError={(error) => console.error('Failed to load users:', error)}
      >
        {({ data: users, loading, error, refetch }) => {
          if (loading) return <div>Loading users...</div>
          if (error) return <div>Error: {error.message} <button onClick={refetch}>Retry</button></div>
          if (!users) return null

          return (
            <div>
              <h3>Users ({users.length})</h3>
              <ul>
                {users.map(user => (
                  <li key={user.id}>{user.name}</li>
                ))}
              </ul>
            </div>
          )
        }}
      </DataFetcher>

      {/* ✅ Form composition */}
      <Form
        initialValues={{ name: '', email: '' }}
        validation={{
          name: (value) => value.length < 2 ? 'Name must be at least 2 characters' : undefined,
          email: (value) => !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value) ? 'Invalid email' : undefined
        }}
        onSubmit={async (values) => {
          console.log('Form submitted:', values)
          // API call here
        }}
      >
        {(form) => (
          <>
            <div>
              <label>Name</label>
              <input
                type="text"
                {...form.getFieldProps('name')}
              />
              {form.state.errors.name && form.state.touched.name && (
                <span className="error">{form.state.errors.name}</span>
              )}
            </div>
            
            <div>
              <label>Email</label>
              <input
                type="email"
                {...form.getFieldProps('email')}
              />
              {form.state.errors.email && form.state.touched.email && (
                <span className="error">{form.state.errors.email}</span>
              )}
            </div>
            
            <button 
              type="submit" 
              disabled={form.state.isSubmitting || !form.state.isValid}
            >
              {form.state.isSubmitting ? 'Submitting...' : 'Submit'}
            </button>
          </>
        )}
      </Form>
    </div>
  )
}
```

## Best Practices Summary

**Key patterns for advanced composition and containerization:**

1. **Component Composition**: Use compound components for related UI elements, implement render props for data sharing, leverage HOCs for cross-cutting concerns, create type-safe composition patterns.

2. **Container Architecture**: Implement multi-stage builds, use proper security practices, optimize for development and production, implement health checks and monitoring.

3. **Development Workflow**: Automate common tasks, implement proper environment management, use Docker Compose profiles, create reproducible development environments.

4. **Performance**: Optimize Docker layers, use proper caching strategies, implement lazy loading, monitor resource usage, optimize build times.

5. **Security**: Use non-root users in containers, implement proper secret management, validate inputs, use security scanning, implement proper network isolation.

6. **Monitoring**: Implement health checks, use structured logging, monitor metrics, implement alerting, track performance.

7. **Testing**: Test composition patterns, implement container testing, test environment consistency, validate deployment processes.

8. **Maintenance**: Keep dependencies updated, implement automated backups, monitor security vulnerabilities, maintain documentation.

Always prioritize composition over inheritance, implement proper separation of concerns, use containerization for consistency, and maintain clean development workflows for scalable React applications with Docker orchestration.