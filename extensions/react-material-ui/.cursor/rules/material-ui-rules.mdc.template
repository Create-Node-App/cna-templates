---
description: You are an expert programming assistant that specializes in implementing and using Material UI components in React applications.
globs: '**/*.{ts,tsx,js,jsx}'
---

# Material UI Rules

You are an expert in Material UI and follow these guidelines:

1. Always use TypeScript for type safety and better developer experience.
2. Create components with clear, descriptive names and organize them by feature/domain.
3. Use Material UI's theming system with proper TypeScript support.
4. Leverage Material UI's responsive utilities for mobile-first design.
5. Use Material UI's color system with proper dark mode support.
6. Follow Material Design principles for consistent UX.
7. Document component behavior with JSDoc or TypeScript types.
8. Implement proper error boundaries and loading states.
9. Use proper component composition and avoid prop drilling.
10. Follow accessibility best practices (WCAG 2.1).

## Anti-Patterns to Avoid

1. Never use Material UI components without proper theming setup.
2. Avoid using Material UI components for complex, custom UI elements.
3. Don't use Material UI components for performance-critical UI elements.
4. Avoid using Material UI components for complex animations.
5. Don't use Material UI components for complex, custom layouts.

## Example Implementation

```tsx
import React from 'react';
import { 
  Card, 
  CardMedia, 
  CardContent, 
  Typography, 
  Button,
  CircularProgress,
---
description: Expert-level Material-UI v5 patterns with advanced theming, component composition, performance optimization, and accessibility.
globs: '**/*.{ts,tsx,js,jsx}'
---

# Material-UI v5 Advanced Patterns & Best Practices

## Theme Architecture & Customization

**Advanced theming with TypeScript:**
```typescript
// ✅ Extended theme with custom properties
declare module '@mui/material/styles' {
  interface Palette {
    tertiary: Palette['primary']
  }
  
  interface PaletteOptions {
    tertiary?: PaletteOptions['primary']
  }
  
  interface BreakpointOverrides {
    xs: true
    sm: true
    md: true
    lg: true
    xl: true
    xxl: true // Add custom breakpoint
  }
}

// ✅ Comprehensive theme configuration
import { createTheme, ThemeOptions } from '@mui/material/styles'

const baseTheme = createTheme({
  breakpoints: {
    values: {
      xs: 0,
      sm: 600,
      md: 900,
      lg: 1200,
      xl: 1536,
      xxl: 1920,
    },
  },
})

export const theme = createTheme(baseTheme, {
  palette: {
    mode: 'light',
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
      contrastText: '#fff',
    },
    tertiary: {
      main: '#ed6c02',
      light: '#ff9800',
      dark: '#e65100',
      contrastText: '#fff',
    },
    background: {
      default: '#fafafa',
      paper: '#fff',
    },
    text: {
      primary: 'rgba(0, 0, 0, 0.87)',
      secondary: 'rgba(0, 0, 0, 0.6)',
    },
  },
  typography: {
    fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: '3.5rem',
      fontWeight: 700,
      lineHeight: 1.2,
      [baseTheme.breakpoints.down('md')]: {
        fontSize: '2.5rem',
      },
    },
    body1: {
      fontSize: '1rem',
      lineHeight: 1.6,
    },
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          textTransform: 'none',
          fontWeight: 600,
        },
        containedPrimary: {
          background: 'linear-gradient(45deg, #1976d2 30%, #42a5f5 90%)',
          '&:hover': {
            background: 'linear-gradient(45deg, #1565c0 30%, #1976d2 90%)',
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
          '&:hover': {
            boxShadow: '0 8px 24px rgba(0, 0, 0, 0.12)',
          },
        },
      },
    },
  },
})

// ✅ Dark theme variant
export const darkTheme = createTheme(theme, {
  palette: {
    mode: 'dark',
    background: {
      default: '#121212',
      paper: '#1e1e1e',
    },
    text: {
      primary: '#fff',
      secondary: 'rgba(255, 255, 255, 0.7)',
    },
  },
})
```

## Advanced Component Patterns

**Compound components and composition:**
```tsx
import { 
  Card, 
  CardContent, 
  CardActions, 
  Typography, 
  Button,
  Skeleton,
  useTheme,
  alpha,
} from '@mui/material'
import { useState, forwardRef } from 'react'

// ✅ Polymorphic component pattern
interface BaseProps {
  children: React.ReactNode
  variant?: 'elevated' | 'outlined' | 'filled'
  loading?: boolean
}

type PolymorphicComponentProps<T extends React.ElementType> = {
  component?: T
} & BaseProps &
  Omit<React.ComponentPropsWithoutRef<T>, keyof BaseProps>

export function PolymorphicCard<T extends React.ElementType = 'div'>({
  component,
  children,
  variant = 'elevated',
  loading = false,
  ...other
}: PolymorphicComponentProps<T>) {
  const Component = component || 'div'
  const theme = useTheme()
  
  const variantStyles = {
    elevated: {
      boxShadow: theme.shadows[2],
      '&:hover': { boxShadow: theme.shadows[4] },
    },
    outlined: {
      border: `1px solid ${theme.palette.divider}`,
      boxShadow: 'none',
    },
    filled: {
      backgroundColor: alpha(theme.palette.primary.main, 0.04),
      boxShadow: 'none',
    },
  }
  
  if (loading) {
    return (
      <Card sx={variantStyles[variant]}>
        <CardContent>
          <Skeleton variant="rectangular" height={140} />
          <Skeleton variant="text" sx={{ mt: 2 }} />
          <Skeleton variant="text" width="60%" />
        </CardContent>
      </Card>
    )
  }
  
  return (
    <Card component={Component} sx={variantStyles[variant]} {...other}>
      {children}
    </Card>
  )
}

// ✅ Compound component pattern
interface ProductCardContextType {
  product: Product
  isLoading: boolean
  onAction: (action: string) => void
}

const ProductCardContext = createContext<ProductCardContextType | undefined>(undefined)

export const ProductCard = {
  Root: ({ 
    children, 
    product, 
    isLoading = false, 
    onAction 
  }: {
    children: React.ReactNode
    product: Product
    isLoading?: boolean
    onAction: (action: string) => void
  }) => (
    <ProductCardContext.Provider value={{ product, isLoading, onAction }}>
      <PolymorphicCard variant="elevated" loading={isLoading}>
        {children}
      </PolymorphicCard>
    </ProductCardContext.Provider>
  ),
  
  Media: ({ height = 200 }: { height?: number }) => {
    const context = useContext(ProductCardContext)!
    return (
      <CardMedia
        component="img"
        height={height}
        image={context.product.image}
        alt={context.product.name}
        sx={{
          objectFit: 'cover',
          transition: 'transform 0.3s ease-in-out',
          '&:hover': { transform: 'scale(1.05)' },
        }}
      />
    )
  },
  
  Content: ({ children }: { children: React.ReactNode }) => (
    <CardContent>{children}</CardContent>
  ),
  
  Title: () => {
    const context = useContext(ProductCardContext)!
    return (
      <Typography 
        variant="h6" 
        component="h3"
        gutterBottom
        sx={{ fontWeight: 600 }}
      >
        {context.product.name}
      </Typography>
    )
  },
  
  Description: ({ maxLines = 3 }: { maxLines?: number }) => {
    const context = useContext(ProductCardContext)!
    return (
      <Typography
        variant="body2"
        color="text.secondary"
        sx={{
          display: '-webkit-box',
          WebkitLineClamp: maxLines,
          WebkitBoxOrient: 'vertical',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
        }}
      >
        {context.product.description}
      </Typography>
    )
  },
  
  Actions: ({ children }: { children: React.ReactNode }) => (
    <CardActions sx={{ justifyContent: 'space-between', px: 2, pb: 2 }}>
      {children}
    </CardActions>
  ),
  
  Price: () => {
    const context = useContext(ProductCardContext)!
    const theme = useTheme()
    
    return (
      <Typography
        variant="h6"
        sx={{
          color: theme.palette.primary.main,
          fontWeight: 700,
        }}
      >
        ${context.product.price}
      </Typography>
    )
  },
}

// Usage:
<ProductCard.Root product={product} onAction={handleAction}>
  <ProductCard.Media height={240} />
  <ProductCard.Content>
    <ProductCard.Title />
    <ProductCard.Description maxLines={2} />
  </ProductCard.Content>
  <ProductCard.Actions>
    <ProductCard.Price />
    <Button variant="contained" size="small">
      Add to Cart
    </Button>
  </ProductCard.Actions>
</ProductCard.Root>
```

## Form Components & Validation

**Advanced form patterns with react-hook-form integration:**
```tsx
import { 
  TextField, 
  FormControl, 
  FormLabel, 
  FormHelperText,
  Autocomplete,
  Chip,
} from '@mui/material'
import { Controller, useFormContext } from 'react-hook-form'

// ✅ Custom form field wrapper
interface FormFieldProps {
  name: string
  label: string
  helperText?: string
  required?: boolean
  children: React.ReactElement
}

export function FormField({ 
  name, 
  label, 
  helperText, 
  required, 
  children 
}: FormFieldProps) {
  const { 
    control, 
    formState: { errors } 
  } = useFormContext()
  
  const error = errors[name]
  const hasError = !!error
  
  return (
    <Controller
      name={name}
      control={control}
      render={({ field, fieldState }) => (
        <FormControl fullWidth margin="normal" error={hasError}>
          <FormLabel component="legend" required={required}>
            {label}
          </FormLabel>
          {React.cloneElement(children, {
            ...field,
            error: hasError,
            helperText: hasError ? error?.message : helperText,
          })}
        </FormControl>
      )}
    />
  )
}

// ✅ Multi-select with chips
interface MultiSelectFieldProps {
  name: string
  label: string
  options: Array<{ value: string; label: string }>
  placeholder?: string
}

export function MultiSelectField({ 
  name, 
  label, 
  options, 
  placeholder 
}: MultiSelectFieldProps) {
  const { control } = useFormContext()
  
  return (
    <Controller
      name={name}
      control={control}
      render={({ field: { value, onChange }, fieldState }) => (
        <Autocomplete
          multiple
          options={options}
          getOptionLabel={(option) => option.label}
          value={options.filter(option => value?.includes(option.value)) || []}
          onChange={(_, newValue) => {
            onChange(newValue.map(option => option.value))
          }}
          renderTags={(value, getTagProps) =>
            value.map((option, index) => (
              <Chip
                variant="outlined"
                label={option.label}
                {...getTagProps({ index })}
                key={option.value}
              />
            ))
          }
          renderInput={(params) => (
            <TextField
              {...params}
              label={label}
              placeholder={placeholder}
              error={!!fieldState.error}
              helperText={fieldState.error?.message}
            />
          )}
        />
      )}
    />
  )
}
```

## Performance Optimization

**Optimization strategies for MUI components:**
```tsx
import { memo, useMemo, useCallback } from 'react'
import { List, ListItem, ListItemText, VirtualizedList } from '@mui/material'
import { FixedSizeList } from 'react-window'

// ✅ Virtualized list for large datasets
interface VirtualizedMuiListProps {
  items: Array<{ id: string; primary: string; secondary?: string }>
  onItemClick: (id: string) => void
  height: number
}

export const VirtualizedMuiList = memo(({ 
  items, 
  onItemClick, 
  height 
}: VirtualizedMuiListProps) => {
  const Row = useCallback(({ index, style }: { index: number; style: any }) => {
    const item = items[index]
    
    return (
      <div style={style}>
        <ListItem 
          button 
          onClick={() => onItemClick(item.id)}
          divider={index < items.length - 1}
        >
          <ListItemText
            primary={item.primary}
            secondary={item.secondary}
          />
        </ListItem>
      </div>
    )
  }, [items, onItemClick])
  
  return (
    <FixedSizeList
      height={height}
      itemCount={items.length}
      itemSize={56}
      overscanCount={5}
    >
      {Row}
    </FixedSizeList>
  )
})

// ✅ Optimized theme switching
import { ThemeProvider, createTheme } from '@mui/material/styles'

export function OptimizedThemeProvider({ children }: { children: React.ReactNode }) {
  const [mode, setMode] = useState<'light' | 'dark'>('light')
  
  // ✅ Memoize theme to prevent unnecessary re-renders
  const theme = useMemo(
    () => createTheme({
      palette: { mode },
      // ... theme configuration
    }),
    [mode]
  )
  
  const toggleMode = useCallback(() => {
    setMode(prev => prev === 'light' ? 'dark' : 'light')
  }, [])
  
  return (
    <ThemeProvider theme={theme}>
      <ThemeContext.Provider value={{ mode, toggleMode }}>
        {children}
      </ThemeContext.Provider>
    </ThemeProvider>
  )
}
```

## Accessibility Best Practices

**A11y patterns for MUI components:**
```tsx
import { 
  Button,
  IconButton, 
  Tooltip,
  useMediaQuery,
  useTheme,
} from '@mui/material'
import { useState, useId } from 'react'

// ✅ Accessible button with loading state
interface AccessibleButtonProps {
  loading?: boolean
  children: React.ReactNode
  onClick: () => void
  variant?: 'contained' | 'outlined' | 'text'
}

export function AccessibleButton({ 
  loading = false, 
  children, 
  onClick,
  variant = 'contained'
}: AccessibleButtonProps) {
  const loadingId = useId()
  
  return (
    <Button
      variant={variant}
      onClick={onClick}
      disabled={loading}
      aria-describedby={loading ? loadingId : undefined}
      aria-busy={loading}
    >
      {loading ? 'Loading...' : children}
      {loading && (
        <span 
          id={loadingId}
          className="sr-only"
          aria-live="polite"
        >
          Please wait while we process your request
        </span>
      )}
    </Button>
  )
}

// ✅ Responsive navigation with proper ARIA
export function ResponsiveNavigation() {
  const theme = useTheme()
  const isMobile = useMediaQuery(theme.breakpoints.down('md'))
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false)
  const menuId = useId()
  
  return (
    <nav role="navigation" aria-label="Main navigation">
      {isMobile ? (
        <>
          <IconButton
            aria-label="Open navigation menu"
            aria-expanded={mobileMenuOpen}
            aria-controls={menuId}
            onClick={() => setMobileMenuOpen(!mobileMenuOpen)}
          >
            <MenuIcon />
          </IconButton>
          
          <Drawer
            id={menuId}
            open={mobileMenuOpen}
            onClose={() => setMobileMenuOpen(false)}
            aria-labelledby="mobile-menu-title"
          >
            {/* Mobile menu content */}
          </Drawer>
        </>
      ) : (
        <div role="menubar">
          {/* Desktop menu items */}
        </div>
      )}
    </nav>
  )
}
```
``` 