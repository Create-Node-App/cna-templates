---
description: Advanced Electron-Vite patterns for desktop applications, IPC communication, native integrations, and cross-platform development with React.
globs: '**/*.{ts,tsx,js,jsx}, electron/**/*'
---

# Advanced Electron-Vite Desktop Applications

## Enterprise Electron Architecture

**Multi-process architecture with secure IPC communication:**
```tsx
// ✅ Main process implementation with security
// electron/main.ts
import { app, BrowserWindow, ipcMain, dialog, shell, Menu, Tray } from 'electron'
import { join } from 'path'
import { electronApp, optimizer, is } from '@electron-toolkit/utils'
import { autoUpdater } from 'electron-updater'
import contextMenu from 'electron-context-menu'

interface WindowState {
  width: number
  height: number
  x?: number
  y?: number
  isMaximized: boolean
}

class ElectronApplication {
  private mainWindow: BrowserWindow | null = null
  private splashWindow: BrowserWindow | null = null
  private tray: Tray | null = null
  private windowState: WindowState = {
    width: 1200,
    height: 800,
    isMaximized: false
  }

  constructor() {
    this.initializeApp()
    this.setupEventHandlers()
    this.setupIpcHandlers()
    this.setupAutoUpdater()
    this.setupContextMenu()
  }

  private initializeApp(): void {
    // ✅ App event handlers
    app.whenReady().then(() => {
      electronApp.setAppUserModelId('com.electron')
      
      this.createSplashWindow()
      this.createMainWindow()
      this.createTray()
      this.createApplicationMenu()
      
      app.on('activate', () => {
        if (BrowserWindow.getAllWindows().length === 0) {
          this.createMainWindow()
        }
      })
      
      // ✅ Optimize window on ready (macOS)
      app.on('browser-window-created', (_, window) => {
        optimizer.watchWindowShortcuts(window)
      })
    })

    app.on('window-all-closed', () => {
      if (process.platform !== 'darwin') {
        app.quit()
      }
    })

    app.on('before-quit', () => {
      this.saveWindowState()
    })
  }

  private createSplashWindow(): void {
    this.splashWindow = new BrowserWindow({
      width: 400,
      height: 300,
      frame: false,
      alwaysOnTop: true,
      transparent: true,
      webPreferences: {
        preload: join(__dirname, '../preload/splash.js'),
        sandbox: true,
        contextIsolation: true,
        nodeIntegration: false
      }
    })

    if (is.dev && process.env['ELECTRON_RENDERER_URL']) {
      this.splashWindow.loadURL(process.env['ELECTRON_RENDERER_URL'] + '/splash.html')
    } else {
      this.splashWindow.loadFile(join(__dirname, '../renderer/splash.html'))
    }

    // Auto-hide splash after 3 seconds
    setTimeout(() => {
      this.splashWindow?.destroy()
      this.splashWindow = null
    }, 3000)
  }

  private createMainWindow(): void {
    this.loadWindowState()

    // ✅ Secure main window configuration
    this.mainWindow = new BrowserWindow({
      ...this.windowState,
      show: false,
      autoHideMenuBar: true,
      titleBarStyle: process.platform === 'darwin' ? 'hiddenInset' : 'default',
      icon: join(__dirname, '../../resources/icon.png'),
      webPreferences: {
        preload: join(__dirname, '../preload/index.js'),
        sandbox: true,
        contextIsolation: true,
        nodeIntegration: false,
        webSecurity: true,
        allowRunningInsecureContent: false,
        experimentalFeatures: false
      }
    })

    this.mainWindow.on('ready-to-show', () => {
      this.mainWindow?.show()
      if (this.windowState.isMaximized) {
        this.mainWindow?.maximize()
      }
    })

    this.mainWindow.webContents.setWindowOpenHandler((details) => {
      shell.openExternal(details.url)
      return { action: 'deny' }
    })

    // ✅ Load the app
    if (is.dev && process.env['ELECTRON_RENDERER_URL']) {
      this.mainWindow.loadURL(process.env['ELECTRON_RENDERER_URL'])
      this.mainWindow.webContents.openDevTools()
    } else {
      this.mainWindow.loadFile(join(__dirname, '../renderer/index.html'))
    }

    // ✅ Window state management
    this.mainWindow.on('resize', () => this.handleWindowStateChange())
    this.mainWindow.on('move', () => this.handleWindowStateChange())
    this.mainWindow.on('maximize', () => this.handleWindowStateChange())
    this.mainWindow.on('unmaximize', () => this.handleWindowStateChange())
  }

  private createTray(): void {
    this.tray = new Tray(join(__dirname, '../../resources/tray-icon.png'))
    
    const contextMenu = Menu.buildFromTemplate([
      { 
        label: 'Show App', 
        click: () => this.mainWindow?.show() 
      },
      { 
        label: 'Hide App', 
        click: () => this.mainWindow?.hide() 
      },
      { type: 'separator' },
      { 
        label: 'Quit', 
        click: () => app.quit() 
      }
    ])
    
    this.tray.setToolTip('My Electron App')
    this.tray.setContextMenu(contextMenu)
    
    this.tray.on('click', () => {
      this.mainWindow?.isVisible() ? this.mainWindow?.hide() : this.mainWindow?.show()
    })
  }

  private createApplicationMenu(): void {
    const isMac = process.platform === 'darwin'
    
    const template: Electron.MenuItemConstructorOptions[] = [
      ...(isMac ? [{
        label: app.getName(),
        submenu: [
          { role: 'about' as const },
          { type: 'separator' as const },
          { role: 'services' as const },
          { type: 'separator' as const },
          { role: 'hide' as const },
          { role: 'hideOthers' as const },
          { role: 'unhide' as const },
          { type: 'separator' as const },
          { role: 'quit' as const }
        ]
      }] : []),
      {
        label: 'File',
        submenu: [
          {
            label: 'New File',
            accelerator: 'CmdOrCtrl+N',
            click: () => this.mainWindow?.webContents.send('menu-new-file')
          },
          {
            label: 'Open File',
            accelerator: 'CmdOrCtrl+O',
            click: this.handleOpenFile.bind(this)
          },
          {
            label: 'Save',
            accelerator: 'CmdOrCtrl+S',
            click: () => this.mainWindow?.webContents.send('menu-save')
          },
          { type: 'separator' },
          isMac ? { role: 'close' } : { role: 'quit' }
        ]
      },
      {
        label: 'Edit',
        submenu: [
          { role: 'undo' },
          { role: 'redo' },
          { type: 'separator' },
          { role: 'cut' },
          { role: 'copy' },
          { role: 'paste' }
        ]
      },
      {
        label: 'View',
        submenu: [
          { role: 'reload' },
          { role: 'forceReload' },
          { role: 'toggleDevTools' },
          { type: 'separator' },
          { role: 'resetZoom' },
          { role: 'zoomIn' },
          { role: 'zoomOut' },
          { type: 'separator' },
          { role: 'togglefullscreen' }
        ]
      },
      {
        label: 'Window',
        submenu: [
          { role: 'minimize' },
          { role: 'close' },
          ...(isMac ? [
            { type: 'separator' as const },
            { role: 'front' as const }
          ] : [])
        ]
      }
    ]

    const menu = Menu.buildFromTemplate(template)
    Menu.setApplicationMenu(menu)
  }

  private setupEventHandlers(): void {
    // ✅ Security handlers
    app.on('web-contents-created', (_, contents) => {
      contents.on('new-window', (event, navigationUrl) => {
        event.preventDefault()
        shell.openExternal(navigationUrl)
      })

      contents.on('will-navigate', (event, navigationUrl) => {
        const parsedUrl = new URL(navigationUrl)
        
        if (parsedUrl.origin !== process.env['ELECTRON_RENDERER_URL']) {
          event.preventDefault()
        }
      })
    })
  }

  private setupIpcHandlers(): void {
    // ✅ File system operations
    ipcMain.handle('file:open', async (): Promise<string | null> => {
      const result = await dialog.showOpenDialog(this.mainWindow!, {
        properties: ['openFile'],
        filters: [
          { name: 'Text Files', extensions: ['txt', 'md'] },
          { name: 'All Files', extensions: ['*'] }
        ]
      })

      if (!result.canceled && result.filePaths.length > 0) {
        const fs = require('fs').promises
        const content = await fs.readFile(result.filePaths[0], 'utf-8')
        return content
      }

      return null
    })

    ipcMain.handle('file:save', async (_, content: string, filePath?: string): Promise<string | null> => {
      let targetPath = filePath

      if (!targetPath) {
        const result = await dialog.showSaveDialog(this.mainWindow!, {
          filters: [
            { name: 'Text Files', extensions: ['txt', 'md'] },
            { name: 'All Files', extensions: ['*'] }
          ]
        })

        if (result.canceled) return null
        targetPath = result.filePath
      }

      if (targetPath) {
        const fs = require('fs').promises
        await fs.writeFile(targetPath, content, 'utf-8')
        return targetPath
      }

      return null
    })

    // ✅ System information
    ipcMain.handle('system:info', () => ({
      platform: process.platform,
      arch: process.arch,
      version: process.version,
      electronVersion: process.versions.electron,
      chromeVersion: process.versions.chrome
    }))

    // ✅ Window operations
    ipcMain.handle('window:minimize', () => this.mainWindow?.minimize())
    ipcMain.handle('window:maximize', () => {
      if (this.mainWindow?.isMaximized()) {
        this.mainWindow.unmaximize()
      } else {
        this.mainWindow?.maximize()
      }
    })
    ipcMain.handle('window:close', () => this.mainWindow?.close())

    // ✅ App operations
    ipcMain.handle('app:version', () => app.getVersion())
    ipcMain.handle('app:quit', () => app.quit())
    ipcMain.handle('app:relaunch', () => {
      app.relaunch()
      app.exit()
    })

    // ✅ Shell operations
    ipcMain.handle('shell:openExternal', (_, url: string) => {
      return shell.openExternal(url)
    })

    ipcMain.handle('shell:showItemInFolder', (_, path: string) => {
      shell.showItemInFolder(path)
    })

    // ✅ Notification
    ipcMain.handle('notification:show', (_, options: Electron.NotificationConstructorOptions) => {
      new Notification(options).show()
    })
  }

  private setupAutoUpdater(): void {
    if (is.dev) return

    autoUpdater.checkForUpdatesAndNotify()

    autoUpdater.on('checking-for-update', () => {
      console.log('Checking for update...')
    })

    autoUpdater.on('update-available', () => {
      dialog.showMessageBox(this.mainWindow!, {
        type: 'info',
        title: 'Update available',
        message: 'A new version is available. It will be downloaded in the background.',
        buttons: ['OK']
      })
    })

    autoUpdater.on('update-downloaded', () => {
      dialog.showMessageBox(this.mainWindow!, {
        type: 'info',
        title: 'Update ready',
        message: 'Update downloaded. Application will restart to apply the update.',
        buttons: ['Restart', 'Later']
      }).then((result) => {
        if (result.response === 0) {
          autoUpdater.quitAndInstall()
        }
      })
    })
  }

  private setupContextMenu(): void {
    contextMenu({
      showLookUpSelection: false,
      showSearchWithGoogle: false,
      showCopyImage: false,
      prepend: (defaultActions, parameters, browserWindow) => [
        {
          label: 'Custom Action',
          visible: parameters.selectionText.trim().length > 0,
          click: () => {
            console.log('Custom action clicked')
          }
        }
      ]
    })
  }

  private handleWindowStateChange(): void {
    if (!this.mainWindow) return

    const bounds = this.mainWindow.getBounds()
    this.windowState = {
      width: bounds.width,
      height: bounds.height,
      x: bounds.x,
      y: bounds.y,
      isMaximized: this.mainWindow.isMaximized()
    }
  }

  private loadWindowState(): void {
    try {
      const fs = require('fs')
      const path = require('path')
      const userDataPath = app.getPath('userData')
      const statePath = path.join(userDataPath, 'window-state.json')
      
      if (fs.existsSync(statePath)) {
        const stateData = fs.readFileSync(statePath, 'utf-8')
        this.windowState = { ...this.windowState, ...JSON.parse(stateData) }
      }
    } catch (error) {
      console.error('Failed to load window state:', error)
    }
  }

  private saveWindowState(): void {
    try {
      const fs = require('fs')
      const path = require('path')
      const userDataPath = app.getPath('userData')
      const statePath = path.join(userDataPath, 'window-state.json')
      
      fs.writeFileSync(statePath, JSON.stringify(this.windowState, null, 2))
    } catch (error) {
      console.error('Failed to save window state:', error)
    }
  }

  private async handleOpenFile(): Promise<void> {
    const result = await dialog.showOpenDialog(this.mainWindow!, {
      properties: ['openFile'],
      filters: [
        { name: 'All Files', extensions: ['*'] }
      ]
    })

    if (!result.canceled && result.filePaths.length > 0) {
      this.mainWindow?.webContents.send('file-opened', result.filePaths[0])
    }
  }
}

// Initialize the application
new ElectronApplication()
```

## Secure Preload Scripts

**Type-safe IPC bridge with security boundaries:**
```tsx
// ✅ Main preload script
// electron/preload/index.ts
import { contextBridge, ipcRenderer } from 'electron'

export interface ElectronAPI {
  // File operations
  file: {
    open: () => Promise<string | null>
    save: (content: string, filePath?: string) => Promise<string | null>
  }
  
  // System information
  system: {
    getInfo: () => Promise<{
      platform: string
      arch: string
      version: string
      electronVersion: string
      chromeVersion: string
    }>
  }
  
  // Window operations
  window: {
    minimize: () => Promise<void>
    maximize: () => Promise<void>
    close: () => Promise<void>
  }
  
  // App operations
  app: {
    getVersion: () => Promise<string>
    quit: () => Promise<void>
    relaunch: () => Promise<void>
  }
  
  // Shell operations
  shell: {
    openExternal: (url: string) => Promise<void>
    showItemInFolder: (path: string) => Promise<void>
  }
  
  // Notifications
  notification: {
    show: (options: NotificationOptions) => Promise<void>
  }
  
  // Event listeners
  on: (channel: string, callback: (...args: any[]) => void) => void
  removeAllListeners: (channel: string) => void
}

// ✅ Secure API exposure
const electronAPI: ElectronAPI = {
  file: {
    open: () => ipcRenderer.invoke('file:open'),
    save: (content: string, filePath?: string) => 
      ipcRenderer.invoke('file:save', content, filePath)
  },
  
  system: {
    getInfo: () => ipcRenderer.invoke('system:info')
  },
  
  window: {
    minimize: () => ipcRenderer.invoke('window:minimize'),
    maximize: () => ipcRenderer.invoke('window:maximize'),
    close: () => ipcRenderer.invoke('window:close')
  },
  
  app: {
    getVersion: () => ipcRenderer.invoke('app:version'),
    quit: () => ipcRenderer.invoke('app:quit'),
    relaunch: () => ipcRenderer.invoke('app:relaunch')
  },
  
  shell: {
    openExternal: (url: string) => ipcRenderer.invoke('shell:openExternal', url),
    showItemInFolder: (path: string) => ipcRenderer.invoke('shell:showItemInFolder', path)
  },
  
  notification: {
    show: (options: NotificationOptions) => 
      ipcRenderer.invoke('notification:show', options)
  },
  
  on: (channel: string, callback: (...args: any[]) => void) => {
    // Whitelist of allowed channels
    const validChannels = [
      'menu-new-file',
      'menu-save',
      'file-opened',
      'update-available',
      'update-downloaded'
    ]
    
    if (validChannels.includes(channel)) {
      ipcRenderer.on(channel, callback)
    }
  },
  
  removeAllListeners: (channel: string) => {
    ipcRenderer.removeAllListeners(channel)
  }
}

// ✅ Expose the API to the renderer process
contextBridge.exposeInMainWorld('electronAPI', electronAPI)

// ✅ Type declarations for renderer
declare global {
  interface Window {
    electronAPI: ElectronAPI
  }
}
```

## Advanced React Integration

**Electron-specific React hooks and components:**
```tsx
// ✅ Custom hooks for Electron integration
// src/hooks/useElectron.ts
import { useState, useEffect, useCallback } from 'react'

export interface SystemInfo {
  platform: string
  arch: string
  version: string
  electronVersion: string
  chromeVersion: string
}

export const useElectron = () => {
  const [isElectron] = useState(() => {
    return typeof window !== 'undefined' && window.electronAPI !== undefined
  })

  const [systemInfo, setSystemInfo] = useState<SystemInfo | null>(null)
  const [appVersion, setAppVersion] = useState<string>('')

  useEffect(() => {
    if (!isElectron) return

    // Load system information
    window.electronAPI.system.getInfo().then(setSystemInfo)
    window.electronAPI.app.getVersion().then(setAppVersion)
  }, [isElectron])

  const openFile = useCallback(async (): Promise<string | null> => {
    if (!isElectron) return null
    return window.electronAPI.file.open()
  }, [isElectron])

  const saveFile = useCallback(async (
    content: string, 
    filePath?: string
  ): Promise<string | null> => {
    if (!isElectron) return null
    return window.electronAPI.file.save(content, filePath)
  }, [isElectron])

  const minimizeWindow = useCallback(async () => {
    if (!isElectron) return
    await window.electronAPI.window.minimize()
  }, [isElectron])

  const maximizeWindow = useCallback(async () => {
    if (!isElectron) return
    await window.electronAPI.window.maximize()
  }, [isElectron])

  const closeWindow = useCallback(async () => {
    if (!isElectron) return
    await window.electronAPI.window.close()
  }, [isElectron])

  const openExternal = useCallback(async (url: string) => {
    if (!isElectron) {
      window.open(url, '_blank')
      return
    }
    await window.electronAPI.shell.openExternal(url)
  }, [isElectron])

  const showNotification = useCallback(async (options: NotificationOptions) => {
    if (!isElectron) {
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(options.title || '', {
          body: options.body,
          icon: options.icon
        })
      }
      return
    }
    await window.electronAPI.notification.show(options)
  }, [isElectron])

  const quitApp = useCallback(async () => {
    if (!isElectron) return
    await window.electronAPI.app.quit()
  }, [isElectron])

  const relaunchApp = useCallback(async () => {
    if (!isElectron) return
    await window.electronAPI.app.relaunch()
  }, [isElectron])

  return {
    isElectron,
    systemInfo,
    appVersion,
    openFile,
    saveFile,
    minimizeWindow,
    maximizeWindow,
    closeWindow,
    openExternal,
    showNotification,
    quitApp,
    relaunchApp
  }
}

// ✅ File management hook
export const useFileManager = () => {
  const { isElectron, openFile, saveFile } = useElectron()
  const [currentFile, setCurrentFile] = useState<string | null>(null)
  const [fileContent, setFileContent] = useState<string>('')
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false)

  const openFileDialog = useCallback(async () => {
    const content = await openFile()
    if (content !== null) {
      setFileContent(content)
      setHasUnsavedChanges(false)
    }
  }, [openFile])

  const saveFileDialog = useCallback(async () => {
    const filePath = await saveFile(fileContent, currentFile)
    if (filePath) {
      setCurrentFile(filePath)
      setHasUnsavedChanges(false)
      return filePath
    }
    return null
  }, [saveFile, fileContent, currentFile])

  const updateContent = useCallback((content: string) => {
    setFileContent(content)
    setHasUnsavedChanges(true)
  }, [])

  const newFile = useCallback(() => {
    setCurrentFile(null)
    setFileContent('')
    setHasUnsavedChanges(false)
  }, [])

  useEffect(() => {
    if (!isElectron) return

    const handleNewFile = () => newFile()
    const handleSave = () => saveFileDialog()

    window.electronAPI.on('menu-new-file', handleNewFile)
    window.electronAPI.on('menu-save', handleSave)

    return () => {
      window.electronAPI.removeAllListeners('menu-new-file')
      window.electronAPI.removeAllListeners('menu-save')
    }
  }, [isElectron, newFile, saveFileDialog])

  return {
    currentFile,
    fileContent,
    hasUnsavedChanges,
    openFileDialog,
    saveFileDialog,
    updateContent,
    newFile
  }
}

// ✅ Window controls component
export const WindowControls: React.FC = () => {
  const { isElectron, minimizeWindow, maximizeWindow, closeWindow } = useElectron()
  const [isMaximized, setIsMaximized] = useState(false)

  if (!isElectron) return null

  const handleMaximize = async () => {
    await maximizeWindow()
    setIsMaximized(!isMaximized)
  }

  return (
    <div className="window-controls">
      <button 
        className="window-control minimize"
        onClick={minimizeWindow}
        aria-label="Minimize"
      >
        <svg width="12" height="12" viewBox="0 0 12 12">
          <path d="M2 6h8" stroke="currentColor" strokeWidth="1"/>
        </svg>
      </button>
      
      <button 
        className="window-control maximize"
        onClick={handleMaximize}
        aria-label={isMaximized ? "Restore" : "Maximize"}
      >
        <svg width="12" height="12" viewBox="0 0 12 12">
          {isMaximized ? (
            <path d="M3 3h6v6H3z M5 1h6v6" stroke="currentColor" strokeWidth="1" fill="none"/>
          ) : (
            <path d="M2 2h8v8H2z" stroke="currentColor" strokeWidth="1" fill="none"/>
          )}
        </svg>
      </button>
      
      <button 
        className="window-control close"
        onClick={closeWindow}
        aria-label="Close"
      >
        <svg width="12" height="12" viewBox="0 0 12 12">
          <path d="M3 3l6 6M9 3l-6 6" stroke="currentColor" strokeWidth="1"/>
        </svg>
      </button>
    </div>
  )
}

// ✅ Status bar component
export const StatusBar: React.FC = () => {
  const { isElectron, systemInfo, appVersion } = useElectron()

  if (!isElectron || !systemInfo) return null

  return (
    <div className="status-bar">
      <div className="status-item">
        <span>Platform: {systemInfo.platform}</span>
      </div>
      <div className="status-item">
        <span>Version: {appVersion}</span>
      </div>
      <div className="status-item">
        <span>Electron: {systemInfo.electronVersion}</span>
      </div>
    </div>
  )
}

// ✅ Main application component
export const ElectronApp: React.FC = () => {
  const { isElectron } = useElectron()
  const { 
    fileContent, 
    hasUnsavedChanges, 
    currentFile,
    openFileDialog, 
    saveFileDialog, 
    updateContent, 
    newFile 
  } = useFileManager()

  return (
    <div className="electron-app">
      {isElectron && (
        <div className="title-bar">
          <div className="title-bar-content">
            <span className="app-title">
              {currentFile ? `${currentFile}${hasUnsavedChanges ? ' •' : ''}` : 'Untitled'}
            </span>
          </div>
          <WindowControls />
        </div>
      )}

      <div className="toolbar">
        <button onClick={newFile}>New</button>
        <button onClick={openFileDialog}>Open</button>
        <button onClick={saveFileDialog} disabled={!hasUnsavedChanges}>
          Save
        </button>
      </div>

      <div className="main-content">
        <textarea
          value={fileContent}
          onChange={(e) => updateContent(e.target.value)}
          placeholder="Start typing..."
          className="editor"
        />
      </div>

      <StatusBar />
    </div>
  )
}
```

## Advanced Vite Configuration

**Optimized Vite setup for Electron development:**
```tsx
// ✅ Advanced Vite configuration
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { resolve } from 'path'
import { rmSync } from 'fs'
import { defineConfig as defineElectronConfig } from 'vite-plugin-electron'
import pkg from './package.json'

export default defineConfig(({ command }) => {
  rmSync('dist-electron', { recursive: true, force: true })

  const isServe = command === 'serve'
  const isBuild = command === 'build'
  const sourcemap = isServe || !!process.env.VSCODE_DEBUG

  return {
    plugins: [
      react(),
      // ✅ Electron plugin configuration
      defineElectronConfig([
        {
          // Main process
          entry: 'electron/main.ts',
          onstart(args) {
            if (process.env.VSCODE_DEBUG) {
              console.log('Electron App is ready for debugging')
            } else {
              args.startup()
            }
          },
          vite: {
            build: {
              sourcemap,
              minify: isBuild,
              outDir: 'dist-electron',
              rollupOptions: {
                external: Object.keys('dependencies' in pkg ? pkg.dependencies : {})
              }
            }
          }
        },
        {
          // Preload scripts
          entry: 'electron/preload/index.ts',
          onstart(args) {
            args.reload()
          },
          vite: {
            build: {
              sourcemap: sourcemap ? 'inline' : undefined,
              minify: isBuild,
              outDir: 'dist-electron/preload',
              rollupOptions: {
                external: Object.keys('dependencies' in pkg ? pkg.dependencies : {})
              }
            }
          }
        },
        {
          // Splash preload
          entry: 'electron/preload/splash.ts',
          onstart(args) {
            args.reload()
          },
          vite: {
            build: {
              sourcemap: sourcemap ? 'inline' : undefined,
              minify: isBuild,
              outDir: 'dist-electron/preload',
              rollupOptions: {
                external: Object.keys('dependencies' in pkg ? pkg.dependencies : {})
              }
            }
          }
        }
      ])
    ],
    
    // ✅ Renderer process configuration
    build: {
      outDir: 'dist-electron/renderer',
      sourcemap,
      rollupOptions: {
        input: {
          index: resolve(__dirname, 'index.html'),
          splash: resolve(__dirname, 'splash.html')
        }
      }
    },

    resolve: {
      alias: {
        '@': resolve(__dirname, 'src'),
        '@electron': resolve(__dirname, 'electron'),
        '@components': resolve(__dirname, 'src/components'),
        '@hooks': resolve(__dirname, 'src/hooks'),
        '@utils': resolve(__dirname, 'src/utils'),
        '@assets': resolve(__dirname, 'src/assets')
      }
    },

    // ✅ Development server configuration
    server: {
      port: 3000,
      host: process.env.VITE_DEV_SERVER_HOST,
      hmr: {
        port: 3001
      }
    },

    // ✅ Environment variables
    define: {
      __APP_VERSION__: JSON.stringify(pkg.version)
    },

    // ✅ CSS configuration
    css: {
      modules: {
        localsConvention: 'camelCase'
      },
      preprocessorOptions: {
        scss: {
          additionalData: `@import "@/styles/variables.scss";`
        }
      }
    },

    // ✅ Optimization
    optimizeDeps: {
      include: [
        'react',
        'react-dom',
        'react-router-dom'
      ]
    }
  }
})

// ✅ Electron builder configuration
// electron-builder.json5
{
  "appId": "com.example.myapp",
  "productName": "My Electron App",
  "copyright": "Copyright © 2023 ${author}",
  "directories": {
    "output": "release/${version}"
  },
  "files": [
    "dist-electron"
  ],
  "mac": {
    "target": [
      {
        "target": "default",
        "arch": [
          "arm64",
          "x64"
        ]
      }
    ],
    "artifactName": "${productName}-Mac-${version}-Installer.${ext}",
    "icon": "build/icon.icns",
    "category": "public.app-category.productivity",
    "hardenedRuntime": true,
    "gatekeeperAssess": false,
    "entitlements": "build/entitlements.mac.plist",
    "entitlementsInherit": "build/entitlements.mac.plist"
  },
  "win": {
    "target": [
      {
        "target": "nsis",
        "arch": [
          "x64"
        ]
      }
    ],
    "artifactName": "${productName}-Windows-${version}-Setup.${ext}",
    "icon": "build/icon.ico"
  },
  "linux": {
    "target": [
      {
        "target": "AppImage",
        "arch": [
          "x64"
        ]
      }
    ],
    "artifactName": "${productName}-Linux-${version}.${ext}",
    "icon": "build/icon.png",
    "category": "Office"
  },
  "nsis": {
    "oneClick": false,
    "perMachine": false,
    "allowToChangeInstallationDirectory": true,
    "deleteAppDataOnUninstall": false
  },
  "publish": {
    "provider": "github",
    "owner": "your-username",
    "repo": "your-repo-name"
  },
  "extraResources": [
    {
      "from": "resources",
      "to": "resources",
      "filter": [
        "**/*"
      ]
    }
  ]
}
```

## Testing Electron Applications

**Comprehensive testing strategies for Electron apps:**
```tsx
// ✅ Spectron testing setup
// __tests__/electron/app.test.ts
import { Application } from 'spectron'
import path from 'path'

describe('Electron Application', () => {
  let app: Application

  beforeEach(async () => {
    app = new Application({
      path: path.join(__dirname, '../../dist-electron/main.js'),
      args: [path.join(__dirname, '../../')],
      env: {
        NODE_ENV: 'test'
      },
      startTimeout: 30000,
      waitTimeout: 30000
    })

    await app.start()
  })

  afterEach(async () => {
    if (app && app.isRunning()) {
      await app.stop()
    }
  })

  it('should launch successfully', async () => {
    const isVisible = await app.browserWindow.isVisible()
    expect(isVisible).toBe(true)

    const title = await app.client.getTitle()
    expect(title).toBe('My Electron App')
  })

  it('should have correct window dimensions', async () => {
    const bounds = await app.browserWindow.getBounds()
    expect(bounds.width).toBeGreaterThan(0)
    expect(bounds.height).toBeGreaterThan(0)
  })

  it('should open file dialog', async () => {
    await app.client.click('[data-testid="open-file-button"]')
    // Verify dialog opened (implementation depends on your specific setup)
  })

  it('should handle window controls', async () => {
    await app.client.click('.window-control.minimize')
    const isMinimized = await app.browserWindow.isMinimized()
    expect(isMinimized).toBe(true)
  })

  it('should save window state', async () => {
    await app.browserWindow.setBounds({
      x: 100,
      y: 100,
      width: 800,
      height: 600
    })

    await app.restart()

    const bounds = await app.browserWindow.getBounds()
    expect(bounds.width).toBe(800)
    expect(bounds.height).toBe(600)
  })
})

// ✅ IPC testing
// __tests__/electron/ipc.test.ts
import { ipcRenderer } from 'electron'

// Mock IPC for testing
const mockIpcRenderer = {
  invoke: jest.fn(),
  on: jest.fn(),
  removeAllListeners: jest.fn()
}

Object.defineProperty(window, 'electronAPI', {
  value: {
    file: {
      open: () => mockIpcRenderer.invoke('file:open'),
      save: (content: string, filePath?: string) => 
        mockIpcRenderer.invoke('file:save', content, filePath)
    },
    system: {
      getInfo: () => mockIpcRenderer.invoke('system:info')
    }
  }
})

describe('IPC Communication', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  it('should handle file open', async () => {
    mockIpcRenderer.invoke.mockResolvedValueOnce('file content')

    const content = await window.electronAPI.file.open()
    expect(content).toBe('file content')
    expect(mockIpcRenderer.invoke).toHaveBeenCalledWith('file:open')
  })

  it('should handle file save', async () => {
    const filePath = '/path/to/file.txt'
    mockIpcRenderer.invoke.mockResolvedValueOnce(filePath)

    const result = await window.electronAPI.file.save('content', filePath)
    expect(result).toBe(filePath)
    expect(mockIpcRenderer.invoke).toHaveBeenCalledWith('file:save', 'content', filePath)
  })

  it('should get system info', async () => {
    const systemInfo = {
      platform: 'darwin',
      arch: 'x64',
      version: 'v16.0.0',
      electronVersion: '13.0.0',
      chromeVersion: '91.0.4472.0'
    }
    
    mockIpcRenderer.invoke.mockResolvedValueOnce(systemInfo)

    const info = await window.electronAPI.system.getInfo()
    expect(info).toEqual(systemInfo)
    expect(mockIpcRenderer.invoke).toHaveBeenCalledWith('system:info')
  })
})

// ✅ React component testing with Electron context
// __tests__/components/ElectronApp.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { ElectronApp } from '@/components/ElectronApp'

// Mock the useElectron hook
jest.mock('@/hooks/useElectron', () => ({
  useElectron: () => ({
    isElectron: true,
    systemInfo: {
      platform: 'darwin',
      arch: 'x64',
      version: 'v16.0.0',
      electronVersion: '13.0.0',
      chromeVersion: '91.0.4472.0'
    },
    appVersion: '1.0.0',
    openFile: jest.fn().mockResolvedValue('test content'),
    saveFile: jest.fn().mockResolvedValue('/path/to/file.txt'),
    minimizeWindow: jest.fn(),
    maximizeWindow: jest.fn(),
    closeWindow: jest.fn()
  }),
  useFileManager: () => ({
    fileContent: 'test content',
    hasUnsavedChanges: false,
    currentFile: null,
    openFileDialog: jest.fn(),
    saveFileDialog: jest.fn(),
    updateContent: jest.fn(),
    newFile: jest.fn()
  })
}))

describe('ElectronApp Component', () => {
  it('renders correctly', () => {
    render(<ElectronApp />)
    
    expect(screen.getByText('New')).toBeInTheDocument()
    expect(screen.getByText('Open')).toBeInTheDocument()
    expect(screen.getByText('Save')).toBeInTheDocument()
  })

  it('shows window controls in Electron environment', () => {
    render(<ElectronApp />)
    
    expect(screen.getByLabelText('Minimize')).toBeInTheDocument()
    expect(screen.getByLabelText('Maximize')).toBeInTheDocument()
    expect(screen.getByLabelText('Close')).toBeInTheDocument()
  })

  it('displays status bar with system information', () => {
    render(<ElectronApp />)
    
    expect(screen.getByText('Platform: darwin')).toBeInTheDocument()
    expect(screen.getByText('Version: 1.0.0')).toBeInTheDocument()
    expect(screen.getByText('Electron: 13.0.0')).toBeInTheDocument()
  })
})
```

## Security Best Practices

**Enterprise-grade security implementation:**
```tsx
// ✅ Security configuration and CSP
// electron/security.ts
import { session, BrowserWindow } from 'electron'

export class ElectronSecurity {
  static setupSecurity(window: BrowserWindow): void {
    // ✅ Content Security Policy
    session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
      callback({
        responseHeaders: {
          ...details.responseHeaders,
          'Content-Security-Policy': [
            "default-src 'self' 'unsafe-inline' data:;",
            "script-src 'self' 'unsafe-inline' 'unsafe-eval';",
            "style-src 'self' 'unsafe-inline';",
            "img-src 'self' data: https:;",
            "font-src 'self' data:;",
            "connect-src 'self' https:;",
            "media-src 'self';",
            "object-src 'none';",
            "child-src 'none';",
            "frame-src 'none';",
            "worker-src 'none';",
            "frame-ancestors 'none';",
            "form-action 'self';",
            "base-uri 'self';",
            "manifest-src 'self';"
          ].join(' ')
        }
      })
    })

    // ✅ Disable node integration in renderer
    window.webContents.on('new-window', (event, url) => {
      event.preventDefault()
      require('electron').shell.openExternal(url)
    })

    // ✅ Validate all IPC calls
    window.webContents.on('ipc-message', (event, channel, ...args) => {
      console.log('IPC Message:', channel, args)
      // Add validation logic here
    })

    // ✅ Permission management
    session.defaultSession.setPermissionRequestHandler((webContents, permission, callback) => {
      const allowedPermissions = [
        'notifications',
        'clipboard-read',
        'clipboard-write'
      ]
      
      callback(allowedPermissions.includes(permission))
    })

    // ✅ Certificate validation
    session.defaultSession.setCertificateVerifyProc((request, callback) => {
      // Implement custom certificate validation if needed
      callback(0) // 0 = success, -1 = failure
    })
  }

  static sanitizeInput(input: string): string {
    return input
      .replace(/[<>]/g, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+=/gi, '')
      .trim()
  }

  static validateFilePath(filePath: string): boolean {
    // Prevent directory traversal
    const normalizedPath = require('path').normalize(filePath)
    return !normalizedPath.includes('..')
  }
}
```

## Performance Optimization

**Advanced optimization techniques for Electron applications:**
```tsx
// ✅ Performance monitoring and optimization
// src/utils/performance.ts
export class PerformanceMonitor {
  private static instance: PerformanceMonitor
  private metrics: Map<string, number[]> = new Map()
  private memoryUsage: NodeJS.MemoryUsage[] = []

  static getInstance(): PerformanceMonitor {
    if (!PerformanceMonitor.instance) {
      PerformanceMonitor.instance = new PerformanceMonitor()
    }
    return PerformanceMonitor.instance
  }

  measureOperation<T>(name: string, operation: () => T): T {
    const start = performance.now()
    const result = operation()
    const duration = performance.now() - start

    const measurements = this.metrics.get(name) || []
    measurements.push(duration)
    this.metrics.set(name, measurements)

    if (duration > 100) {
      console.warn(`Slow operation detected: ${name} took ${duration.toFixed(2)}ms`)
    }

    return result
  }

  async measureAsyncOperation<T>(name: string, operation: () => Promise<T>): Promise<T> {
    const start = performance.now()
    const result = await operation()
    const duration = performance.now() - start

    const measurements = this.metrics.get(name) || []
    measurements.push(duration)
    this.metrics.set(name, measurements)

    return result
  }

  trackMemoryUsage(): void {
    if (process.type === 'renderer') {
      // @ts-ignore
      const memInfo = performance.memory
      this.memoryUsage.push({
        rss: memInfo.totalJSHeapSize,
        heapTotal: memInfo.totalJSHeapSize,
        heapUsed: memInfo.usedJSHeapSize,
        external: 0,
        arrayBuffers: 0
      })
    }

    // Keep only last 100 measurements
    if (this.memoryUsage.length > 100) {
      this.memoryUsage = this.memoryUsage.slice(-100)
    }
  }

  getStats() {
    const stats: Record<string, any> = {}

    for (const [name, measurements] of this.metrics.entries()) {
      const avg = measurements.reduce((a, b) => a + b, 0) / measurements.length
      const max = Math.max(...measurements)
      const min = Math.min(...measurements)

      stats[name] = {
        average: Math.round(avg * 100) / 100,
        maximum: Math.round(max * 100) / 100,
        minimum: Math.round(min * 100) / 100,
        count: measurements.length
      }
    }

    return stats
  }

  startMemoryMonitoring(intervalMs: number = 10000): void {
    setInterval(() => {
      this.trackMemoryUsage()
    }, intervalMs)
  }
}

// ✅ Resource optimization utilities
export const ResourceOptimizer = {
  // Lazy load components
  lazyLoad: <T extends React.ComponentType<any>>(
    importFn: () => Promise<{ default: T }>
  ) => {
    return React.lazy(importFn)
  },

  // Image optimization
  optimizeImage: (src: string, width?: number, height?: number): string => {
    if (!width && !height) return src
    
    // In a real app, you might use a service like Cloudinary
    // For now, return original src
    return src
  },

  // Bundle size analysis
  analyzeBundleSize: () => {
    if (process.env.NODE_ENV === 'development') {
      console.log('Bundle analysis would go here')
      // Integration with webpack-bundle-analyzer or similar
    }
  }
}

// ✅ Performance hooks
export const usePerformanceMonitoring = () => {
  const monitor = PerformanceMonitor.getInstance()

  const measureRender = useCallback((componentName: string) => {
    return monitor.measureOperation(`${componentName}_render`, () => {
      // Render measurement logic
    })
  }, [monitor])

  const trackUserAction = useCallback((actionName: string, fn: () => void) => {
    monitor.measureOperation(`user_action_${actionName}`, fn)
  }, [monitor])

  return {
    measureRender,
    trackUserAction,
    getStats: monitor.getStats.bind(monitor)
  }
}
```

## Best Practices Summary

**Key patterns for enterprise Electron applications:**

1. **Security First**: Implement context isolation, disable node integration in renderer, use CSP headers, validate all IPC communication, implement proper permission management.

2. **Architecture**: Use multi-process architecture, separate main/renderer concerns, implement proper IPC patterns, use TypeScript for type safety.

3. **Performance**: Implement lazy loading, optimize bundle size, monitor performance metrics, use efficient IPC communication, implement proper caching strategies.

4. **Development**: Use hot module replacement, implement comprehensive testing, use proper debugging tools, implement proper error handling.

5. **Distribution**: Use proper code signing, implement auto-updates, optimize build configurations, handle native dependencies correctly.

6. **User Experience**: Implement proper window management, handle offline scenarios, provide native integrations, implement proper notifications.

7. **Maintenance**: Monitor application health, implement proper logging, use analytics for insights, maintain security updates.

8. **Testing**: Test IPC communication, test multi-platform compatibility, implement E2E testing, test security boundaries.

Always prioritize security and performance in Electron applications, leverage native platform features appropriately, and maintain clean separation between main and renderer processes for scalable desktop applications. 