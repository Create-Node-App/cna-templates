---
description: Advanced Redux Thunk patterns for async state management, action composition, error handling, and performance optimization.
globs: '**/*.{ts,tsx,js,jsx}', '**/store/**/*.{ts,js}', '**/redux/**/*.{ts,js}'
---

# Advanced Redux Thunk Patterns

## Modern Redux Toolkit with Thunk

**Type-safe async actions with RTK:**
```typescript
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit'
import { RootState } from './store'
import { UserService, User, LoginCredentials } from '../services/userService'

// ✅ Async thunk with proper typing and error handling
export const loginUser = createAsyncThunk<
  User, // Return type
  LoginCredentials, // Arg type
  {
    state: RootState
    rejectValue: string
    extra: { analytics: Analytics }
  }
>('auth/login', async (credentials, { rejectWithValue, extra, dispatch }) => {
  try {
    // ✅ Pre-validation
    if (!credentials.email || !credentials.password) {
      return rejectWithValue('Email and password are required')
    }

    // ✅ API call with timeout
    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), 10000)

    const user = await UserService.login(credentials, {
      signal: controller.signal
    })

    clearTimeout(timeoutId)

    // ✅ Side effects after successful login
    extra.analytics.track('User Login', { 
      userId: user.id, 
      method: 'email' 
    })

    // ✅ Dispatch additional actions
    dispatch(fetchUserPreferences(user.id))
    dispatch(initializeUserSession(user))

    return user

  } catch (error: any) {
    // ✅ Structured error handling
    if (error.name === 'AbortError') {
      return rejectWithValue('Login request timed out')
    }
    
    if (error.response?.status === 401) {
      return rejectWithValue('Invalid email or password')
    }
    
    if (error.response?.status === 429) {
      return rejectWithValue('Too many login attempts. Please try again later.')
    }

    return rejectWithValue(
      error.response?.data?.message || 'Login failed. Please try again.'
    )
  }
})

// ✅ Complex async thunk with dependent API calls
export const updateUserProfile = createAsyncThunk<
  User,
  { userId: string; updates: Partial<User>; profileImage?: File },
  { state: RootState; rejectValue: string }
>('user/updateProfile', async ({ userId, updates, profileImage }, { 
  rejectWithValue, 
  getState, 
  dispatch 
}) => {
  try {
    // ✅ Check current state before proceeding
    const currentUser = getState().auth.user
    if (!currentUser || currentUser.id !== userId) {
      return rejectWithValue('User not authenticated')
    }

    // ✅ Sequential async operations
    let imageUrl: string | undefined

    if (profileImage) {
      // Upload image first
      imageUrl = await UserService.uploadProfileImage(userId, profileImage)
      
      // ✅ Dispatch intermediate update for immediate UI feedback
      dispatch(userSlice.actions.updateUserOptimistic({
        ...updates,
        profileImageUrl: imageUrl
      }))
    }

    // ✅ Update user profile
    const updatedUser = await UserService.updateProfile(userId, {
      ...updates,
      ...(imageUrl && { profileImageUrl: imageUrl })
    })

    // ✅ Refresh related data
    dispatch(refreshUserStats(userId))

    return updatedUser

  } catch (error: any) {
    // ✅ Rollback optimistic update on error
    dispatch(userSlice.actions.rollbackOptimisticUpdate())
    
    return rejectWithValue(
      error.response?.data?.message || 'Failed to update profile'
    )
  }
})

// ✅ Batch operations with thunk
export const batchUserActions = createAsyncThunk<
  { completed: string[]; failed: string[] },
  Array<{ type: 'follow' | 'unfollow' | 'block'; userId: string }>,
  { state: RootState; rejectValue: string }
>('user/batchActions', async (actions, { rejectWithValue, dispatch }) => {
  const results: { completed: string[]; failed: string[] } = {
    completed: [],
    failed: []
  }

  // ✅ Process actions in chunks to avoid overwhelming the server
  const chunks = chunkArray(actions, 5)
  
  for (const chunk of chunks) {
    const promises = chunk.map(async (action) => {
      try {
        switch (action.type) {
          case 'follow':
            await UserService.followUser(action.userId)
            break
          case 'unfollow':
            await UserService.unfollowUser(action.userId)
            break
          case 'block':
            await UserService.blockUser(action.userId)
            break
        }
        results.completed.push(action.userId)
      } catch (error) {
        results.failed.push(action.userId)
      }
    })

    await Promise.allSettled(promises)
    
    // ✅ Small delay between chunks
    await new Promise(resolve => setTimeout(resolve, 100))
  }

  // ✅ Update UI with batch results
  dispatch(notificationSlice.actions.addNotification({
    type: 'success',
    message: `Batch operation completed: ${results.completed.length} successful, ${results.failed.length} failed`
  }))

  return results
})

// ✅ User slice with comprehensive async handling
interface UserState {
  user: User | null
  isLoading: boolean
  error: string | null
  optimisticUpdates: Partial<User> | null
  lastLoginTime: string | null
  loginAttempts: number
  isRefreshing: boolean
}

const initialState: UserState = {
  user: null,
  isLoading: false,
  error: null,
  optimisticUpdates: null,
  lastLoginTime: null,
  loginAttempts: 0,
  isRefreshing: false
}

export const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    // ✅ Sync actions for immediate state updates
    updateUserOptimistic: (state, action: PayloadAction<Partial<User>>) => {
      state.optimisticUpdates = action.payload
    },
    
    rollbackOptimisticUpdate: (state) => {
      state.optimisticUpdates = null
    },
    
    clearError: (state) => {
      state.error = null
    },
    
    incrementLoginAttempts: (state) => {
      state.loginAttempts += 1
    },
    
    resetLoginAttempts: (state) => {
      state.loginAttempts = 0
    },
    
    logout: (state) => {
      state.user = null
      state.optimisticUpdates = null
      state.lastLoginTime = null
      state.error = null
    }
  },
  extraReducers: (builder) => {
    // ✅ Login async action handling
    builder
      .addCase(loginUser.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(loginUser.fulfilled, (state, action) => {
        state.isLoading = false
        state.user = action.payload
        state.lastLoginTime = new Date().toISOString()
        state.loginAttempts = 0
        state.error = null
      })
      .addCase(loginUser.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload || 'Login failed'
        state.loginAttempts += 1
      })

    // ✅ Update profile async action handling
    builder
      .addCase(updateUserProfile.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(updateUserProfile.fulfilled, (state, action) => {
        state.isLoading = false
        state.user = action.payload
        state.optimisticUpdates = null
        state.error = null
      })
      .addCase(updateUserProfile.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload || 'Update failed'
        state.optimisticUpdates = null
      })

    // ✅ Batch actions handling
    builder
      .addCase(batchUserActions.pending, (state) => {
        state.isLoading = true
      })
      .addCase(batchUserActions.fulfilled, (state, action) => {
        state.isLoading = false
        // Handle batch results if needed
      })
      .addCase(batchUserActions.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload || 'Batch operation failed'
      })
  }
})
```

## Complex Thunk Patterns

**Advanced async flow composition:**
```typescript
// ✅ Conditional thunk execution
export const smartDataRefresh = createAsyncThunk<
  void,
  void,
  { state: RootState }
>('data/smartRefresh', async (_, { getState, dispatch }) => {
  const state = getState()
  const now = Date.now()
  const lastRefresh = state.data.lastRefreshTime
  
  // ✅ Only refresh if data is stale (older than 5 minutes)
  if (lastRefresh && (now - lastRefresh) < 5 * 60 * 1000) {
    return // Skip refresh if data is fresh
  }

  // ✅ Check what needs refreshing
  const promises: Promise<any>[] = []
  
  if (!state.user.user) {
    promises.push(dispatch(fetchUserProfile()).unwrap())
  }
  
  if (state.notifications.unreadCount === -1) {
    promises.push(dispatch(fetchUnreadNotifications()).unwrap())
  }
  
  if (state.dashboard.data.length === 0) {
    promises.push(dispatch(fetchDashboardData()).unwrap())
  }

  // ✅ Execute refreshes in parallel
  await Promise.allSettled(promises)
})

// ✅ Retry mechanism with exponential backoff
export const createRetryThunk = <T, U>(
  baseThunk: AsyncThunkAction<T, U, any>,
  maxRetries: number = 3
) => {
  return createAsyncThunk<T, U, { state: RootState; rejectValue: string }>(
    `${baseThunk.type}/retry`,
    async (arg, { dispatch, rejectWithValue }) => {
      let lastError: any
      
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          const result = await dispatch(baseThunk(arg)).unwrap()
          return result
        } catch (error) {
          lastError = error
          
          if (attempt < maxRetries) {
            // ✅ Exponential backoff: 1s, 2s, 4s
            const delay = Math.pow(2, attempt - 1) * 1000
            await new Promise(resolve => setTimeout(resolve, delay))
          }
        }
      }
      
      return rejectWithValue(`Failed after ${maxRetries} attempts: ${lastError}`)
    }
  )
}

// ✅ Usage of retry thunk
export const fetchUserProfileWithRetry = createRetryThunk(fetchUserProfile, 3)

// ✅ Polling thunk for real-time updates
export const startPolling = createAsyncThunk<
  void,
  { endpoint: string; interval: number },
  { state: RootState }
>('polling/start', async ({ endpoint, interval }, { dispatch, getState }) => {
  const pollData = async () => {
    const state = getState()
    
    // ✅ Stop polling if user navigates away or logs out
    if (!state.user.user || !state.app.isVisible) {
      return
    }

    try {
      await dispatch(fetchDataFromEndpoint(endpoint)).unwrap()
    } catch (error) {
      console.warn('Polling error:', error)
    }

    // ✅ Schedule next poll
    setTimeout(pollData, interval)
  }

  // ✅ Start polling
  pollData()
})

// ✅ Debounced search thunk
export const debouncedSearch = createAsyncThunk<
  SearchResult[],
  string,
  { state: RootState }
>('search/debounced', async (query, { getState }) => {
  // ✅ This thunk will be debounced in the component
  const state = getState()
  
  if (!query.trim()) {
    return []
  }

  const results = await SearchService.search(query, {
    userId: state.user.user?.id,
    filters: state.search.filters
  })

  return results
})
```

## Performance Optimization Patterns

**Efficient state management with selectors:**
```typescript
import { createSelector } from '@reduxjs/toolkit'
import { RootState } from './store'

// ✅ Memoized selectors for computed values
export const selectUser = (state: RootState) => state.user.user
export const selectOptimisticUser = createSelector(
  [selectUser, (state: RootState) => state.user.optimisticUpdates],
  (user, optimisticUpdates) => {
    if (!user) return null
    return optimisticUpdates ? { ...user, ...optimisticUpdates } : user
  }
)

export const selectUserPermissions = createSelector(
  [selectUser],
  (user) => {
    if (!user) return []
    
    const basePermissions = ['read']
    
    switch (user.role) {
      case 'admin':
        return [...basePermissions, 'write', 'delete', 'manage']
      case 'moderator':
        return [...basePermissions, 'write', 'moderate']
      case 'premium':
        return [...basePermissions, 'premium-features']
      default:
        return basePermissions
    }
  }
)

// ✅ Complex derived state with multiple dependencies
export const selectDashboardStats = createSelector(
  [
    (state: RootState) => state.user.user,
    (state: RootState) => state.projects.items,
    (state: RootState) => state.tasks.items,
    (state: RootState) => state.analytics.data
  ],
  (user, projects, tasks, analytics) => {
    if (!user) return null

    const userProjects = projects.filter(p => p.ownerId === user.id)
    const userTasks = tasks.filter(t => t.assigneeId === user.id)
    
    return {
      projectCount: userProjects.length,
      activeProjects: userProjects.filter(p => p.status === 'active').length,
      totalTasks: userTasks.length,
      completedTasks: userTasks.filter(t => t.status === 'completed').length,
      productivityScore: analytics?.productivityScore || 0,
      weeklyProgress: analytics?.weeklyProgress || []
    }
  }
)

// ✅ Normalized state selectors
export const selectProjectById = createSelector(
  [(state: RootState) => state.projects.entities, (_, id: string) => id],
  (entities, id) => entities[id]
)

export const selectProjectsByStatus = createSelector(
  [(state: RootState) => state.projects.entities, (_, status: string) => status],
  (entities, status) => 
    Object.values(entities).filter(project => project?.status === status)
)

// ✅ Custom hooks for component integration
export const useUserPermissions = () => {
  const permissions = useSelector(selectUserPermissions)
  
  return {
    permissions,
    hasPermission: (permission: string) => permissions.includes(permission),
    canWrite: permissions.includes('write'),
    canDelete: permissions.includes('delete'),
    canManage: permissions.includes('manage')
  }
}

export const useDashboardStats = () => {
  const stats = useSelector(selectDashboardStats)
  const dispatch = useAppDispatch()
  
  const refreshStats = useCallback(() => {
    dispatch(fetchDashboardData())
  }, [dispatch])

  return {
    stats,
    refreshStats,
    isLoading: useSelector((state: RootState) => state.analytics.isLoading)
  }
}
```

## Error Handling & Loading States

**Comprehensive error management:**
```typescript
// ✅ Global error handling middleware
export const errorHandlingMiddleware: Middleware = (store) => (next) => (action) => {
  // ✅ Catch all rejected async thunks
  if (action.type.endsWith('/rejected')) {
    const error = action.payload || action.error?.message || 'An error occurred'
    
    // ✅ Log error for monitoring
    console.error('Thunk rejected:', {
      type: action.type,
      error,
      meta: action.meta
    })

    // ✅ Handle specific error types
    if (error.includes('401') || error.includes('Unauthorized')) {
      store.dispatch(userSlice.actions.logout())
      window.location.href = '/login'
      return next(action)
    }

    if (error.includes('403') || error.includes('Forbidden')) {
      store.dispatch(notificationSlice.actions.addNotification({
        type: 'error',
        message: 'You do not have permission to perform this action'
      }))
      return next(action)
    }

    if (error.includes('429') || error.includes('Too Many Requests')) {
      store.dispatch(notificationSlice.actions.addNotification({
        type: 'warning',
        message: 'Please slow down. Too many requests.'
      }))
      return next(action)
    }

    // ✅ Network errors
    if (error.includes('Network Error') || error.includes('fetch')) {
      store.dispatch(notificationSlice.actions.addNotification({
        type: 'error',
        message: 'Network error. Please check your connection.'
      }))
    }
  }

  return next(action)
}

// ✅ Loading state management
interface LoadingState {
  [key: string]: boolean
}

const initialLoadingState: LoadingState = {}

export const loadingSlice = createSlice({
  name: 'loading',
  initialState: initialLoadingState,
  reducers: {},
  extraReducers: (builder) => {
    // ✅ Automatically handle loading states for all async thunks
    builder
      .addMatcher(
        (action) => action.type.endsWith('/pending'),
        (state, action) => {
          state[action.type.replace('/pending', '')] = true
        }
      )
      .addMatcher(
        (action) => action.type.endsWith('/fulfilled'),
        (state, action) => {
          state[action.type.replace('/fulfilled', '')] = false
        }
      )
      .addMatcher(
        (action) => action.type.endsWith('/rejected'),
        (state, action) => {
          state[action.type.replace('/rejected', '')] = false
        }
      )
  }
})

// ✅ Custom hook for loading states
export const useLoadingState = (actionType: string) => {
  return useSelector((state: RootState) => 
    state.loading[actionType] || false
  )
}

export const useAsyncAction = <T, U>(
  asyncAction: (arg: U) => AsyncThunkAction<T, U, any>
) => {
  const dispatch = useAppDispatch()
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const execute = useCallback(async (arg: U): Promise<T | null> => {
    setLoading(true)
    setError(null)

    try {
      const result = await dispatch(asyncAction(arg)).unwrap()
      return result
    } catch (err: any) {
      setError(err.message || 'An error occurred')
      return null
    } finally {
      setLoading(false)
    }
  }, [dispatch, asyncAction])

  return { execute, loading, error }
}
```

## Testing Patterns

**Comprehensive thunk testing:**
```typescript
import { configureStore } from '@reduxjs/toolkit'
import { renderHook } from '@testing-library/react'
import { Provider } from 'react-redux'

// ✅ Mock store for testing
const createMockStore = (initialState?: Partial<RootState>) => {
  return configureStore({
    reducer: {
      user: userSlice.reducer,
      loading: loadingSlice.reducer
    },
    preloadedState: initialState,
    middleware: (getDefaultMiddleware) =>
      getDefaultMiddleware({
        thunk: {
          extraArgument: {
            analytics: mockAnalytics
          }
        }
      })
  })
}

describe('User Thunks', () => {
  let store: ReturnType<typeof createMockStore>
  
  beforeEach(() => {
    store = createMockStore()
    vi.clearAllMocks()
  })

  // ✅ Test successful async action
  it('should handle successful login', async () => {
    const mockUser = { id: '1', name: 'Test User', email: 'test@example.com' }
    const credentials = { email: 'test@example.com', password: 'password' }

    vi.mocked(UserService.login).mockResolvedValue(mockUser)

    const result = await store.dispatch(loginUser(credentials))
    
    expect(result.type).toBe('auth/login/fulfilled')
    expect(result.payload).toEqual(mockUser)
    
    const state = store.getState()
    expect(state.user.user).toEqual(mockUser)
    expect(state.user.isLoading).toBe(false)
    expect(state.user.error).toBeNull()
  })

  // ✅ Test error handling
  it('should handle login failure', async () => {
    const credentials = { email: 'test@example.com', password: 'wrong' }
    const error = new Error('Invalid credentials')
    error.response = { status: 401, data: { message: 'Invalid credentials' } }

    vi.mocked(UserService.login).mockRejectedValue(error)

    const result = await store.dispatch(loginUser(credentials))
    
    expect(result.type).toBe('auth/login/rejected')
    expect(result.payload).toBe('Invalid email or password')
    
    const state = store.getState()
    expect(state.user.user).toBeNull()
    expect(state.user.error).toBe('Invalid email or password')
    expect(state.user.loginAttempts).toBe(1)
  })

  // ✅ Test complex async flow
  it('should handle profile update with image upload', async () => {
    const userId = '1'
    const updates = { name: 'Updated Name' }
    const profileImage = new File([''], 'avatar.jpg')
    const imageUrl = 'https://example.com/avatar.jpg'
    const updatedUser = { id: userId, name: 'Updated Name', profileImageUrl: imageUrl }

    vi.mocked(UserService.uploadProfileImage).mockResolvedValue(imageUrl)
    vi.mocked(UserService.updateProfile).mockResolvedValue(updatedUser)

    const result = await store.dispatch(updateUserProfile({
      userId,
      updates,
      profileImage
    }))

    expect(result.type).toBe('user/updateProfile/fulfilled')
    expect(result.payload).toEqual(updatedUser)
    
    // ✅ Verify service calls
    expect(UserService.uploadProfileImage).toHaveBeenCalledWith(userId, profileImage)
    expect(UserService.updateProfile).toHaveBeenCalledWith(userId, {
      ...updates,
      profileImageUrl: imageUrl
    })
  })

  // ✅ Test selectors
  it('should compute user permissions correctly', () => {
    const adminUser = { id: '1', name: 'Admin', role: 'admin' as const }
    store = createMockStore({
      user: { ...initialState, user: adminUser }
    })

    const permissions = selectUserPermissions(store.getState())
    expect(permissions).toEqual(['read', 'write', 'delete', 'manage'])
  })

  // ✅ Test custom hooks
  it('should provide user permissions through hook', () => {
    const adminUser = { id: '1', name: 'Admin', role: 'admin' as const }
    store = createMockStore({
      user: { ...initialState, user: adminUser }
    })

    const wrapper = ({ children }: { children: React.ReactNode }) => (
      <Provider store={store}>{children}</Provider>
    )

    const { result } = renderHook(() => useUserPermissions(), { wrapper })

    expect(result.current.permissions).toEqual(['read', 'write', 'delete', 'manage'])
    expect(result.current.hasPermission('write')).toBe(true)
    expect(result.current.canManage).toBe(true)
  })
})
``` 