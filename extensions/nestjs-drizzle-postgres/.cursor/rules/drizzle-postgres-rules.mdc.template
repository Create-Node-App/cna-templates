---
description: Advanced NestJS Drizzle ORM patterns for PostgreSQL integration, schema management, query optimization, and enterprise database architecture.
globs: '**/*.{ts,js}', '**/drizzle.config.{ts,js}', '**/migrations/**/*', '**/schemas/**/*'
---

# Advanced NestJS Drizzle PostgreSQL Integration

## Enterprise Drizzle Configuration

**Advanced Drizzle configuration with connection pooling:**
```typescript
// drizzle.config.ts
import { defineConfig } from 'drizzle-kit'
import { Config } from '@drizzle-team/brocli'
import dotenv from 'dotenv'

dotenv.config()

const config: Config = {
  schema: './src/database/schemas/*.ts',
  out: './drizzle/migrations',
  driver: 'pg',
  dbCredentials: {
    connectionString: process.env.DATABASE_URL!,
    ssl: process.env.NODE_ENV === 'production' ? {
      rejectUnauthorized: false,
      ca: process.env.DATABASE_SSL_CA,
      key: process.env.DATABASE_SSL_KEY,
      cert: process.env.DATABASE_SSL_CERT
    } : undefined
  },
  
  // Advanced migration configuration
  migrations: {
    table: 'drizzle_migrations',
    schema: 'public'
  },
  
  // Performance optimizations
  introspect: {
    casing: 'snake_case'
  },
  
  // Environment-specific settings
  breakpoints: true,
  strict: true,
  verbose: process.env.NODE_ENV === 'development'
}

export default config
```

**Advanced database module configuration:**
```typescript
// src/database/database.module.ts
import { Module, Global } from '@nestjs/common'
import { ConfigModule, ConfigService } from '@nestjs/config'
import { drizzle } from 'drizzle-orm/postgres-js'
import { migrate } from 'drizzle-orm/postgres-js/migrator'
import postgres from 'postgres'
import * as schema from './schemas'
import { DATABASE_CONNECTION } from './database.constants'
import { DatabaseService } from './database.service'
import { DatabaseHealthIndicator } from './database-health.indicator'

@Global()
@Module({
  imports: [ConfigModule],
  providers: [
    {
      provide: DATABASE_CONNECTION,
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => {
        const databaseUrl = configService.get<string>('DATABASE_URL')
        
        if (!databaseUrl) {
          throw new Error('DATABASE_URL is not defined')
        }
        
        // Connection configuration with pooling
        const connection = postgres(databaseUrl, {
          // Connection pool settings
          max: configService.get<number>('DB_POOL_MAX', 20),
          idle_timeout: configService.get<number>('DB_IDLE_TIMEOUT', 30000),
          connect_timeout: configService.get<number>('DB_CONNECT_TIMEOUT', 10000),
          
          // SSL configuration
          ssl: configService.get<string>('NODE_ENV') === 'production' ? {
            rejectUnauthorized: false,
            ca: configService.get<string>('DATABASE_SSL_CA'),
            key: configService.get<string>('DATABASE_SSL_KEY'),
            cert: configService.get<string>('DATABASE_SSL_CERT')
          } : undefined,
          
          // Performance settings
          prepare: true,
          types: {
            // Custom type parsers
            bigint: postgres.BigInt,
            date: (value: string) => new Date(value + 'T00:00:00.000Z'),
            timestamp: (value: string) => new Date(value + 'Z'),
            timestamptz: (value: string) => new Date(value)
          },
          
          // Connection events
          onnotice: (notice) => {
            console.log('PostgreSQL Notice:', notice)
          },
          
          // Error handling
          connection: {
            application_name: configService.get<string>('APP_NAME', 'nestjs-drizzle-app'),
            statement_timeout: configService.get<number>('DB_STATEMENT_TIMEOUT', 30000)
          }
        })
        
        // Initialize Drizzle
        const db = drizzle(connection, { 
          schema,
          logger: configService.get<string>('NODE_ENV') === 'development'
        })
        
        // Auto-migrate in development
        if (configService.get<string>('NODE_ENV') === 'development') {
          try {
            await migrate(db, { migrationsFolder: './drizzle/migrations' })
            console.log('Database migrations completed successfully')
          } catch (error) {
            console.error('Database migration failed:', error)
            throw error
          }
        }
        
        return db
      }
    },
    DatabaseService,
    DatabaseHealthIndicator
  ],
  exports: [DATABASE_CONNECTION, DatabaseService]
})
export class DatabaseModule {}
```

## Advanced Schema Design

**Comprehensive database schemas with relationships:**
```typescript
// src/database/schemas/users.schema.ts
import { 
  pgTable, 
  uuid, 
  varchar, 
  text, 
  timestamp, 
  boolean, 
  integer,
  jsonb,
  pgEnum,
  uniqueIndex,
  index
} from 'drizzle-orm/pg-core'
import { relations, sql } from 'drizzle-orm'
import { createInsertSchema, createSelectSchema } from 'drizzle-zod'
import { z } from 'zod'

// Enums
export const userStatusEnum = pgEnum('user_status', ['active', 'inactive', 'suspended', 'deleted'])
export const userRoleEnum = pgEnum('user_role', ['admin', 'moderator', 'user', 'guest'])

// Users table
export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  email: varchar('email', { length: 255 }).notNull(),
  username: varchar('username', { length: 100 }).notNull(),
  firstName: varchar('first_name', { length: 100 }),
  lastName: varchar('last_name', { length: 100 }),
  avatar: text('avatar'),
  bio: text('bio'),
  
  // Authentication
  passwordHash: text('password_hash').notNull(),
  emailVerified: boolean('email_verified').default(false),
  emailVerificationToken: varchar('email_verification_token', { length: 255 }),
  resetPasswordToken: varchar('reset_password_token', { length: 255 }),
  resetPasswordExpires: timestamp('reset_password_expires'),
  
  // User status and role
  status: userStatusEnum('status').default('active'),
  role: userRoleEnum('role').default('user'),
  
  // Metadata
  metadata: jsonb('metadata').$type<{
    preferences?: {
      theme?: 'light' | 'dark'
      language?: string
      notifications?: boolean
      newsletter?: boolean
    }
    profile?: {
      company?: string
      website?: string
      location?: string
      timezone?: string
    }
    security?: {
      twoFactorEnabled?: boolean
      lastPasswordChange?: string
      loginAttempts?: number
      lockedUntil?: string
    }
  }>(),
  
  // Audit fields
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
  lastLoginAt: timestamp('last_login_at'),
  
  // Soft delete
  deletedAt: timestamp('deleted_at')
}, (table) => ({
  // Indexes
  emailIdx: uniqueIndex('users_email_idx').on(table.email),
  usernameIdx: uniqueIndex('users_username_idx').on(table.username),
  statusIdx: index('users_status_idx').on(table.status),
  roleIdx: index('users_role_idx').on(table.role),
  createdAtIdx: index('users_created_at_idx').on(table.createdAt),
  
  // Composite indexes
  statusRoleIdx: index('users_status_role_idx').on(table.status, table.role),
  deletedAtStatusIdx: index('users_deleted_at_status_idx').on(table.deletedAt, table.status)
}))

// Posts table
export const posts = pgTable('posts', {
  id: uuid('id').primaryKey().defaultRandom(),
  title: varchar('title', { length: 255 }).notNull(),
  slug: varchar('slug', { length: 255 }).notNull(),
  content: text('content').notNull(),
  excerpt: text('excerpt'),
  
  // Author relationship
  authorId: uuid('author_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  
  // Status and visibility
  status: pgEnum('post_status', ['draft', 'published', 'archived'])('status').default('draft'),
  visibility: pgEnum('post_visibility', ['public', 'private', 'unlisted'])('visibility').default('public'),
  
  // SEO and metadata
  metaTitle: varchar('meta_title', { length: 255 }),
  metaDescription: text('meta_description'),
  tags: text('tags').array(),
  categories: text('categories').array(),
  
  // Engagement metrics
  viewCount: integer('view_count').default(0),
  likeCount: integer('like_count').default(0),
  shareCount: integer('share_count').default(0),
  commentCount: integer('comment_count').default(0),
  
  // Content metadata
  readTime: integer('read_time'), // in minutes
  wordCount: integer('word_count'),
  featuredImage: text('featured_image'),
  
  // Publishing
  publishedAt: timestamp('published_at'),
  scheduledAt: timestamp('scheduled_at'),
  
  // Audit fields
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
  deletedAt: timestamp('deleted_at')
}, (table) => ({
  // Indexes
  slugIdx: uniqueIndex('posts_slug_idx').on(table.slug),
  authorIdx: index('posts_author_idx').on(table.authorId),
  statusIdx: index('posts_status_idx').on(table.status),
  publishedAtIdx: index('posts_published_at_idx').on(table.publishedAt),
  
  // Full-text search indexes
  titleSearchIdx: index('posts_title_search_idx').using('gin', sql`to_tsvector('english', ${table.title})`),
  contentSearchIdx: index('posts_content_search_idx').using('gin', sql`to_tsvector('english', ${table.content})`),
  
  // Composite indexes
  statusPublishedIdx: index('posts_status_published_idx').on(table.status, table.publishedAt),
  authorStatusIdx: index('posts_author_status_idx').on(table.authorId, table.status)
}))

// Comments table
export const comments = pgTable('comments', {
  id: uuid('id').primaryKey().defaultRandom(),
  content: text('content').notNull(),
  
  // Relationships
  postId: uuid('post_id').notNull().references(() => posts.id, { onDelete: 'cascade' }),
  authorId: uuid('author_id').references(() => users.id, { onDelete: 'set null' }),
  parentId: uuid('parent_id').references(() => comments.id, { onDelete: 'cascade' }), // For nested comments
  
  // Guest comments (when authorId is null)
  guestName: varchar('guest_name', { length: 100 }),
  guestEmail: varchar('guest_email', { length: 255 }),
  
  // Status and moderation
  status: pgEnum('comment_status', ['pending', 'approved', 'spam', 'deleted'])('status').default('pending'),
  moderatedBy: uuid('moderated_by').references(() => users.id),
  moderatedAt: timestamp('moderated_at'),
  
  // Metrics
  likeCount: integer('like_count').default(0),
  replyCount: integer('reply_count').default(0),
  
  // Audit fields
  ipAddress: varchar('ip_address', { length: 45 }),
  userAgent: text('user_agent'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
  deletedAt: timestamp('deleted_at')
}, (table) => ({
  // Indexes
  postIdx: index('comments_post_idx').on(table.postId),
  authorIdx: index('comments_author_idx').on(table.authorId),
  parentIdx: index('comments_parent_idx').on(table.parentId),
  statusIdx: index('comments_status_idx').on(table.status),
  createdAtIdx: index('comments_created_at_idx').on(table.createdAt),
  
  // Composite indexes
  postStatusIdx: index('comments_post_status_idx').on(table.postId, table.status),
  parentStatusIdx: index('comments_parent_status_idx').on(table.parentId, table.status)
}))

// User sessions table
export const userSessions = pgTable('user_sessions', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  
  // Session data
  sessionToken: varchar('session_token', { length: 255 }).notNull(),
  refreshToken: varchar('refresh_token', { length: 255 }),
  deviceInfo: jsonb('device_info').$type<{
    userAgent?: string
    platform?: string
    browser?: string
    os?: string
    device?: string
    ip?: string
    location?: {
      country?: string
      city?: string
      timezone?: string
    }
  }>(),
  
  // Session metadata
  isActive: boolean('is_active').default(true),
  lastActivity: timestamp('last_activity').defaultNow(),
  
  // Expiration
  expiresAt: timestamp('expires_at').notNull(),
  
  // Audit fields
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull()
}, (table) => ({
  // Indexes
  userIdx: index('user_sessions_user_idx').on(table.userId),
  tokenIdx: uniqueIndex('user_sessions_token_idx').on(table.sessionToken),
  refreshTokenIdx: index('user_sessions_refresh_token_idx').on(table.refreshToken),
  activeIdx: index('user_sessions_active_idx').on(table.isActive),
  expiresAtIdx: index('user_sessions_expires_at_idx').on(table.expiresAt),
  
  // Composite indexes
  userActiveIdx: index('user_sessions_user_active_idx').on(table.userId, table.isActive)
}))

// Define relationships
export const usersRelations = relations(users, ({ many, one }) => ({
  posts: many(posts),
  comments: many(comments),
  sessions: many(userSessions),
  moderatedComments: many(comments, {
    relationName: 'moderator'
  })
}))

export const postsRelations = relations(posts, ({ one, many }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id]
  }),
  comments: many(comments)
}))

export const commentsRelations = relations(comments, ({ one, many }) => ({
  post: one(posts, {
    fields: [comments.postId],
    references: [posts.id]
  }),
  author: one(users, {
    fields: [comments.authorId],
    references: [users.id]
  }),
  parent: one(comments, {
    fields: [comments.parentId],
    references: [comments.id],
    relationName: 'parent'
  }),
  replies: many(comments, {
    relationName: 'parent'
  }),
  moderatedBy: one(users, {
    fields: [comments.moderatedBy],
    references: [users.id],
    relationName: 'moderator'
  })
}))

export const userSessionsRelations = relations(userSessions, ({ one }) => ({
  user: one(users, {
    fields: [userSessions.userId],
    references: [users.id]
  })
}))

// Zod schemas for validation
export const insertUserSchema = createInsertSchema(users, {
  email: z.string().email(),
  username: z.string().min(3).max(100),
  firstName: z.string().min(1).max(100).optional(),
  lastName: z.string().min(1).max(100).optional(),
  passwordHash: z.string().min(1),
  metadata: z.object({
    preferences: z.object({
      theme: z.enum(['light', 'dark']).optional(),
      language: z.string().optional(),
      notifications: z.boolean().optional(),
      newsletter: z.boolean().optional()
    }).optional(),
    profile: z.object({
      company: z.string().optional(),
      website: z.string().url().optional(),
      location: z.string().optional(),
      timezone: z.string().optional()
    }).optional()
  }).optional()
})

export const selectUserSchema = createSelectSchema(users)

export const insertPostSchema = createInsertSchema(posts, {
  title: z.string().min(1).max(255),
  slug: z.string().min(1).max(255),
  content: z.string().min(1),
  authorId: z.string().uuid(),
  tags: z.array(z.string()).optional(),
  categories: z.array(z.string()).optional()
})

export const selectPostSchema = createSelectSchema(posts)

export const insertCommentSchema = createInsertSchema(comments, {
  content: z.string().min(1),
  postId: z.string().uuid(),
  authorId: z.string().uuid().optional(),
  parentId: z.string().uuid().optional(),
  guestName: z.string().max(100).optional(),
  guestEmail: z.string().email().optional()
})

export const selectCommentSchema = createSelectSchema(comments)

// Type exports
export type User = typeof users.$inferSelect
export type NewUser = typeof users.$inferInsert
export type Post = typeof posts.$inferSelect
export type NewPost = typeof posts.$inferInsert
export type Comment = typeof comments.$inferSelect
export type NewComment = typeof comments.$inferInsert
export type UserSession = typeof userSessions.$inferSelect
export type NewUserSession = typeof userSessions.$inferInsert
```

## Advanced Database Service

**Comprehensive database service with query optimization:**
```typescript
// src/database/database.service.ts
import { Injectable, Inject, Logger, OnModuleDestroy } from '@nestjs/common'
import { eq, and, or, sql, desc, asc, ilike, inArray, isNull, isNotNull, gte, lte, between, count } from 'drizzle-orm'
import { PgDatabase } from 'drizzle-orm/pg-core'
import { DATABASE_CONNECTION } from './database.constants'
import * as schema from './schemas'
import { 
  User, 
  NewUser, 
  Post, 
  NewPost, 
  Comment, 
  NewComment,
  insertUserSchema,
  insertPostSchema,
  insertCommentSchema
} from './schemas'

export interface PaginationOptions {
  page?: number
  limit?: number
  sortBy?: string
  sortOrder?: 'asc' | 'desc'
}

export interface PaginatedResult<T> {
  data: T[]
  meta: {
    page: number
    limit: number
    total: number
    totalPages: number
    hasNextPage: boolean
    hasPreviousPage: boolean
  }
}

export interface UserFilters {
  status?: string[]
  role?: string[]
  emailVerified?: boolean
  createdAfter?: Date
  createdBefore?: Date
  search?: string
}

export interface PostFilters {
  status?: string[]
  visibility?: string[]
  authorId?: string
  tags?: string[]
  categories?: string[]
  publishedAfter?: Date
  publishedBefore?: Date
  search?: string
}

export interface CommentFilters {
  status?: string[]
  postId?: string
  authorId?: string
  hasParent?: boolean
  createdAfter?: Date
  createdBefore?: Date
}

@Injectable()
export class DatabaseService implements OnModuleDestroy {
  private readonly logger = new Logger(DatabaseService.name)
  
  constructor(
    @Inject(DATABASE_CONNECTION) 
    private readonly db: PgDatabase<typeof schema>
  ) {}
  
  async onModuleDestroy() {
    try {
      // Cleanup database connections
      await this.db.$client.end()
      this.logger.log('Database connections closed')
    } catch (error) {
      this.logger.error('Error closing database connections:', error)
    }
  }
  
  // Transaction helper
  async transaction<T>(
    callback: (tx: PgDatabase<typeof schema>) => Promise<T>
  ): Promise<T> {
    return this.db.transaction(callback)
  }
  
  // Generic pagination helper
  private async paginate<T>(
    query: any,
    options: PaginationOptions
  ): Promise<PaginatedResult<T>> {
    const page = Math.max(1, options.page || 1)
    const limit = Math.min(100, Math.max(1, options.limit || 10))
    const offset = (page - 1) * limit
    
    // Get total count
    const totalResult = await query.select({ count: count() })
    const total = totalResult[0]?.count || 0
    
    // Get paginated data
    const data = await query
      .limit(limit)
      .offset(offset)
    
    const totalPages = Math.ceil(total / limit)
    
    return {
      data,
      meta: {
        page,
        limit,
        total,
        totalPages,
        hasNextPage: page < totalPages,
        hasPreviousPage: page > 1
      }
    }
  }
  
  // User methods
  async createUser(userData: NewUser): Promise<User> {
    try {
      // Validate input
      const validatedData = insertUserSchema.parse(userData)
      
      const [user] = await this.db
        .insert(schema.users)
        .values(validatedData)
        .returning()
      
      this.logger.log(`User created: ${user.id}`)
      return user
    } catch (error) {
      this.logger.error('Error creating user:', error)
      throw error
    }
  }
  
  async getUserById(id: string, includeDeleted = false): Promise<User | null> {
    try {
      const conditions = [eq(schema.users.id, id)]
      if (!includeDeleted) {
        conditions.push(isNull(schema.users.deletedAt))
      }
      
      const [user] = await this.db
        .select()
        .from(schema.users)
        .where(and(...conditions))
      
      return user || null
    } catch (error) {
      this.logger.error('Error getting user by ID:', error)
      throw error
    }
  }
  
  async getUserByEmail(email: string, includeDeleted = false): Promise<User | null> {
    try {
      const conditions = [eq(schema.users.email, email)]
      if (!includeDeleted) {
        conditions.push(isNull(schema.users.deletedAt))
      }
      
      const [user] = await this.db
        .select()
        .from(schema.users)
        .where(and(...conditions))
      
      return user || null
    } catch (error) {
      this.logger.error('Error getting user by email:', error)
      throw error
    }
  }
  
  async getUserByUsername(username: string, includeDeleted = false): Promise<User | null> {
    try {
      const conditions = [eq(schema.users.username, username)]
      if (!includeDeleted) {
        conditions.push(isNull(schema.users.deletedAt))
      }
      
      const [user] = await this.db
        .select()
        .from(schema.users)
        .where(and(...conditions))
      
      return user || null
    } catch (error) {
      this.logger.error('Error getting user by username:', error)
      throw error
    }
  }
  
  async getUsers(
    filters: UserFilters = {},
    pagination: PaginationOptions = {}
  ): Promise<PaginatedResult<User>> {
    try {
      const conditions: any[] = [isNull(schema.users.deletedAt)]
      
      // Apply filters
      if (filters.status?.length) {
        conditions.push(inArray(schema.users.status, filters.status))
      }
      
      if (filters.role?.length) {
        conditions.push(inArray(schema.users.role, filters.role))
      }
      
      if (typeof filters.emailVerified === 'boolean') {
        conditions.push(eq(schema.users.emailVerified, filters.emailVerified))
      }
      
      if (filters.createdAfter) {
        conditions.push(gte(schema.users.createdAt, filters.createdAfter))
      }
      
      if (filters.createdBefore) {
        conditions.push(lte(schema.users.createdAt, filters.createdBefore))
      }
      
      if (filters.search) {
        conditions.push(
          or(
            ilike(schema.users.email, `%${filters.search}%`),
            ilike(schema.users.username, `%${filters.search}%`),
            ilike(schema.users.firstName, `%${filters.search}%`),
            ilike(schema.users.lastName, `%${filters.search}%`)
          )
        )
      }
      
      let query = this.db
        .select()
        .from(schema.users)
        .where(and(...conditions))
      
      // Apply sorting
      const sortBy = pagination.sortBy || 'createdAt'
      const sortOrder = pagination.sortOrder || 'desc'
      
      if (sortBy && schema.users[sortBy]) {
        query = query.orderBy(
          sortOrder === 'asc' 
            ? asc(schema.users[sortBy])
            : desc(schema.users[sortBy])
        )
      }
      
      return this.paginate(query, pagination)
    } catch (error) {
      this.logger.error('Error getting users:', error)
      throw error
    }
  }
  
  async updateUser(id: string, updates: Partial<NewUser>): Promise<User | null> {
    try {
      const [user] = await this.db
        .update(schema.users)
        .set({
          ...updates,
          updatedAt: new Date()
        })
        .where(and(
          eq(schema.users.id, id),
          isNull(schema.users.deletedAt)
        ))
        .returning()
      
      if (user) {
        this.logger.log(`User updated: ${id}`)
      }
      
      return user || null
    } catch (error) {
      this.logger.error('Error updating user:', error)
      throw error
    }
  }
  
  async softDeleteUser(id: string): Promise<boolean> {
    try {
      const [user] = await this.db
        .update(schema.users)
        .set({
          deletedAt: new Date(),
          updatedAt: new Date()
        })
        .where(and(
          eq(schema.users.id, id),
          isNull(schema.users.deletedAt)
        ))
        .returning({ id: schema.users.id })
      
      if (user) {
        this.logger.log(`User soft deleted: ${id}`)
        return true
      }
      
      return false
    } catch (error) {
      this.logger.error('Error soft deleting user:', error)
      throw error
    }
  }
  
  // Post methods
  async createPost(postData: NewPost): Promise<Post> {
    try {
      const validatedData = insertPostSchema.parse(postData)
      
      const [post] = await this.db
        .insert(schema.posts)
        .values({
          ...validatedData,
          wordCount: this.calculateWordCount(validatedData.content),
          readTime: this.calculateReadTime(validatedData.content)
        })
        .returning()
      
      this.logger.log(`Post created: ${post.id}`)
      return post
    } catch (error) {
      this.logger.error('Error creating post:', error)
      throw error
    }
  }
  
  async getPostById(id: string, includeDeleted = false): Promise<Post & { author: User } | null> {
    try {
      const conditions = [eq(schema.posts.id, id)]
      if (!includeDeleted) {
        conditions.push(isNull(schema.posts.deletedAt))
      }
      
      const [post] = await this.db
        .select()
        .from(schema.posts)
        .innerJoin(schema.users, eq(schema.posts.authorId, schema.users.id))
        .where(and(...conditions))
      
      if (!post) return null
      
      return {
        ...post.posts,
        author: post.users
      }
    } catch (error) {
      this.logger.error('Error getting post by ID:', error)
      throw error
    }
  }
  
  async getPosts(
    filters: PostFilters = {},
    pagination: PaginationOptions = {}
  ): Promise<PaginatedResult<Post & { author: User }>> {
    try {
      const conditions: any[] = [
        isNull(schema.posts.deletedAt),
        isNull(schema.users.deletedAt)
      ]
      
      // Apply filters
      if (filters.status?.length) {
        conditions.push(inArray(schema.posts.status, filters.status))
      }
      
      if (filters.visibility?.length) {
        conditions.push(inArray(schema.posts.visibility, filters.visibility))
      }
      
      if (filters.authorId) {
        conditions.push(eq(schema.posts.authorId, filters.authorId))
      }
      
      if (filters.tags?.length) {
        conditions.push(
          sql`${schema.posts.tags} && ${filters.tags}`
        )
      }
      
      if (filters.categories?.length) {
        conditions.push(
          sql`${schema.posts.categories} && ${filters.categories}`
        )
      }
      
      if (filters.publishedAfter) {
        conditions.push(gte(schema.posts.publishedAt, filters.publishedAfter))
      }
      
      if (filters.publishedBefore) {
        conditions.push(lte(schema.posts.publishedAt, filters.publishedBefore))
      }
      
      if (filters.search) {
        conditions.push(
          or(
            sql`to_tsvector('english', ${schema.posts.title}) @@ plainto_tsquery('english', ${filters.search})`,
            sql`to_tsvector('english', ${schema.posts.content}) @@ plainto_tsquery('english', ${filters.search})`
          )
        )
      }
      
      let query = this.db
        .select()
        .from(schema.posts)
        .innerJoin(schema.users, eq(schema.posts.authorId, schema.users.id))
        .where(and(...conditions))
      
      // Apply sorting
      const sortBy = pagination.sortBy || 'createdAt'
      const sortOrder = pagination.sortOrder || 'desc'
      
      if (sortBy && schema.posts[sortBy]) {
        query = query.orderBy(
          sortOrder === 'asc'
            ? asc(schema.posts[sortBy])
            : desc(schema.posts[sortBy])
        )
      }
      
      const result = await this.paginate(query, pagination)
      
      return {
        ...result,
        data: result.data.map(item => ({
          ...item.posts,
          author: item.users
        }))
      }
    } catch (error) {
      this.logger.error('Error getting posts:', error)
      throw error
    }
  }
  
  async updatePost(id: string, updates: Partial<NewPost>): Promise<Post | null> {
    try {
      const updateData: any = {
        ...updates,
        updatedAt: new Date()
      }
      
      // Recalculate word count and read time if content changed
      if (updates.content) {
        updateData.wordCount = this.calculateWordCount(updates.content)
        updateData.readTime = this.calculateReadTime(updates.content)
      }
      
      const [post] = await this.db
        .update(schema.posts)
        .set(updateData)
        .where(and(
          eq(schema.posts.id, id),
          isNull(schema.posts.deletedAt)
        ))
        .returning()
      
      if (post) {
        this.logger.log(`Post updated: ${id}`)
      }
      
      return post || null
    } catch (error) {
      this.logger.error('Error updating post:', error)
      throw error
    }
  }
  
  async incrementPostViews(id: string): Promise<void> {
    try {
      await this.db
        .update(schema.posts)
        .set({
          viewCount: sql`${schema.posts.viewCount} + 1`,
          updatedAt: new Date()
        })
        .where(eq(schema.posts.id, id))
      
    } catch (error) {
      this.logger.error('Error incrementing post views:', error)
    }
  }
  
  // Comment methods
  async createComment(commentData: NewComment): Promise<Comment> {
    try {
      const validatedData = insertCommentSchema.parse(commentData)
      
      return await this.db.transaction(async (tx) => {
        const [comment] = await tx
          .insert(schema.comments)
          .values(validatedData)
          .returning()
        
        // Update post comment count
        await tx
          .update(schema.posts)
          .set({
            commentCount: sql`${schema.posts.commentCount} + 1`,
            updatedAt: new Date()
          })
          .where(eq(schema.posts.id, commentData.postId))
        
        // Update parent comment reply count if it's a reply
        if (commentData.parentId) {
          await tx
            .update(schema.comments)
            .set({
              replyCount: sql`${schema.comments.replyCount} + 1`,
              updatedAt: new Date()
            })
            .where(eq(schema.comments.id, commentData.parentId))
        }
        
        this.logger.log(`Comment created: ${comment.id}`)
        return comment
      })
    } catch (error) {
      this.logger.error('Error creating comment:', error)
      throw error
    }
  }
  
  async getComments(
    filters: CommentFilters = {},
    pagination: PaginationOptions = {}
  ): Promise<PaginatedResult<Comment & { author?: User; post: Post }>> {
    try {
      const conditions: any[] = [isNull(schema.comments.deletedAt)]
      
      // Apply filters
      if (filters.status?.length) {
        conditions.push(inArray(schema.comments.status, filters.status))
      }
      
      if (filters.postId) {
        conditions.push(eq(schema.comments.postId, filters.postId))
      }
      
      if (filters.authorId) {
        conditions.push(eq(schema.comments.authorId, filters.authorId))
      }
      
      if (typeof filters.hasParent === 'boolean') {
        conditions.push(
          filters.hasParent
            ? isNotNull(schema.comments.parentId)
            : isNull(schema.comments.parentId)
        )
      }
      
      if (filters.createdAfter) {
        conditions.push(gte(schema.comments.createdAt, filters.createdAfter))
      }
      
      if (filters.createdBefore) {
        conditions.push(lte(schema.comments.createdAt, filters.createdBefore))
      }
      
      let query = this.db
        .select()
        .from(schema.comments)
        .leftJoin(schema.users, eq(schema.comments.authorId, schema.users.id))
        .innerJoin(schema.posts, eq(schema.comments.postId, schema.posts.id))
        .where(and(...conditions))
      
      // Apply sorting
      const sortBy = pagination.sortBy || 'createdAt'
      const sortOrder = pagination.sortOrder || 'desc'
      
      if (sortBy && schema.comments[sortBy]) {
        query = query.orderBy(
          sortOrder === 'asc'
            ? asc(schema.comments[sortBy])
            : desc(schema.comments[sortBy])
        )
      }
      
      const result = await this.paginate(query, pagination)
      
      return {
        ...result,
        data: result.data.map(item => ({
          ...item.comments,
          author: item.users || undefined,
          post: item.posts
        }))
      }
    } catch (error) {
      this.logger.error('Error getting comments:', error)
      throw error
    }
  }
  
  // Utility methods
  private calculateWordCount(content: string): number {
    return content.trim().split(/\s+/).filter(word => word.length > 0).length
  }
  
  private calculateReadTime(content: string): number {
    const wordsPerMinute = 200
    const wordCount = this.calculateWordCount(content)
    return Math.max(1, Math.ceil(wordCount / wordsPerMinute))
  }
  
  // Health check
  async healthCheck(): Promise<{ status: string; timestamp: Date }> {
    try {
      await this.db.select({ test: sql`1` })
      return {
        status: 'healthy',
        timestamp: new Date()
      }
    } catch (error) {
      this.logger.error('Database health check failed:', error)
      throw new Error('Database connection failed')
    }
  }
  
  // Analytics methods
  async getUserStats(): Promise<{
    total: number
    active: number
    verified: number
    newThisWeek: number
  }> {
    try {
      const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
      
      const [stats] = await this.db
        .select({
          total: count(),
          active: count(sql`CASE WHEN status = 'active' THEN 1 END`),
          verified: count(sql`CASE WHEN email_verified = true THEN 1 END`),
          newThisWeek: count(sql`CASE WHEN created_at >= ${weekAgo} THEN 1 END`)
        })
        .from(schema.users)
        .where(isNull(schema.users.deletedAt))
      
      return stats
    } catch (error) {
      this.logger.error('Error getting user stats:', error)
      throw error
    }
  }
  
  async getPostStats(): Promise<{
    total: number
    published: number
    drafts: number
    newThisWeek: number
  }> {
    try {
      const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
      
      const [stats] = await this.db
        .select({
          total: count(),
          published: count(sql`CASE WHEN status = 'published' THEN 1 END`),
          drafts: count(sql`CASE WHEN status = 'draft' THEN 1 END`),
          newThisWeek: count(sql`CASE WHEN created_at >= ${weekAgo} THEN 1 END`)
        })
        .from(schema.posts)
        .where(isNull(schema.posts.deletedAt))
      
      return stats
    } catch (error) {
      this.logger.error('Error getting post stats:', error)
      throw error
    }
  }
}
```

## Best Practices Summary

**Key patterns for advanced NestJS Drizzle PostgreSQL integration:**

1. **Schema Design**: Use comprehensive table schemas with proper relationships, implement proper indexing strategies, use enums for constrained values, include audit fields and soft deletes.

2. **Query Optimization**: Implement proper pagination and filtering, use full-text search for content, leverage composite indexes, implement query result caching where appropriate.

3. **Service Architecture**: Create comprehensive service methods with validation, implement proper error handling and logging, use database transactions for complex operations, provide health checks and monitoring.

4. **Type Safety**: Use Drizzle's TypeScript integration, implement Zod validation schemas, properly type all database operations, leverage InferSelect and InferInsert types.

5. **Performance**: Implement connection pooling, use prepared statements, monitor query performance, implement proper caching strategies, optimize for large datasets.

Always implement proper error handling, use transactions for data consistency, monitor database performance, and follow PostgreSQL best practices for optimal production performance. 