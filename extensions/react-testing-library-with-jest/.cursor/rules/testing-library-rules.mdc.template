---
description: Advanced React Testing Library patterns with Jest for user-centric testing, accessibility, performance, and comprehensive coverage.
globs: '**/*.{test,spec}.{ts,tsx,js,jsx}'
---

# Advanced React Testing Library & Jest Patterns

## User-Centric Testing Philosophy

**Test like your users interact:**
```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { describe, it, expect, vi } from 'vitest'
import { LoginForm } from './LoginForm'

// ✅ Focus on user behavior, not implementation
describe('LoginForm', () => {
  const user = userEvent.setup()
  
  it('allows users to log in with valid credentials', async () => {
    const mockLogin = vi.fn().mockResolvedValue({ success: true })
    render(<LoginForm onLogin={mockLogin} />)
    
    // ✅ Use accessible queries that match how users interact
    const emailInput = screen.getByRole('textbox', { name: /email/i })
    const passwordInput = screen.getByLabelText(/password/i)
    const submitButton = screen.getByRole('button', { name: /log in/i })
    
    // ✅ Test realistic user interactions
    await user.type(emailInput, 'user@example.com')
    await user.type(passwordInput, 'password123')
    await user.click(submitButton)
    
    // ✅ Assert on user-visible outcomes
    await waitFor(() => {
      expect(screen.getByText(/welcome back/i)).toBeInTheDocument()
    })
    
    expect(mockLogin).toHaveBeenCalledWith({
      email: 'user@example.com',
      password: 'password123'
    })
  })
  
  it('shows validation errors for invalid input', async () => {
    render(<LoginForm onLogin={vi.fn()} />)
    
    const submitButton = screen.getByRole('button', { name: /log in/i })
    await user.click(submitButton)
    
    // ✅ Test error states users would see
    expect(await screen.findByText(/email is required/i)).toBeInTheDocument()
    expect(await screen.findByText(/password is required/i)).toBeInTheDocument()
    
    // ✅ Verify error accessibility
    const emailInput = screen.getByRole('textbox', { name: /email/i })
    expect(emailInput).toHaveAttribute('aria-invalid', 'true')
    expect(emailInput).toHaveAccessibleDescription(/email is required/i)
  })
  
  it('handles network errors gracefully', async () => {
    const mockLogin = vi.fn().mockRejectedValue(new Error('Network error'))
    render(<LoginForm onLogin={mockLogin} />)
    
    await user.type(screen.getByRole('textbox', { name: /email/i }), 'user@example.com')
    await user.type(screen.getByLabelText(/password/i), 'password123')
    await user.click(screen.getByRole('button', { name: /log in/i }))
    
    // ✅ Test error handling from user perspective
    await waitFor(() => {
      expect(screen.getByText(/something went wrong/i)).toBeInTheDocument()
    })
  })
})
```

## Advanced Query Patterns

**Robust element selection strategies:**
```typescript
// ✅ Query priority hierarchy (most to least preferred)

// 1. Accessible to everyone
const submitButton = screen.getByRole('button', { name: /submit/i })
const emailField = screen.getByLabelText(/email address/i)
const heading = screen.getByRole('heading', { level: 1 })

// 2. Accessible to screen readers
const errorMessage = screen.getByText(/invalid credentials/i)
const description = screen.getByDisplayValue('Default value')

// 3. Still accessible but not ideal
const placeholder = screen.getByPlaceholderText(/enter your email/i)
const altText = screen.getByAltText(/company logo/i)

// 4. Last resort (but sometimes necessary)
const customElement = screen.getByTestId('complex-widget')

// ✅ Custom render utilities for common patterns
function renderWithProviders(
  ui: React.ReactElement,
  {
    initialState = {},
    store = setupStore(initialState),
    ...renderOptions
  } = {}
) {
  function Wrapper({ children }: { children: React.ReactNode }) {
    return (
      <Provider store={store}>
        <Router>
          <ThemeProvider theme={testTheme}>
            {children}
          </ThemeProvider>
        </Router>
      </Provider>
    )
  }
  
  return {
    store,
    ...render(ui, { wrapper: Wrapper, ...renderOptions })
  }
}

// ✅ Custom matchers for domain-specific assertions
expect.extend({
  toBeValidEmail(received: string) {
    const isValid = /\S+@\S+\.\S+/.test(received)
    return {
      message: () => `expected ${received} to be a valid email address`,
      pass: isValid
    }
  },
  
  toHaveLoadingState(element: HTMLElement) {
    const hasSpinner = element.querySelector('[data-testid="spinner"]')
    const hasLoadingText = element.textContent?.includes('Loading')
    const hasAriaLabel = element.getAttribute('aria-busy') === 'true'
    
    const isLoading = hasSpinner || hasLoadingText || hasAriaLabel
    
    return {
      message: () => `expected element to have loading state`,
      pass: !!isLoading
    }
  }
})
```

## Complex Interaction Testing

**Real-world user scenarios:**
```typescript
describe('ShoppingCart', () => {
  it('handles the complete shopping flow', async () => {
    const user = userEvent.setup()
    const mockApi = setupMockApi()
    
    render(<ShoppingApp />, { wrapper: AppProviders })
    
    // ✅ Browse products
    const productGrid = screen.getByRole('grid', { name: /products/i })
    expect(productGrid).toBeInTheDocument()
    
    // ✅ Add items to cart
    const firstProduct = within(productGrid).getAllByRole('gridcell')[0]
    const addToCartButton = within(firstProduct).getByRole('button', { 
      name: /add to cart/i 
    })
    
    await user.click(addToCartButton)
    
    // ✅ Verify cart counter updates
    const cartCounter = screen.getByText('1', { 
      selector: '[aria-label*="items in cart"]' 
    })
    expect(cartCounter).toBeInTheDocument()
    
    // ✅ Open cart and proceed to checkout
    const cartButton = screen.getByRole('button', { name: /view cart/i })
    await user.click(cartButton)
    
    const checkoutButton = await screen.findByRole('button', { 
      name: /proceed to checkout/i 
    })
    await user.click(checkoutButton)
    
    // ✅ Fill checkout form
    await user.type(
      screen.getByRole('textbox', { name: /shipping address/i }),
      '123 Main St'
    )
    
    await user.selectOptions(
      screen.getByRole('combobox', { name: /payment method/i }),
      'credit-card'
    )
    
    // ✅ Submit order
    const placeOrderButton = screen.getByRole('button', { name: /place order/i })
    await user.click(placeOrderButton)
    
    // ✅ Verify success state
    await waitFor(() => {
      expect(screen.getByRole('status')).toHaveTextContent(/order confirmed/i)
    })
  })
})

// ✅ Testing complex forms with validation
describe('ProfileForm', () => {
  it('validates form fields in real-time', async () => {
    const user = userEvent.setup()
    render(<ProfileForm />)
    
    const emailInput = screen.getByRole('textbox', { name: /email/i })
    const phoneInput = screen.getByRole('textbox', { name: /phone/i })
    
    // ✅ Test progressive validation
    await user.type(emailInput, 'invalid-email')
    await user.tab() // Blur event
    
    expect(await screen.findByText(/please enter a valid email/i)).toBeInTheDocument()
    
    // ✅ Test validation clearing
    await user.clear(emailInput)
    await user.type(emailInput, 'valid@example.com')
    
    await waitFor(() => {
      expect(screen.queryByText(/please enter a valid email/i)).not.toBeInTheDocument()
    })
    
    // ✅ Test phone number formatting
    await user.type(phoneInput, '1234567890')
    expect(phoneInput).toHaveValue('(123) 456-7890')
  })
})
```

## Mock Strategies & API Testing

**Comprehensive mocking patterns:**
```typescript
import { rest } from 'msw'
import { setupServer } from 'msw/node'

// ✅ MSW server setup for realistic API mocking
const server = setupServer(
  rest.get('/api/users', (req, res, ctx) => {
    const page = req.url.searchParams.get('page') || '1'
    
    return res(
      ctx.json({
        users: generateMockUsers(10),
        pagination: {
          page: parseInt(page),
          total: 100,
          hasNext: parseInt(page) < 10
        }
      })
    )
  }),
  
  rest.post('/api/users', async (req, res, ctx) => {
    const newUser = await req.json()
    
    // ✅ Simulate validation errors
    if (!newUser.email) {
      return res(
        ctx.status(400),
        ctx.json({ error: 'Email is required' })
      )
    }
    
    return res(
      ctx.status(201),
      ctx.json({ ...newUser, id: Math.random().toString() })
    )
  }),
  
  // ✅ Simulate network delays and errors
  rest.get('/api/slow-endpoint', (req, res, ctx) => {
    return res(
      ctx.delay(2000), // 2 second delay
      ctx.json({ data: 'slow response' })
    )
  }),
  
  rest.get('/api/error-endpoint', (req, res, ctx) => {
    return res(ctx.status(500), ctx.json({ error: 'Server error' }))
  })
)

beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())

// ✅ Testing loading and error states
describe('UserList', () => {
  it('shows loading spinner while fetching users', async () => {
    server.use(
      rest.get('/api/users', (req, res, ctx) => {
        return res(ctx.delay(1000), ctx.json({ users: [] }))
      })
    )
    
    render(<UserList />)
    
    expect(screen.getByLabelText(/loading users/i)).toBeInTheDocument()
    
    await waitForElementToBeRemoved(
      screen.getByLabelText(/loading users/i)
    )
  })
  
  it('displays error message when API fails', async () => {
    server.use(
      rest.get('/api/users', (req, res, ctx) => {
        return res(ctx.status(500))
      })
    )
    
    render(<UserList />)
    
    expect(await screen.findByText(/failed to load users/i)).toBeInTheDocument()
    
    // ✅ Test retry functionality
    const retryButton = screen.getByRole('button', { name: /try again/i })
    await user.click(retryButton)
    
    // Should attempt to reload
    expect(await screen.findByLabelText(/loading users/i)).toBeInTheDocument()
  })
})

// ✅ Testing WebSocket connections
describe('ChatComponent', () => {
  const mockWebSocket = {
    send: vi.fn(),
    close: vi.fn(),
    readyState: WebSocket.OPEN
  }
  
  beforeEach(() => {
    global.WebSocket = vi.fn(() => mockWebSocket) as any
  })
  
  it('sends and receives chat messages', async () => {
    const user = userEvent.setup()
    render(<ChatComponent roomId="test-room" />)
    
    const messageInput = screen.getByRole('textbox', { name: /message/i })
    const sendButton = screen.getByRole('button', { name: /send/i })
    
    await user.type(messageInput, 'Hello world!')
    await user.click(sendButton)
    
    expect(mockWebSocket.send).toHaveBeenCalledWith(
      JSON.stringify({
        type: 'message',
        content: 'Hello world!',
        roomId: 'test-room'
      })
    )
    
    // ✅ Simulate receiving a message
    act(() => {
      mockWebSocket.onmessage?.({
        data: JSON.stringify({
          type: 'message',
          content: 'Hello back!',
          author: 'John Doe'
        })
      } as MessageEvent)
    })
    
    expect(await screen.findByText('Hello back!')).toBeInTheDocument()
    expect(screen.getByText('John Doe')).toBeInTheDocument()
  })
})
```

## Accessibility Testing

**A11y testing patterns:**
```typescript
import { axe, toHaveNoViolations } from 'jest-axe'

expect.extend(toHaveNoViolations)

describe('Accessibility', () => {
  it('has no accessibility violations', async () => {
    const { container } = render(<ComplexForm />)
    const results = await axe(container)
    expect(results).toHaveNoViolations()
  })
  
  it('supports keyboard navigation', async () => {
    const user = userEvent.setup()
    render(<NavigationMenu />)
    
    const firstItem = screen.getAllByRole('menuitem')[0]
    firstItem.focus()
    expect(firstItem).toHaveFocus()
    
    // ✅ Test arrow key navigation
    await user.keyboard('{ArrowDown}')
    const secondItem = screen.getAllByRole('menuitem')[1]
    expect(secondItem).toHaveFocus()
    
    // ✅ Test escape key
    await user.keyboard('{Escape}')
    expect(screen.getByRole('button', { name: /menu/i })).toHaveFocus()
  })
  
  it('provides proper screen reader support', () => {
    render(<DataTable data={mockData} />)
    
    const table = screen.getByRole('table')
    expect(table).toHaveAttribute('aria-label', 'User data')
    
    const headers = screen.getAllByRole('columnheader')
    headers.forEach(header => {
      expect(header).toHaveAttribute('scope', 'col')
    })
    
    const sortableHeader = screen.getByRole('columnheader', { name: /name/i })
    expect(sortableHeader).toHaveAttribute('aria-sort', 'ascending')
  })
})
```

## Performance Testing

**Testing performance-critical features:**
```typescript
describe('Performance', () => {
  it('renders large lists efficiently', () => {
    const largeDataset = generateMockData(10000)
    const startTime = performance.now()
    
    render(<VirtualizedList data={largeDataset} />)
    
    const renderTime = performance.now() - startTime
    expect(renderTime).toBeLessThan(100) // Should render in under 100ms
    
    // ✅ Only visible items should be in DOM
    const visibleItems = screen.getAllByTestId('list-item')
    expect(visibleItems.length).toBeLessThan(50) // Virtualized
  })
  
  it('debounces search input', async () => {
    const user = userEvent.setup()
    const mockSearch = vi.fn()
    
    render(<SearchBox onSearch={mockSearch} />)
    
    const input = screen.getByRole('textbox')
    
    // ✅ Type quickly - should debounce
    await user.type(input, 'react')
    
    // Should not call immediately
    expect(mockSearch).not.toHaveBeenCalled()
    
    // ✅ Wait for debounce
    await waitFor(() => {
      expect(mockSearch).toHaveBeenCalledWith('react')
    }, { timeout: 1000 })
    
    expect(mockSearch).toHaveBeenCalledTimes(1)
  })
})