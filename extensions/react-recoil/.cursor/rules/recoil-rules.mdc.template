---
description: Comprehensive patterns and best practices for implementing enterprise-grade state management with Recoil in React applications.
globs: '**/*.{ts,tsx,js,jsx}'
---

# Recoil Advanced Implementation Patterns

## Core State Architecture

**Atomic state design with typed atoms and selectors:**
```tsx
import { atom, selector, atomFamily, selectorFamily, RecoilRoot, useRecoilState, useRecoilValue, useSetRecoilState } from 'recoil'

// ✅ Domain entity types
export interface User {
  id: string
  firstName: string
  lastName: string
  email: string
  avatar?: string
  isActive: boolean
  roles: string[]
  lastLoginAt?: Date
  createdAt: Date
  updatedAt: Date
}

export interface UserFilters {
  search: string
  status: 'all' | 'active' | 'inactive'
  role: string
  sortBy: 'firstName' | 'lastName' | 'email' | 'lastLoginAt' | 'createdAt'
  sortOrder: 'asc' | 'desc'
}

export interface UserPagination {
  page: number
  pageSize: number
  total: number
}

// ✅ Atomic state atoms
export const usersState = atom<Map<string, User>>({
  key: 'usersState',
  default: new Map(),
})

export const userFiltersState = atom<UserFilters>({
  key: 'userFiltersState',
  default: {
    search: '',
    status: 'all',
    role: 'all',
    sortBy: 'firstName',
    sortOrder: 'asc',
  },
})

export const userPaginationState = atom<UserPagination>({
  key: 'userPaginationState',
  default: {
    page: 1,
    pageSize: 20,
    total: 0,
  },
})

export const userLoadingState = atom<boolean>({
  key: 'userLoadingState',
  default: false,
})

export const userErrorState = atom<string | null>({
  key: 'userErrorState',
  default: null,
})

export const currentUserIdState = atom<string | null>({
  key: 'currentUserIdState',
  default: null,
})

// ✅ Atom families for dynamic state
export const userByIdState = atomFamily<User | null, string>({
  key: 'userByIdState',
  default: null,
})

export const userFormState = atomFamily<Partial<User>, string>({
  key: 'userFormState',
  default: {
    firstName: '',
    lastName: '',
    email: '',
    isActive: true,
    roles: ['user'],
  },
})

// ✅ Complex selectors with derived state
export const allUsersSelector = selector<User[]>({
  key: 'allUsersSelector',
  get: ({ get }) => {
    const usersMap = get(usersState)
    return Array.from(usersMap.values())
  },
})

export const filteredUsersSelector = selector<User[]>({
  key: 'filteredUsersSelector',
  get: ({ get }) => {
    const users = get(allUsersSelector)
    const filters = get(userFiltersState)

    let filtered = users

    // Search filter
    if (filters.search) {
      const search = filters.search.toLowerCase()
      filtered = filtered.filter(user =>
        user.firstName.toLowerCase().includes(search) ||
        user.lastName.toLowerCase().includes(search) ||
        user.email.toLowerCase().includes(search)
      )
    }

    // Status filter
    if (filters.status !== 'all') {
      filtered = filtered.filter(user =>
        filters.status === 'active' ? user.isActive : !user.isActive
      )
    }

    // Role filter
    if (filters.role !== 'all') {
      filtered = filtered.filter(user => user.roles.includes(filters.role))
    }

    // Sorting
    filtered.sort((a, b) => {
      const aValue = a[filters.sortBy]
      const bValue = b[filters.sortBy]

      if (aValue === undefined || aValue === null) return 1
      if (bValue === undefined || bValue === null) return -1

      let comparison = 0
      if (aValue instanceof Date && bValue instanceof Date) {
        comparison = aValue.getTime() - bValue.getTime()
      } else {
        comparison = String(aValue).localeCompare(String(bValue))
      }

      return filters.sortOrder === 'desc' ? -comparison : comparison
    })

    return filtered
  },
})

export const paginatedUsersSelector = selector<User[]>({
  key: 'paginatedUsersSelector',
  get: ({ get }) => {
    const filtered = get(filteredUsersSelector)
    const pagination = get(userPaginationState)

    const startIndex = (pagination.page - 1) * pagination.pageSize
    const endIndex = startIndex + pagination.pageSize

    return filtered.slice(startIndex, endIndex)
  },
})

export const userStatsSelector = selector({
  key: 'userStatsSelector',
  get: ({ get }) => {
    const users = get(allUsersSelector)
    const filtered = get(filteredUsersSelector)

    const activeUsers = users.filter(user => user.isActive)
    const onlineUsers = users.filter(user => 
      user.lastLoginAt && 
      Date.now() - user.lastLoginAt.getTime() < 5 * 60 * 1000 // 5 minutes
    )

    const roleDistribution = users.reduce((acc, user) => {
      user.roles.forEach(role => {
        acc[role] = (acc[role] || 0) + 1
      })
      return acc
    }, {} as Record<string, number>)

    return {
      total: users.length,
      active: activeUsers.length,
      inactive: users.length - activeUsers.length,
      online: onlineUsers.length,
      filtered: filtered.length,
      roleDistribution,
      averageRolesPerUser: users.length > 0 
        ? users.reduce((sum, user) => sum + user.roles.length, 0) / users.length
        : 0,
    }
  },
})

export const currentUserSelector = selector<User | null>({
  key: 'currentUserSelector',
  get: ({ get }) => {
    const currentUserId = get(currentUserIdState)
    if (!currentUserId) return null
    
    const users = get(usersState)
    return users.get(currentUserId) || null
  },
})

// ✅ Selector families for parameterized queries
export const usersByRoleSelector = selectorFamily<User[], string>({
  key: 'usersByRoleSelector',
  get: (role: string) => ({ get }) => {
    const users = get(allUsersSelector)
    return users.filter(user => user.roles.includes(role))
  },
})

export const userSearchSelector = selectorFamily<User[], string>({
  key: 'userSearchSelector',
  get: (query: string) => ({ get }) => {
    const users = get(allUsersSelector)
    const searchTerm = query.toLowerCase()
    
    return users.filter(user =>
      user.firstName.toLowerCase().includes(searchTerm) ||
      user.lastName.toLowerCase().includes(searchTerm) ||
      user.email.toLowerCase().includes(searchTerm)
    )
  },
})

// ✅ Async selectors for data fetching
export const userAsyncSelector = selector<User[]>({
  key: 'userAsyncSelector',
  get: async ({ get }) => {
    const loading = get(userLoadingState)
    if (loading) {
      throw new Promise(resolve => {
        // This will suspend the component until loading is false
        const checkLoading = () => {
          if (!loading) {
            resolve([])
          } else {
            setTimeout(checkLoading, 100)
          }
        }
        checkLoading()
      })
    }

    try {
      const response = await fetch('/api/users')
      if (!response.ok) {
        throw new Error(`Failed to fetch users: ${response.statusText}`)
      }
      const userData: User[] = await response.json()
      return userData
    } catch (error) {
      console.error('Error fetching users:', error)
      throw error
    }
  },
})

export const userByIdAsyncSelector = selectorFamily<User | null, string>({
  key: 'userByIdAsyncSelector',
  get: (userId: string) => async ({ get }) => {
    // First check if user exists in current state
    const users = get(usersState)
    const existingUser = users.get(userId)
    if (existingUser) return existingUser

    try {
      const response = await fetch(`/api/users/${userId}`)
      if (!response.ok) {
        if (response.status === 404) return null
        throw new Error(`Failed to fetch user: ${response.statusText}`)
      }
      const user: User = await response.json()
      return user
    } catch (error) {
      console.error(`Error fetching user ${userId}:`, error)
      throw error
    }
  },
})
```

## Advanced React Integration

**Optimized components with Recoil hooks and suspense:**
```tsx
import React, { Suspense, useCallback, useEffect, useMemo, useState } from 'react'
import { ErrorBoundary } from 'react-error-boundary'

// ✅ Root provider setup
export const AppWithRecoil: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <RecoilRoot>
      <ErrorBoundary
        FallbackComponent={({ error, resetErrorBoundary }) => (
          <div className="error-boundary">
            <h2>Something went wrong:</h2>
            <pre>{error.message}</pre>
            <button onClick={resetErrorBoundary}>Try again</button>
          </div>
        )}
      >
        <Suspense fallback={<div className="global-loading">Loading application...</div>}>
          {children}
        </Suspense>
      </ErrorBoundary>
    </RecoilRoot>
  )
}

// ✅ Smart user list component with suspense
const UserList: React.FC = () => {
  const users = useRecoilValue(paginatedUsersSelector)
  const stats = useRecoilValue(userStatsSelector)
  const loading = useRecoilValue(userLoadingState)
  const error = useRecoilValue(userErrorState)

  if (loading) {
    return (
      <div className="user-list-loading">
        <div className="spinner" />
        <p>Loading users...</p>
      </div>
    )
  }

  if (error) {
    return (
      <div className="user-list-error">
        <h3>Error loading users</h3>
        <p>{error}</p>
        <UserListActions />
      </div>
    )
  }

  return (
    <div className="user-list">
      <div className="user-list-header">
        <UserStats stats={stats} />
        <UserFilters />
      </div>
      
      <div className="user-list-content">
        {users.length === 0 ? (
          <div className="empty-state">
            <h3>No users found</h3>
            <p>Try adjusting your filters or search criteria</p>
          </div>
        ) : (
          users.map(user => <UserListItem key={user.id} user={user} />)
        )}
      </div>
      
      <UserPagination />
    </div>
  )
}

// ✅ Individual user item component
const UserListItem: React.FC<{ user: User }> = React.memo(({ user }) => {
  const setCurrentUserId = useSetRecoilState(currentUserIdState)
  const setUsers = useSetRecoilState(usersState)

  const handleUserClick = useCallback(() => {
    setCurrentUserId(user.id)
  }, [user.id, setCurrentUserId])

  const handleToggleStatus = useCallback(() => {
    setUsers(prevUsers => {
      const newUsers = new Map(prevUsers)
      const existingUser = newUsers.get(user.id)
      if (existingUser) {
        newUsers.set(user.id, {
          ...existingUser,
          isActive: !existingUser.isActive,
          updatedAt: new Date(),
        })
      }
      return newUsers
    })
  }, [user.id, setUsers])

  return (
    <div className={`user-item ${user.isActive ? 'active' : 'inactive'}`}>
      <div className="user-avatar" onClick={handleUserClick}>
        {user.avatar ? (
          <img src={user.avatar} alt={`${user.firstName} ${user.lastName}`} />
        ) : (
          <span className="initials">
            {user.firstName.charAt(0)}{user.lastName.charAt(0)}
          </span>
        )}
      </div>
      
      <div className="user-details">
        <h4>{user.firstName} {user.lastName}</h4>
        <p>{user.email}</p>
        <div className="user-roles">
          {user.roles.map(role => (
            <span key={role} className="role-badge">
              {role}
            </span>
          ))}
        </div>
        {user.lastLoginAt && (
          <p className="last-login">
            Last login: {user.lastLoginAt.toLocaleString()}
          </p>
        )}
      </div>
      
      <div className="user-actions">
        <button 
          className={`toggle-status ${user.isActive ? 'deactivate' : 'activate'}`}
          onClick={handleToggleStatus}
        >
          {user.isActive ? 'Deactivate' : 'Activate'}
        </button>
      </div>
    </div>
  )
})

// ✅ Advanced filters component
const UserFilters: React.FC = () => {
  const [filters, setFilters] = useRecoilState(userFiltersState)
  const stats = useRecoilValue(userStatsSelector)

  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setFilters(prev => ({ ...prev, search: e.target.value }))
  }, [setFilters])

  const handleStatusChange = useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {
    setFilters(prev => ({ ...prev, status: e.target.value as UserFilters['status'] }))
  }, [setFilters])

  const handleRoleChange = useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {
    setFilters(prev => ({ ...prev, role: e.target.value }))
  }, [setFilters])

  const handleSortChange = useCallback((field: UserFilters['sortBy']) => {
    setFilters(prev => ({
      ...prev,
      sortBy: field,
      sortOrder: prev.sortBy === field && prev.sortOrder === 'asc' ? 'desc' : 'asc',
    }))
  }, [setFilters])

  const roleOptions = useMemo(() => 
    Object.entries(stats.roleDistribution).map(([role, count]) => ({
      value: role,
      label: `${role} (${count})`,
    }))
  , [stats.roleDistribution])

  return (
    <div className="user-filters">
      <div className="search-group">
        <input
          type="text"
          placeholder="Search users..."
          value={filters.search}
          onChange={handleSearchChange}
          className="search-input"
        />
      </div>
      
      <div className="filter-group">
        <select value={filters.status} onChange={handleStatusChange}>
          <option value="all">All Status</option>
          <option value="active">Active ({stats.active})</option>
          <option value="inactive">Inactive ({stats.inactive})</option>
        </select>
        
        <select value={filters.role} onChange={handleRoleChange}>
          <option value="all">All Roles</option>
          {roleOptions.map(({ value, label }) => (
            <option key={value} value={value}>{label}</option>
          ))}
        </select>
      </div>
      
      <div className="sort-group">
        <span>Sort by:</span>
        {(['firstName', 'lastName', 'email', 'lastLoginAt', 'createdAt'] as const).map(field => (
          <button
            key={field}
            onClick={() => handleSortChange(field)}
            className={`sort-button ${filters.sortBy === field ? 'active' : ''}`}
          >
            {field} {filters.sortBy === field && (filters.sortOrder === 'asc' ? '↑' : '↓')}
          </button>
        ))}
      </div>
    </div>
  )
}

// ✅ Stats display component
const UserStats: React.FC<{ stats: ReturnType<typeof userStatsSelector['get']> }> = ({ stats }) => {
  return (
    <div className="user-stats">
      <div className="stat-item">
        <span className="stat-value">{stats.total}</span>
        <span className="stat-label">Total Users</span>
      </div>
      <div className="stat-item">
        <span className="stat-value">{stats.active}</span>
        <span className="stat-label">Active</span>
      </div>
      <div className="stat-item">
        <span className="stat-value">{stats.online}</span>
        <span className="stat-label">Online</span>
      </div>
      <div className="stat-item">
        <span className="stat-value">{stats.filtered}</span>
        <span className="stat-label">Filtered</span>
      </div>
      <div className="stat-item">
        <span className="stat-value">{stats.averageRolesPerUser.toFixed(1)}</span>
        <span className="stat-label">Avg Roles</span>
      </div>
    </div>
  )
}

// ✅ Pagination component
const UserPagination: React.FC = () => {
  const [pagination, setPagination] = useRecoilState(userPaginationState)
  const filteredCount = useRecoilValue(filteredUsersSelector).length

  const totalPages = Math.ceil(filteredCount / pagination.pageSize)

  const handlePageChange = useCallback((newPage: number) => {
    setPagination(prev => ({ ...prev, page: newPage }))
  }, [setPagination])

  const handlePageSizeChange = useCallback((e: React.ChangeEvent<HTMLSelectElement>) => {
    const newPageSize = parseInt(e.target.value)
    setPagination(prev => ({ 
      ...prev, 
      pageSize: newPageSize,
      page: Math.min(prev.page, Math.ceil(filteredCount / newPageSize) || 1)
    }))
  }, [setPagination, filteredCount])

  if (totalPages <= 1) return null

  return (
    <div className="user-pagination">
      <div className="pagination-info">
        Showing {((pagination.page - 1) * pagination.pageSize) + 1} - {Math.min(pagination.page * pagination.pageSize, filteredCount)} of {filteredCount}
      </div>
      
      <div className="pagination-controls">
        <button 
          disabled={pagination.page <= 1}
          onClick={() => handlePageChange(pagination.page - 1)}
        >
          Previous
        </button>
        
        <span className="page-numbers">
          {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
            const pageNum = Math.max(1, pagination.page - 2) + i
            if (pageNum > totalPages) return null
            
            return (
              <button
                key={pageNum}
                className={pageNum === pagination.page ? 'active' : ''}
                onClick={() => handlePageChange(pageNum)}
              >
                {pageNum}
              </button>
            )
          })}
        </span>
        
        <button 
          disabled={pagination.page >= totalPages}
          onClick={() => handlePageChange(pagination.page + 1)}
        >
          Next
        </button>
      </div>
      
      <div className="page-size-selector">
        <select value={pagination.pageSize} onChange={handlePageSizeChange}>
          <option value={10}>10 per page</option>
          <option value={20}>20 per page</option>
          <option value={50}>50 per page</option>
          <option value={100}>100 per page</option>
        </select>
      </div>
    </div>
  )
}
```

## Custom Hooks & Utilities

**Reusable hooks for common Recoil patterns:**
```tsx
// ✅ Custom hooks for complex state operations
export const useUserOperations = () => {
  const setUsers = useSetRecoilState(usersState)
  const setLoading = useSetRecoilState(userLoadingState)
  const setError = useSetRecoilState(userErrorState)
  const setPagination = useSetRecoilState(userPaginationState)

  const createUser = useCallback(async (userData: Omit<User, 'id' | 'createdAt' | 'updatedAt'>) => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData),
      })

      if (!response.ok) {
        throw new Error(`Failed to create user: ${response.statusText}`)
      }

      const newUser: User = await response.json()

      setUsers(prevUsers => {
        const newUsers = new Map(prevUsers)
        newUsers.set(newUser.id, newUser)
        return newUsers
      })

      setPagination(prev => ({ ...prev, total: prev.total + 1 }))

      return newUser
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to create user'
      setError(errorMessage)
      throw error
    } finally {
      setLoading(false)
    }
  }, [setUsers, setLoading, setError, setPagination])

  const updateUser = useCallback(async (userId: string, updates: Partial<User>) => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch(`/api/users/${userId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      })

      if (!response.ok) {
        throw new Error(`Failed to update user: ${response.statusText}`)
      }

      const updatedUser: User = await response.json()

      setUsers(prevUsers => {
        const newUsers = new Map(prevUsers)
        newUsers.set(userId, updatedUser)
        return newUsers
      })

      return updatedUser
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to update user'
      setError(errorMessage)
      throw error
    } finally {
      setLoading(false)
    }
  }, [setUsers, setLoading, setError])

  const deleteUser = useCallback(async (userId: string) => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch(`/api/users/${userId}`, {
        method: 'DELETE',
      })

      if (!response.ok) {
        throw new Error(`Failed to delete user: ${response.statusText}`)
      }

      setUsers(prevUsers => {
        const newUsers = new Map(prevUsers)
        newUsers.delete(userId)
        return newUsers
      })

      setPagination(prev => ({ 
        ...prev, 
        total: Math.max(0, prev.total - 1),
        page: Math.min(prev.page, Math.ceil((prev.total - 1) / prev.pageSize) || 1)
      }))

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to delete user'
      setError(errorMessage)
      throw error
    } finally {
      setLoading(false)
    }
  }, [setUsers, setLoading, setError, setPagination])

  const bulkUpdateUsers = useCallback(async (userIds: string[], updates: Partial<User>) => {
    setLoading(true)
    setError(null)

    try {
      const promises = userIds.map(id => 
        fetch(`/api/users/${id}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(updates),
        })
      )

      const responses = await Promise.allSettled(promises)
      const successful: User[] = []
      const failed: string[] = []

      for (let i = 0; i < responses.length; i++) {
        const response = responses[i]
        if (response.status === 'fulfilled' && response.value.ok) {
          const user: User = await response.value.json()
          successful.push(user)
        } else {
          failed.push(userIds[i])
        }
      }

      if (successful.length > 0) {
        setUsers(prevUsers => {
          const newUsers = new Map(prevUsers)
          successful.forEach(user => {
            newUsers.set(user.id, user)
          })
          return newUsers
        })
      }

      if (failed.length > 0) {
        setError(`Failed to update ${failed.length} users`)
      }

      return { successful, failed }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Bulk update failed'
      setError(errorMessage)
      throw error
    } finally {
      setLoading(false)
    }
  }, [setUsers, setLoading, setError])

  return {
    createUser,
    updateUser,
    deleteUser,
    bulkUpdateUsers,
  }
}

// ✅ Hook for managing user search with debouncing
export const useUserSearch = (debounceMs = 300) => {
  const [filters, setFilters] = useRecoilState(userFiltersState)
  const [debouncedQuery, setDebouncedQuery] = useState(filters.search)

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedQuery(filters.search)
    }, debounceMs)

    return () => clearTimeout(timer)
  }, [filters.search, debounceMs])

  const searchResults = useRecoilValue(
    useMemo(() => userSearchSelector(debouncedQuery), [debouncedQuery])
  )

  const setSearchQuery = useCallback((query: string) => {
    setFilters(prev => ({ ...prev, search: query, page: 1 }))
  }, [setFilters])

  return {
    query: filters.search,
    debouncedQuery,
    results: searchResults,
    setSearchQuery,
  }
}

// ✅ Hook for user form management
export const useUserForm = (initialUserId?: string) => {
  const [formState, setFormState] = useRecoilState(
    userFormState(initialUserId || 'new')
  )
  const { createUser, updateUser } = useUserOperations()
  const [validationErrors, setValidationErrors] = useState<Record<string, string>>({})

  const validateForm = useCallback((data: Partial<User>): Record<string, string> => {
    const errors: Record<string, string> = {}

    if (!data.firstName?.trim()) {
      errors.firstName = 'First name is required'
    }

    if (!data.lastName?.trim()) {
      errors.lastName = 'Last name is required'
    }

    if (!data.email?.trim()) {
      errors.email = 'Email is required'
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.email)) {
      errors.email = 'Invalid email format'
    }

    if (!data.roles?.length) {
      errors.roles = 'At least one role is required'
    }

    return errors
  }, [])

  const updateField = useCallback(<K extends keyof Partial<User>>(
    field: K,
    value: Partial<User>[K]
  ) => {
    setFormState(prev => ({ ...prev, [field]: value }))
    
    // Clear validation error for this field
    if (validationErrors[field]) {
      setValidationErrors(prev => {
        const { [field]: _, ...rest } = prev
        return rest
      })
    }
  }, [setFormState, validationErrors])

  const resetForm = useCallback(() => {
    setFormState({
      firstName: '',
      lastName: '',
      email: '',
      isActive: true,
      roles: ['user'],
    })
    setValidationErrors({})
  }, [setFormState])

  const submitForm = useCallback(async () => {
    const errors = validateForm(formState)
    setValidationErrors(errors)

    if (Object.keys(errors).length > 0) {
      return false
    }

    try {
      if (initialUserId && initialUserId !== 'new') {
        await updateUser(initialUserId, formState)
      } else {
        await createUser(formState as Omit<User, 'id' | 'createdAt' | 'updatedAt'>)
        resetForm()
      }
      return true
    } catch (error) {
      console.error('Form submission failed:', error)
      return false
    }
  }, [formState, initialUserId, createUser, updateUser, validateForm, resetForm])

  return {
    formState,
    validationErrors,
    updateField,
    resetForm,
    submitForm,
    isValid: Object.keys(validationErrors).length === 0,
  }
}

// ✅ Hook for managing local state persistence
export const usePersistentState = <T>(key: string, recoilState: RecoilState<T>) => {
  const [value, setValue] = useRecoilState(recoilState)

  useEffect(() => {
    const saved = localStorage.getItem(key)
    if (saved) {
      try {
        const parsed = JSON.parse(saved)
        setValue(parsed)
      } catch (error) {
        console.warn(`Failed to parse saved state for ${key}:`, error)
      }
    }
  }, [key, setValue])

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value))
  }, [key, value])

  return [value, setValue] as const
}
```

## Advanced Patterns & Performance

**Complex selectors, effects, and optimization techniques:**
```tsx
import { DefaultValue, selector, selectorFamily, atom, atomFamily, RecoilEnv } from 'recoil'

// Enable Recoil development tools
RecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = false

// ✅ Advanced selector patterns with caching
export const expensiveComputationSelector = selector({
  key: 'expensiveComputationSelector',
  get: ({ get }) => {
    const users = get(allUsersSelector)
    
    // Expensive computation that should be cached
    console.log('Computing expensive analytics...')
    
    return users.reduce((analytics, user) => {
      // Simulate heavy computation
      const userScore = user.roles.length * (user.isActive ? 1.5 : 0.5)
      const engagementScore = user.lastLoginAt 
        ? Math.max(0, 100 - Math.floor((Date.now() - user.lastLoginAt.getTime()) / (1000 * 60 * 60 * 24)))
        : 0

      analytics.totalScore += userScore + engagementScore
      analytics.userScores[user.id] = userScore
      analytics.engagementScores[user.id] = engagementScore

      return analytics
    }, {
      totalScore: 0,
      userScores: {} as Record<string, number>,
      engagementScores: {} as Record<string, number>,
      computedAt: new Date(),
    })
  },
})

// ✅ Selector with custom equality check
export const userListDisplaySelector = selector({
  key: 'userListDisplaySelector',
  get: ({ get }) => {
    const users = get(paginatedUsersSelector)
    const stats = get(userStatsSelector)
    
    return {
      users,
      stats,
      displayConfig: {
        showAvatars: true,
        showRoles: true,
        showLastLogin: stats.online > 0,
      },
    }
  },
  dangerouslyAllowMutability: true, // Only if needed for performance
})

// ✅ Writeable selector for complex state updates
export const userFiltersWriteableSelector = selector({
  key: 'userFiltersWriteableSelector',
  get: ({ get }) => get(userFiltersState),
  set: ({ set, get }, newValue) => {
    if (newValue instanceof DefaultValue) {
      set(userFiltersState, newValue)
      return
    }

    const currentPagination = get(userPaginationState)
    
    // Reset pagination when filters change
    set(userFiltersState, newValue)
    set(userPaginationState, {
      ...currentPagination,
      page: 1,
    })
  },
})

// ✅ Conditional selectors with error handling
export const conditionalDataSelector = selector({
  key: 'conditionalDataSelector',
  get: ({ get }) => {
    const currentUser = get(currentUserSelector)
    
    if (!currentUser) {
      return { data: null, error: 'No current user' }
    }

    try {
      // Only compute if user has admin role
      if (currentUser.roles.includes('admin')) {
        const allUsers = get(allUsersSelector)
        const adminData = {
          totalUsers: allUsers.length,
          sensitiveInfo: 'Admin only data',
          lastAccess: new Date(),
        }
        return { data: adminData, error: null }
      }
      
      return { data: null, error: 'Insufficient permissions' }
    } catch (error) {
      return { 
        data: null, 
        error: error instanceof Error ? error.message : 'Unknown error'
      }
    }
  },
})

// ✅ Time-based selectors with automatic updates
export const timeBasedStatsSelector = selector({
  key: 'timeBasedStatsSelector',
  get: ({ get }) => {
    const users = get(allUsersSelector)
    const now = Date.now()
    
    const timeRanges = {
      lastHour: now - 60 * 60 * 1000,
      lastDay: now - 24 * 60 * 60 * 1000,
      lastWeek: now - 7 * 24 * 60 * 60 * 1000,
      lastMonth: now - 30 * 24 * 60 * 60 * 1000,
    }

    return Object.entries(timeRanges).reduce((stats, [period, cutoff]) => {
      stats[period] = users.filter(user => 
        user.lastLoginAt && user.lastLoginAt.getTime() > cutoff
      ).length
      return stats
    }, {} as Record<string, number>)
  },
})

// ✅ Atom effects for side effects and persistence
export const userPreferencesState = atom({
  key: 'userPreferencesState',
  default: {
    theme: 'light' as 'light' | 'dark',
    language: 'en',
    pageSize: 20,
    autoRefresh: true,
    notifications: true,
  },
  effects: [
    // Local storage persistence
    ({ setSelf, onSet, node }) => {
      const savedValue = localStorage.getItem(node.key)
      if (savedValue != null) {
        setSelf(JSON.parse(savedValue))
      }

      onSet((newValue, _, isReset) => {
        if (isReset) {
          localStorage.removeItem(node.key)
        } else {
          localStorage.setItem(node.key, JSON.stringify(newValue))
        }
      })
    },
    // Analytics tracking
    ({ onSet }) => {
      onSet((newValue, oldValue) => {
        if (oldValue instanceof DefaultValue) return
        
        // Track preference changes
        const changes = Object.entries(newValue).filter(([key, value]) => 
          oldValue[key as keyof typeof oldValue] !== value
        )
        
        changes.forEach(([key, value]) => {
          console.log('Preference changed:', key, value)
          // Send to analytics service
        })
      })
    },
  ],
})

// ✅ Atom family with validation effects
export const validatedUserFormState = atomFamily({
  key: 'validatedUserFormState',
  default: (userId: string) => ({
    data: {
      firstName: '',
      lastName: '',
      email: '',
      isActive: true,
      roles: ['user'] as string[],
    },
    errors: {} as Record<string, string>,
    touched: {} as Record<string, boolean>,
    isValid: false,
  }),
  effects: (userId) => [
    ({ setSelf, onSet }) => {
      onSet((newValue, oldValue) => {
        if (newValue.data === oldValue.data) return

        // Validate on change
        const errors: Record<string, string> = {}
        
        if (!newValue.data.firstName?.trim()) {
          errors.firstName = 'First name is required'
        }
        
        if (!newValue.data.lastName?.trim()) {
          errors.lastName = 'Last name is required'
        }
        
        if (!newValue.data.email?.trim()) {
          errors.email = 'Email is required'
        } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(newValue.data.email)) {
          errors.email = 'Invalid email format'
        }

        const isValid = Object.keys(errors).length === 0
        
        setSelf({
          ...newValue,
          errors,
          isValid,
        })
      })
    },
  ],
})

// ✅ Performance monitoring selector
export const performanceMonitorSelector = selector({
  key: 'performanceMonitorSelector',
  get: ({ get }) => {
    const start = performance.now()
    
    // Get expensive computations
    const users = get(allUsersSelector)
    const stats = get(userStatsSelector)
    const expensiveData = get(expensiveComputationSelector)
    
    const end = performance.now()
    const computationTime = end - start

    if (computationTime > 10) {
      console.warn(`Slow selector computation: ${computationTime}ms`)
    }

    return {
      users: users.length,
      stats: Object.keys(stats).length,
      expensiveData: !!expensiveData,
      computationTime,
      timestamp: new Date(),
    }
  },
})
```

## Testing Patterns

**Comprehensive testing strategies for Recoil applications:**
```tsx
import { RecoilRoot, snapshot_UNSTABLE } from 'recoil'
import { renderHook, act } from '@testing-library/react'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'

// ✅ Test utilities for Recoil
export const createRecoilTestWrapper = (initialStates?: Array<{ atom: any; value: any }>) => {
  return ({ children }: { children: React.ReactNode }) => (
    <RecoilRoot initializeState={(snapshot) => {
      initialStates?.forEach(({ atom, value }) => {
        snapshot.set(atom, value)
      })
    }}>
      {children}
    </RecoilRoot>
  )
}

export const mockUsers: User[] = [
  {
    id: '1',
    firstName: 'John',
    lastName: 'Doe',
    email: 'john@example.com',
    isActive: true,
    roles: ['user', 'admin'],
    lastLoginAt: new Date(),
    createdAt: new Date('2023-01-01'),
    updatedAt: new Date(),
  },
  {
    id: '2',
    firstName: 'Jane',
    lastName: 'Smith',
    email: 'jane@example.com',
    isActive: true,
    roles: ['user'],
    lastLoginAt: new Date(Date.now() - 2 * 60 * 60 * 1000), // 2 hours ago
    createdAt: new Date('2023-02-01'),
    updatedAt: new Date(),
  },
  {
    id: '3',
    firstName: 'Inactive',
    lastName: 'User',
    email: 'inactive@example.com',
    isActive: false,
    roles: ['user'],
    createdAt: new Date('2023-03-01'),
    updatedAt: new Date(),
  },
]

// ✅ Atom and selector tests
describe('User State Management', () => {
  test('usersState holds user data correctly', () => {
    const Wrapper = createRecoilTestWrapper([
      { atom: usersState, value: new Map(mockUsers.map(user => [user.id, user])) }
    ])

    const { result } = renderHook(() => useRecoilValue(usersState), { wrapper: Wrapper })

    expect(result.current.size).toBe(3)
    expect(result.current.get('1')).toEqual(mockUsers[0])
  })

  test('filteredUsersSelector applies search filter', () => {
    const Wrapper = createRecoilTestWrapper([
      { atom: usersState, value: new Map(mockUsers.map(user => [user.id, user])) },
      { atom: userFiltersState, value: { ...userFiltersState.default, search: 'john' } }
    ])

    const { result } = renderHook(() => useRecoilValue(filteredUsersSelector), { wrapper: Wrapper })

    expect(result.current).toHaveLength(1)
    expect(result.current[0].firstName).toBe('John')
  })

  test('userStatsSelector computes statistics correctly', () => {
    const Wrapper = createRecoilTestWrapper([
      { atom: usersState, value: new Map(mockUsers.map(user => [user.id, user])) }
    ])

    const { result } = renderHook(() => useRecoilValue(userStatsSelector), { wrapper: Wrapper })

    expect(result.current.total).toBe(3)
    expect(result.current.active).toBe(2)
    expect(result.current.inactive).toBe(1)
    expect(result.current.roleDistribution.user).toBe(3)
    expect(result.current.roleDistribution.admin).toBe(1)
  })
})

// ✅ Component integration tests
describe('UserList Component', () => {
  test('renders user list with data', async () => {
    const Wrapper = createRecoilTestWrapper([
      { atom: usersState, value: new Map(mockUsers.map(user => [user.id, user])) }
    ])

    render(<UserList />, { wrapper: Wrapper })

    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument()
      expect(screen.getByText('Jane Smith')).toBeInTheDocument()
    })
  })

  test('filters users based on search query', async () => {
    const Wrapper = createRecoilTestWrapper([
      { atom: usersState, value: new Map(mockUsers.map(user => [user.id, user])) }
    ])

    render(<UserList />, { wrapper: Wrapper })

    const searchInput = screen.getByPlaceholderText('Search users...')
    
    act(() => {
      fireEvent.change(searchInput, { target: { value: 'jane' } })
    })

    await waitFor(() => {
      expect(screen.getByText('Jane Smith')).toBeInTheDocument()
      expect(screen.queryByText('John Doe')).not.toBeInTheDocument()
    })
  })

  test('handles empty state correctly', async () => {
    const Wrapper = createRecoilTestWrapper([
      { atom: usersState, value: new Map() }
    ])

    render(<UserList />, { wrapper: Wrapper })

    await waitFor(() => {
      expect(screen.getByText('No users found')).toBeInTheDocument()
    })
  })
})

// ✅ Custom hooks testing
describe('useUserOperations', () => {
  beforeEach(() => {
    global.fetch = jest.fn()
  })

  afterEach(() => {
    jest.resetAllMocks()
  })

  test('createUser makes API call and updates state', async () => {
    const mockFetch = global.fetch as jest.MockedFunction<typeof fetch>
    const newUser = { ...mockUsers[0], id: '4', firstName: 'New', lastName: 'User' }
    
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => newUser,
    } as Response)

    const Wrapper = createRecoilTestWrapper()

    const { result } = renderHook(() => ({
      operations: useUserOperations(),
      users: useRecoilValue(usersState),
    }), { wrapper: Wrapper })

    await act(async () => {
      await result.current.operations.createUser({
        firstName: 'New',
        lastName: 'User',
        email: 'new@example.com',
        isActive: true,
        roles: ['user'],
      })
    })

    expect(mockFetch).toHaveBeenCalledWith('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        firstName: 'New',
        lastName: 'User',
        email: 'new@example.com',
        isActive: true,
        roles: ['user'],
      }),
    })

    expect(result.current.users.get('4')).toEqual(newUser)
  })
})

// ✅ Snapshot testing
describe('Recoil Snapshots', () => {
  test('can create and read from snapshots', () => {
    const snapshot = snapshot_UNSTABLE()
    
    snapshot.set(usersState, new Map(mockUsers.map(user => [user.id, user])))
    snapshot.set(userFiltersState, { ...userFiltersState.default, search: 'john' })

    const users = snapshot.getLoadable(usersState).contents
    const filteredUsers = snapshot.getLoadable(filteredUsersSelector).contents

    expect(users.size).toBe(3)
    expect(filteredUsers).toHaveLength(1)
    expect(filteredUsers[0].firstName).toBe('John')
  })
})
```

## Best Practices Summary

**Key patterns for enterprise Recoil applications:**

1. **Atomic Design**: Structure atoms as single sources of truth, use derived state via selectors, maintain clear atom dependencies.

2. **Performance**: Leverage Recoil's built-in memoization, avoid unnecessary re-renders with granular subscriptions, use atom families for dynamic state.

3. **Type Safety**: Define strict TypeScript interfaces, use typed selectors and atom families, implement runtime validation where needed.

4. **Error Handling**: Implement error boundaries with Recoil, handle async selector failures gracefully, provide fallback states.

5. **Testing**: Create reusable test wrappers, test atoms and selectors independently, use snapshot testing for complex state.

6. **Effects**: Use atom effects for side effects, implement persistent storage, track state changes for analytics.

7. **Architecture**: Organize atoms by domain, use selector composition for complex derived state, implement proper cleanup patterns.

8. **Debugging**: Leverage Recoil DevTools, implement performance monitoring, use descriptive atom keys for easier debugging.

Always prioritize predictable state updates, maintain clear separation of concerns, and leverage Recoil's reactive system for optimal performance and developer experience.
``` 