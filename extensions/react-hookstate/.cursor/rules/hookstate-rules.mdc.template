---
description: Advanced React Hookstate patterns for scalable state management, plugins, performance optimization, and enterprise-grade reactive state architecture.
globs: '**/*.{ts,tsx,js,jsx}'
---

# Advanced React Hookstate Management

## Enterprise Hookstate Architecture

**Scalable state management with Hookstate plugins and advanced patterns:**
```tsx
import React, { useCallback, useMemo, useRef, useEffect } from 'react'
import { 
  createState, 
  useHookstate, 
  State, 
  none, 
  downgraded,
  Plugin,
  PluginCallbacks,
  StateMethodsDestroy,
  Path
} from '@hookstate/core'
import { Persistence } from '@hookstate/persistence'
import { Validation } from '@hookstate/validation'
import { DevTools } from '@hookstate/devtools'
import { Touched } from '@hookstate/touched'
import { Initial } from '@hookstate/initial'

// ✅ Advanced user management state with comprehensive structure
interface User {
  id: string
  name: string
  email: string
  role: 'admin' | 'user' | 'guest'
  avatar?: string
  preferences: {
    theme: 'light' | 'dark' | 'system'
    notifications: {
      email: boolean
      push: boolean
      sms: boolean
    }
    language: string
    timezone: string
  }
  profile: {
    bio: string
    location: string
    website?: string
    socialLinks: {
      twitter?: string
      linkedin?: string
      github?: string
    }
  }
  metadata: {
    createdAt: Date
    lastLogin: Date | null
    loginCount: number
    isOnline: boolean
    subscription: {
      plan: 'free' | 'pro' | 'enterprise'
      expiresAt: Date | null
      features: string[]
    }
  }
}

interface UserState {
  currentUser: User | null
  users: Record<string, User>
  selectedUserIds: string[]
  filters: {
    role: string
    search: string
    online: boolean
    subscription: string
  }
  pagination: {
    page: number
    pageSize: number
    total: number
    hasNext: boolean
    hasPrev: boolean
  }
  ui: {
    loading: {
      users: boolean
      profile: boolean
      update: boolean
    }
    error: {
      users: string | null
      profile: string | null
      update: string | null
    }
    modals: {
      userProfile: boolean
      userSettings: boolean
      confirmDelete: boolean
    }
    sidebar: {
      collapsed: boolean
      activeSection: string
    }
  }
  cache: {
    lastFetch: Date | null
    etags: Record<string, string>
    invalidationKeys: string[]
  }
  realtime: {
    connected: boolean
    lastUpdate: Date | null
    pendingUpdates: Array<{
      id: string
      type: string
      data: any
      timestamp: Date
    }>
  }
}

// ✅ Advanced analytics plugin
class AnalyticsPlugin implements Plugin {
  private analyticsQueue: Array<{
    event: string
    properties: any
    timestamp: Date
  }> = []

  init(state: State<any>, options?: any): PluginCallbacks {
    return {
      onSet: ({ path, value, previous }) => {
        const eventName = this.getEventName(path)
        this.trackEvent(eventName, {
          path: path.join('.'),
          newValue: value,
          previousValue: previous,
          timestamp: new Date()
        })
      },
      
      onDestroy: () => {
        this.flushAnalytics()
      }
    }
  }

  private getEventName(path: Path): string {
    const pathStr = path.join('.')
    
    if (pathStr.includes('currentUser')) return 'user_state_changed'
    if (pathStr.includes('filters')) return 'filter_applied'
    if (pathStr.includes('ui.modals')) return 'modal_toggled'
    if (pathStr.includes('selectedUserIds')) return 'selection_changed'
    
    return 'state_updated'
  }

  private trackEvent(event: string, properties: any) {
    this.analyticsQueue.push({ event, properties, timestamp: new Date() })
    
    // Flush queue when it reaches 10 events or every 30 seconds
    if (this.analyticsQueue.length >= 10) {
      this.flushAnalytics()
    }
  }

  private flushAnalytics() {
    if (this.analyticsQueue.length === 0) return
    
    // Send to analytics service
    if (typeof window !== 'undefined' && window.gtag) {
      this.analyticsQueue.forEach(({ event, properties }) => {
        window.gtag('event', event, properties)
      })
    }
    
    this.analyticsQueue = []
  }
}

// ✅ Performance monitoring plugin
class PerformancePlugin implements Plugin {
  private renderCounts = new Map<string, number>()
  private updateTimes = new Map<string, number[]>()

  init(state: State<any>): PluginCallbacks {
    return {
      onSet: ({ path, value }) => {
        const pathStr = path.join('.')
        const now = performance.now()
        
        // Track update frequency
        if (!this.updateTimes.has(pathStr)) {
          this.updateTimes.set(pathStr, [])
        }
        this.updateTimes.get(pathStr)!.push(now)
        
        // Clean up old timestamps (keep last 100)
        const times = this.updateTimes.get(pathStr)!
        if (times.length > 100) {
          times.splice(0, times.length - 100)
        }
        
        // Log performance warnings
        if (times.length > 10) {
          const recentUpdates = times.slice(-10)
          const averageInterval = (recentUpdates[9] - recentUpdates[0]) / 9
          
          if (averageInterval < 16) { // More than 60fps updates
            console.warn(`High frequency updates detected for ${pathStr}: ${averageInterval.toFixed(2)}ms average interval`)
          }
        }
      }
    }
  }

  getStats() {
    const stats: Record<string, any> = {}
    
    for (const [path, times] of this.updateTimes.entries()) {
      if (times.length > 1) {
        const intervals = []
        for (let i = 1; i < times.length; i++) {
          intervals.push(times[i] - times[i - 1])
        }
        
        stats[path] = {
          updateCount: times.length,
          averageInterval: intervals.reduce((a, b) => a + b, 0) / intervals.length,
          minInterval: Math.min(...intervals),
          maxInterval: Math.max(...intervals)
        }
      }
    }
    
    return stats
  }
}

// ✅ Create global user state with plugins
const userState = createState<UserState>({
  currentUser: null,
  users: {},
  selectedUserIds: [],
  filters: {
    role: 'all',
    search: '',
    online: false,
    subscription: 'all'
  },
  pagination: {
    page: 1,
    pageSize: 20,
    total: 0,
    hasNext: false,
    hasPrev: false
  },
  ui: {
    loading: {
      users: false,
      profile: false,
      update: false
    },
    error: {
      users: null,
      profile: null,
      update: null
    },
    modals: {
      userProfile: false,
      userSettings: false,
      confirmDelete: false
    },
    sidebar: {
      collapsed: false,
      activeSection: 'users'
    }
  },
  cache: {
    lastFetch: null,
    etags: {},
    invalidationKeys: []
  },
  realtime: {
    connected: false,
    lastUpdate: null,
    pendingUpdates: []
  }
})

// ✅ Attach plugins to state
if (typeof window !== 'undefined') {
  userState.attach(DevTools)
}

userState.attach(Persistence('user-state'))
userState.attach(new AnalyticsPlugin())
userState.attach(new PerformancePlugin())
userState.attach(Validation)
userState.attach(Touched)
userState.attach(Initial)

// ✅ Advanced validation rules
const userValidationRules = {
  currentUser: {
    required: false,
    validator: (user: User | null) => {
      if (!user) return true
      
      const errors: string[] = []
      
      if (!user.email || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(user.email)) {
        errors.push('Valid email is required')
      }
      
      if (!user.name || user.name.trim().length < 2) {
        errors.push('Name must be at least 2 characters')
      }
      
      if (!['admin', 'user', 'guest'].includes(user.role)) {
        errors.push('Invalid role')
      }
      
      return errors.length === 0 ? true : errors.join(', ')
    }
  },
  
  filters: {
    search: {
      validator: (search: string) => {
        if (search.length > 100) {
          return 'Search query too long'
        }
        return true
      }
    }
  }
}

// Apply validation rules
userState.attach(Validation, userValidationRules)

// ✅ Advanced custom hooks for user management
export const useUserManagement = () => {
  const state = useHookstate(userState)
  
  // Memoized selectors
  const currentUser = useMemo(() => state.currentUser.get(), [state.currentUser])
  const loading = useMemo(() => state.ui.loading.get(), [state.ui.loading])
  const errors = useMemo(() => state.ui.error.get(), [state.ui.error])
  
  // Fetch users with caching and error handling
  const fetchUsers = useCallback(async (options?: {
    page?: number
    pageSize?: number
    filters?: Partial<UserState['filters']>
  }) => {
    const { page = 1, pageSize = 20, filters: filterOptions } = options || {}
    
    state.ui.loading.users.set(true)
    state.ui.error.users.set(null)
    
    try {
      // Build query parameters
      const params = new URLSearchParams({
        page: page.toString(),
        pageSize: pageSize.toString(),
        ...filterOptions
      })
      
      // Check cache
      const cacheKey = `users-${params.toString()}`
      const cachedEtag = state.cache.etags[cacheKey].get()
      
      const headers: HeadersInit = {
        'Content-Type': 'application/json'
      }
      
      if (cachedEtag) {
        headers['If-None-Match'] = cachedEtag
      }
      
      const response = await fetch(`/api/users?${params}`, { headers })
      
      if (response.status === 304) {
        // Not modified, use cache
        return
      }
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      const data = await response.json()
      const etag = response.headers.get('etag')
      
      // Update state atomically
      state.batch(() => {
        // Convert users array to record
        const usersRecord: Record<string, User> = {}
        data.users.forEach((user: User) => {
          usersRecord[user.id] = user
        })
        
        state.users.set(usersRecord)
        state.pagination.set({
          page: data.pagination.page,
          pageSize: data.pagination.pageSize,
          total: data.pagination.total,
          hasNext: data.pagination.hasNext,
          hasPrev: data.pagination.hasPrev
        })
        
        // Update cache
        state.cache.lastFetch.set(new Date())
        if (etag) {
          state.cache.etags[cacheKey].set(etag)
        }
      })
      
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to fetch users'
      state.ui.error.users.set(message)
      throw error
    } finally {
      state.ui.loading.users.set(false)
    }
  }, [state])
  
  // Optimistic user update with rollback
  const updateUser = useCallback(async (userId: string, updates: Partial<User>) => {
    const originalUser = state.users[userId].get()
    if (!originalUser) {
      throw new Error('User not found')
    }
    
    // Optimistic update
    const updatedUser = { ...originalUser, ...updates }
    state.users[userId].set(updatedUser)
    
    // Also update current user if it's the same
    if (state.currentUser.get()?.id === userId) {
      state.currentUser.set(updatedUser)
    }
    
    state.ui.loading.update.set(true)
    state.ui.error.update.set(null)
    
    try {
      const response = await fetch(`/api/users/${userId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      })
      
      if (!response.ok) {
        throw new Error('Failed to update user')
      }
      
      const serverUser: User = await response.json()
      
      // Update with server response
      state.batch(() => {
        state.users[userId].set(serverUser)
        if (state.currentUser.get()?.id === userId) {
          state.currentUser.set(serverUser)
        }
      })
      
      // Invalidate related cache
      state.cache.invalidationKeys.merge(['users', `user-${userId}`])
      
    } catch (error) {
      // Rollback optimistic update
      state.batch(() => {
        state.users[userId].set(originalUser)
        if (state.currentUser.get()?.id === userId) {
          state.currentUser.set(originalUser)
        }
      })
      
      const message = error instanceof Error ? error.message : 'Failed to update user'
      state.ui.error.update.set(message)
      throw error
    } finally {
      state.ui.loading.update.set(false)
    }
  }, [state])
  
  // Batch user operations
  const batchUpdateUsers = useCallback(async (operations: Array<{
    userId: string
    updates: Partial<User>
  }>) => {
    const originalUsers: Record<string, User> = {}
    
    // Store originals and apply optimistic updates
    state.batch(() => {
      operations.forEach(({ userId, updates }) => {
        const originalUser = state.users[userId].get()
        if (originalUser) {
          originalUsers[userId] = originalUser
          state.users[userId].merge(updates)
        }
      })
    })
    
    try {
      const response = await fetch('/api/users/batch', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ operations })
      })
      
      if (!response.ok) {
        throw new Error('Batch update failed')
      }
      
      const updatedUsers: User[] = await response.json()
      
      // Update with server response
      state.batch(() => {
        updatedUsers.forEach(user => {
          state.users[user.id].set(user)
          if (state.currentUser.get()?.id === user.id) {
            state.currentUser.set(user)
          }
        })
      })
      
    } catch (error) {
      // Rollback all optimistic updates
      state.batch(() => {
        Object.entries(originalUsers).forEach(([userId, originalUser]) => {
          state.users[userId].set(originalUser)
          if (state.currentUser.get()?.id === userId) {
            state.currentUser.set(originalUser)
          }
        })
      })
      throw error
    }
  }, [state])
  
  // Delete user with confirmation
  const deleteUser = useCallback(async (userId: string) => {
    const userToDelete = state.users[userId].get()
    if (!userToDelete) {
      throw new Error('User not found')
    }
    
    // Optimistic removal
    state.users[userId].set(none)
    state.selectedUserIds.set(current => current.filter(id => id !== userId))
    
    try {
      const response = await fetch(`/api/users/${userId}`, {
        method: 'DELETE'
      })
      
      if (!response.ok) {
        throw new Error('Failed to delete user')
      }
      
      // Update pagination
      state.pagination.total.set(current => current - 1)
      
    } catch (error) {
      // Rollback deletion
      state.users[userId].set(userToDelete)
      throw error
    }
  }, [state])
  
  return {
    currentUser,
    loading,
    errors,
    fetchUsers,
    updateUser,
    batchUpdateUsers,
    deleteUser
  }
}

// ✅ Advanced filtering and pagination hook
export const useUserFilters = () => {
  const state = useHookstate(userState)
  
  const filters = state.filters
  const pagination = state.pagination
  
  // Computed filtered users with performance optimization
  const filteredUsers = useMemo(() => {
    const users = Object.values(state.users.get())
    const currentFilters = filters.get()
    
    return users.filter(user => {
      // Role filter
      if (currentFilters.role !== 'all' && user.role !== currentFilters.role) {
        return false
      }
      
      // Search filter
      if (currentFilters.search) {
        const searchTerm = currentFilters.search.toLowerCase()
        const matchesName = user.name.toLowerCase().includes(searchTerm)
        const matchesEmail = user.email.toLowerCase().includes(searchTerm)
        const matchesBio = user.profile.bio.toLowerCase().includes(searchTerm)
        
        if (!matchesName && !matchesEmail && !matchesBio) {
          return false
        }
      }
      
      // Online filter
      if (currentFilters.online && !user.metadata.isOnline) {
        return false
      }
      
      // Subscription filter
      if (currentFilters.subscription !== 'all' && 
          user.metadata.subscription.plan !== currentFilters.subscription) {
        return false
      }
      
      return true
    })
  }, [state.users, filters])
  
  // Paginated users
  const paginatedUsers = useMemo(() => {
    const paginationState = pagination.get()
    const startIndex = (paginationState.page - 1) * paginationState.pageSize
    const endIndex = startIndex + paginationState.pageSize
    
    return filteredUsers.slice(startIndex, endIndex)
  }, [filteredUsers, pagination])
  
  // Update filters with debouncing
  const updateFilters = useCallback((newFilters: Partial<UserState['filters']>) => {
    state.batch(() => {
      filters.merge(newFilters)
      // Reset to first page when filters change
      pagination.page.set(1)
      pagination.total.set(filteredUsers.length)
      pagination.hasNext.set(filteredUsers.length > pagination.pageSize.get())
      pagination.hasPrev.set(false)
    })
  }, [state, filters, pagination, filteredUsers.length])
  
  // Pagination controls
  const goToPage = useCallback((page: number) => {
    const totalPages = Math.ceil(filteredUsers.length / pagination.pageSize.get())
    const validPage = Math.max(1, Math.min(page, totalPages))
    
    state.batch(() => {
      pagination.page.set(validPage)
      pagination.hasNext.set(validPage < totalPages)
      pagination.hasPrev.set(validPage > 1)
    })
  }, [state, pagination, filteredUsers.length])
  
  const nextPage = useCallback(() => {
    const currentPage = pagination.page.get()
    const totalPages = Math.ceil(filteredUsers.length / pagination.pageSize.get())
    
    if (currentPage < totalPages) {
      goToPage(currentPage + 1)
    }
  }, [pagination, goToPage, filteredUsers.length])
  
  const prevPage = useCallback(() => {
    const currentPage = pagination.page.get()
    
    if (currentPage > 1) {
      goToPage(currentPage - 1)
    }
  }, [pagination, goToPage])
  
  return {
    filters: filters.get(),
    pagination: pagination.get(),
    filteredUsers,
    paginatedUsers,
    updateFilters,
    goToPage,
    nextPage,
    prevPage,
    totalPages: Math.ceil(filteredUsers.length / pagination.pageSize.get())
  }
}

// ✅ User selection management hook
export const useUserSelection = () => {
  const state = useHookstate(userState)
  const selectedUserIds = state.selectedUserIds
  
  const selectedUsers = useMemo(() => {
    const userIds = selectedUserIds.get()
    const users = state.users.get()
    
    return userIds.map(id => users[id]).filter(Boolean)
  }, [selectedUserIds, state.users])
  
  const selectUser = useCallback((userId: string) => {
    const current = selectedUserIds.get()
    if (!current.includes(userId)) {
      selectedUserIds.set([...current, userId])
    }
  }, [selectedUserIds])
  
  const deselectUser = useCallback((userId: string) => {
    selectedUserIds.set(current => current.filter(id => id !== userId))
  }, [selectedUserIds])
  
  const toggleUserSelection = useCallback((userId: string) => {
    const current = selectedUserIds.get()
    if (current.includes(userId)) {
      deselectUser(userId)
    } else {
      selectUser(userId)
    }
  }, [selectedUserIds, selectUser, deselectUser])
  
  const selectAll = useCallback((userIds: string[]) => {
    selectedUserIds.set(userIds)
  }, [selectedUserIds])
  
  const clearSelection = useCallback(() => {
    selectedUserIds.set([])
  }, [selectedUserIds])
  
  const isSelected = useCallback((userId: string) => {
    return selectedUserIds.get().includes(userId)
  }, [selectedUserIds])
  
  return {
    selectedUsers,
    selectedUserIds: selectedUserIds.get(),
    selectUser,
    deselectUser,
    toggleUserSelection,
    selectAll,
    clearSelection,
    isSelected,
    selectionCount: selectedUserIds.get().length
  }
}

// ✅ Modal management hook with focus management
export const useUserModals = () => {
  const state = useHookstate(userState)
  const modals = state.ui.modals
  
  const openModal = useCallback((modalName: keyof UserState['ui']['modals']) => {
    modals[modalName].set(true)
    
    // Focus management
    requestAnimationFrame(() => {
      const modalElement = document.querySelector(`[data-modal="${modalName}"]`)
      if (modalElement) {
        const focusableElement = modalElement.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')
        if (focusableElement) {
          (focusableElement as HTMLElement).focus()
        }
      }
    })
  }, [modals])
  
  const closeModal = useCallback((modalName: keyof UserState['ui']['modals']) => {
    modals[modalName].set(false)
  }, [modals])
  
  const toggleModal = useCallback((modalName: keyof UserState['ui']['modals']) => {
    const isOpen = modals[modalName].get()
    if (isOpen) {
      closeModal(modalName)
    } else {
      openModal(modalName)
    }
  }, [modals, openModal, closeModal])
  
  // Keyboard event handler for modals
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        const openModals = Object.entries(modals.get()).filter(([_, isOpen]) => isOpen)
        if (openModals.length > 0) {
          const lastOpenModal = openModals[openModals.length - 1][0] as keyof UserState['ui']['modals']
          closeModal(lastOpenModal)
        }
      }
    }
    
    document.addEventListener('keydown', handleKeyDown)
    return () => document.removeEventListener('keydown', handleKeyDown)
  }, [modals, closeModal])
  
  return {
    modals: modals.get(),
    openModal,
    closeModal,
    toggleModal,
    isOpen: (modalName: keyof UserState['ui']['modals']) => modals[modalName].get()
  }
}

// ✅ Real-time synchronization hook
export const useRealtimeSync = () => {
  const state = useHookstate(userState)
  const wsRef = useRef<WebSocket | null>(null)
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>()
  const heartbeatIntervalRef = useRef<NodeJS.Timeout>()
  
  const connect = useCallback(() => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      return
    }
    
    const ws = new WebSocket(process.env.REACT_APP_WS_URL || 'ws://localhost:3001')
    wsRef.current = ws
    
    ws.onopen = () => {
      console.log('WebSocket connected')
      state.realtime.connected.set(true)
      
      // Start heartbeat
      heartbeatIntervalRef.current = setInterval(() => {
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'heartbeat', timestamp: Date.now() }))
        }
      }, 30000)
    }
    
    ws.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data)
        state.realtime.lastUpdate.set(new Date())
        
        switch (message.type) {
          case 'user_updated':
            if (message.user) {
              state.users[message.user.id].merge(message.user)
              
              // Update current user if it matches
              if (state.currentUser.get()?.id === message.user.id) {
                state.currentUser.merge(message.user)
              }
            }
            break
            
          case 'user_added':
            if (message.user) {
              state.users[message.user.id].set(message.user)
            }
            break
            
          case 'user_deleted':
            if (message.userId) {
              state.users[message.userId].set(none)
              state.selectedUserIds.set(current => 
                current.filter(id => id !== message.userId)
              )
            }
            break
            
          case 'user_status_changed':
            if (message.userId && typeof message.isOnline === 'boolean') {
              state.users[message.userId].metadata.isOnline.set(message.isOnline)
              
              if (state.currentUser.get()?.id === message.userId) {
                state.currentUser.metadata.isOnline.set(message.isOnline)
              }
            }
            break
            
          case 'heartbeat_response':
            // Connection is alive
            break
        }
      } catch (error) {
        console.error('Failed to process WebSocket message:', error)
      }
    }
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error)
    }
    
    ws.onclose = () => {
      console.log('WebSocket disconnected')
      state.realtime.connected.set(false)
      
      // Clear heartbeat
      if (heartbeatIntervalRef.current) {
        clearInterval(heartbeatIntervalRef.current)
      }
      
      // Attempt to reconnect after 3 seconds
      reconnectTimeoutRef.current = setTimeout(() => {
        connect()
      }, 3000)
    }
  }, [state])
  
  const disconnect = useCallback(() => {
    if (wsRef.current) {
      wsRef.current.close()
      wsRef.current = null
    }
    
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current)
    }
    
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current)
    }
    
    state.realtime.connected.set(false)
  }, [state])
  
  const sendMessage = useCallback((message: any) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(message))
    } else {
      console.warn('WebSocket not connected, queueing message')
      state.realtime.pendingUpdates.merge([{
        id: Date.now().toString(),
        type: message.type,
        data: message,
        timestamp: new Date()
      }])
    }
  }, [state])
  
  // Auto-connect on mount
  useEffect(() => {
    connect()
    return () => {
      disconnect()
    }
  }, [connect, disconnect])
  
  return {
    isConnected: state.realtime.connected.get(),
    lastUpdate: state.realtime.lastUpdate.get(),
    pendingUpdates: state.realtime.pendingUpdates.get(),
    connect,
    disconnect,
    sendMessage
  }
}

// ✅ Performance monitoring hook
export const useStatePerformance = () => {
  const renderCountRef = useRef(0)
  const lastRenderTimeRef = useRef(Date.now())
  const [performanceData, setPerformanceData] = React.useState<any>({})
  
  useEffect(() => {
    renderCountRef.current += 1
    const now = Date.now()
    const timeSinceLastRender = now - lastRenderTimeRef.current
    lastRenderTimeRef.current = now
    
    // Update performance data every 50 renders
    if (renderCountRef.current % 50 === 0) {
      const plugin = userState.ornull()?.plugins?.find(p => p instanceof PerformancePlugin) as PerformancePlugin
      
      if (plugin) {
        setPerformanceData({
          renderCount: renderCountRef.current,
          averageRenderInterval: timeSinceLastRender,
          stateStats: plugin.getStats(),
          timestamp: now
        })
      }
    }
  })
  
  const resetCounters = useCallback(() => {
    renderCountRef.current = 0
    setPerformanceData({})
  }, [])
  
  return {
    performanceData,
    renderCount: renderCountRef.current,
    resetCounters
  }
}

// ✅ Advanced user list component
export const UserList: React.FC = () => {
  const { fetchUsers, loading, errors } = useUserManagement()
  const { 
    paginatedUsers, 
    filters, 
    pagination, 
    updateFilters, 
    nextPage, 
    prevPage, 
    totalPages 
  } = useUserFilters()
  const { selectedUserIds, toggleUserSelection, selectAll, clearSelection } = useUserSelection()
  const { isConnected } = useRealtimeSync()
  
  // Initial fetch
  useEffect(() => {
    fetchUsers()
  }, [fetchUsers])
  
  // Debounced search
  const searchTimeoutRef = useRef<NodeJS.Timeout>()
  const handleSearchChange = useCallback((search: string) => {
    if (searchTimeoutRef.current) {
      clearTimeout(searchTimeoutRef.current)
    }
    
    searchTimeoutRef.current = setTimeout(() => {
      updateFilters({ search })
    }, 300)
  }, [updateFilters])
  
  if (loading.users) {
    return (
      <div className="loading-container">
        <div className="loading-spinner" />
        <p>Loading users...</p>
      </div>
    )
  }
  
  if (errors.users) {
    return (
      <div className="error-container">
        <p>Error: {errors.users}</p>
        <button onClick={() => fetchUsers()}>Retry</button>
      </div>
    )
  }
  
  return (
    <div className="user-list">
      {/* Connection Status */}
      <div className={`connection-status ${isConnected ? 'connected' : 'disconnected'}`}>
        {isConnected ? '🟢 Connected' : '🔴 Disconnected'}
      </div>
      
      {/* Filters */}
      <div className="user-filters">
        <input
          type="text"
          placeholder="Search users..."
          defaultValue={filters.search}
          onChange={(e) => handleSearchChange(e.target.value)}
          className="search-input"
        />
        
        <select
          value={filters.role}
          onChange={(e) => updateFilters({ role: e.target.value })}
          className="filter-select"
        >
          <option value="all">All Roles</option>
          <option value="admin">Admin</option>
          <option value="user">User</option>
          <option value="guest">Guest</option>
        </select>
        
        <select
          value={filters.subscription}
          onChange={(e) => updateFilters({ subscription: e.target.value })}
          className="filter-select"
        >
          <option value="all">All Plans</option>
          <option value="free">Free</option>
          <option value="pro">Pro</option>
          <option value="enterprise">Enterprise</option>
        </select>
        
        <label className="filter-checkbox">
          <input
            type="checkbox"
            checked={filters.online}
            onChange={(e) => updateFilters({ online: e.target.checked })}
          />
          Online only
        </label>
      </div>
      
      {/* Selection Controls */}
      {paginatedUsers.length > 0 && (
        <div className="selection-controls">
          <span className="selection-info">
            {paginatedUsers.length} users shown, {selectedUserIds.length} selected
          </span>
          
          <div className="selection-actions">
            <button 
              onClick={() => selectAll(paginatedUsers.map(u => u.id))}
              className="btn btn-sm"
            >
              Select Page
            </button>
            <button 
              onClick={clearSelection}
              className="btn btn-sm"
              disabled={selectedUserIds.length === 0}
            >
              Clear Selection
            </button>
          </div>
        </div>
      )}
      
      {/* User Grid */}
      <div className="user-grid">
        {paginatedUsers.map(user => (
          <UserCard
            key={user.id}
            user={user}
            isSelected={selectedUserIds.includes(user.id)}
            onToggleSelection={() => toggleUserSelection(user.id)}
          />
        ))}
      </div>
      
      {/* Pagination */}
      {totalPages > 1 && (
        <div className="pagination">
          <button
            onClick={prevPage}
            disabled={!pagination.hasPrev}
            className="pagination-btn"
          >
            ← Previous
          </button>
          
          <div className="pagination-info">
            Page {pagination.page} of {totalPages}
          </div>
          
          <button
            onClick={nextPage}
            disabled={!pagination.hasNext}
            className="pagination-btn"
          >
            Next →
          </button>
        </div>
      )}
    </div>
  )
}

// ✅ Memoized user card component
export const UserCard: React.FC<{
  user: User
  isSelected: boolean
  onToggleSelection: () => void
}> = React.memo(({ user, isSelected, onToggleSelection }) => {
  const { updateUser } = useUserManagement()
  const { openModal } = useUserModals()
  const [localLoading, setLocalLoading] = React.useState(false)
  
  const handleStatusToggle = useCallback(async () => {
    setLocalLoading(true)
    try {
      await updateUser(user.id, {
        metadata: {
          ...user.metadata,
          isOnline: !user.metadata.isOnline
        }
      })
    } catch (error) {
      console.error('Failed to update user status:', error)
    } finally {
      setLocalLoading(false)
    }
  }, [user, updateUser])
  
  return (
    <div className={`user-card ${isSelected ? 'selected' : ''} ${localLoading ? 'loading' : ''}`}>
      <div className="user-card-header">
        <input
          type="checkbox"
          checked={isSelected}
          onChange={onToggleSelection}
          className="selection-checkbox"
        />
        
        <div className="user-avatar-container">
          <img
            src={user.avatar || '/default-avatar.png'}
            alt={`${user.name} avatar`}
            className="user-avatar"
            loading="lazy"
          />
          <div className={`status-indicator ${user.metadata.isOnline ? 'online' : 'offline'}`} />
        </div>
        
        <div className={`subscription-badge ${user.metadata.subscription.plan}`}>
          {user.metadata.subscription.plan}
        </div>
      </div>
      
      <div className="user-card-body">
        <h4 className="user-name">{user.name}</h4>
        <p className="user-email">{user.email}</p>
        <span className={`role-badge role-${user.role}`}>
          {user.role}
        </span>
        
        {user.profile.bio && (
          <p className="user-bio">{user.profile.bio}</p>
        )}
        
        {user.profile.location && (
          <p className="user-location">📍 {user.profile.location}</p>
        )}
      </div>
      
      <div className="user-card-actions">
        <button 
          onClick={() => openModal('userProfile')}
          className="btn btn-sm btn-primary"
        >
          View Profile
        </button>
        
        <button 
          onClick={handleStatusToggle}
          disabled={localLoading}
          className="btn btn-sm btn-secondary"
        >
          {localLoading ? '...' : (user.metadata.isOnline ? 'Set Offline' : 'Set Online')}
        </button>
      </div>
      
      <div className="user-metadata">
        <small className="metadata-item">
          Last login: {user.metadata.lastLogin 
            ? new Date(user.metadata.lastLogin).toLocaleDateString()
            : 'Never'
          }
        </small>
        <small className="metadata-item">
          Logins: {user.metadata.loginCount}
        </small>
        <small className="metadata-item">
          Member since: {new Date(user.metadata.createdAt).toLocaleDateString()}
        </small>
      </div>
    </div>
  )
})
```

## Best Practices Summary

**Key patterns for advanced Hookstate management:**

1. **Plugin Architecture**: Leverage Hookstate plugins for cross-cutting concerns like persistence, validation, analytics, and performance monitoring.

2. **Type Safety**: Use comprehensive TypeScript interfaces, implement proper validation rules, leverage plugin type definitions.

3. **Performance**: Use selective subscriptions, implement proper memoization, leverage downgraded() for performance-critical paths, monitor render counts.

4. **State Organization**: Structure complex state hierarchically, use proper state splitting, implement domain-driven state boundaries.

5. **Real-time Integration**: Implement WebSocket synchronization, handle optimistic updates with rollback, manage connection state properly.

6. **Developer Experience**: Integrate with Redux DevTools, implement comprehensive logging, provide debugging utilities, use proper error boundaries.

7. **Testing**: Test state logic in isolation, mock plugins appropriately, test real-time synchronization, validate persistence mechanisms.

8. **Scalability**: Design for large applications, implement proper cleanup patterns, use efficient data structures, optimize for concurrent users.

Always prioritize type safety, leverage Hookstate's plugin ecosystem, implement proper performance monitoring, and maintain clear separation of concerns for enterprise-grade state management. 