---
description: Advanced internationalization patterns with react-i18next, type-safe translations, pluralization, namespace management, and enterprise-scale localization architecture.
globs: '**/*.{ts,tsx,js,jsx}, **/locales/**/*.json'
---

# Advanced React i18n Patterns

## Enterprise Translation Architecture

**Type-safe i18n setup with advanced configuration:**
```tsx
import i18n from 'i18next'
import { initReactI18next, useTranslation, Trans, withTranslation } from 'react-i18next'
import Backend from 'i18next-http-backend'
import LanguageDetector from 'i18next-browser-languagedetector'
import ChainedBackend from 'i18next-chained-backend'
import LocalStorageBackend from 'i18next-localstorage-backend'
import { z } from 'zod'

// âœ… Type-safe translation key definitions
export interface TranslationResources {
  common: {
    buttons: {
      save: string
      cancel: string
      delete: string
      edit: string
      submit: string
      loading: string
      retry: string
    }
    validation: {
      required: string
      email: string
      minLength: string
      maxLength: string
      pattern: string
    }
    messages: {
      success: string
      error: string
      warning: string
      info: string
      notFound: string
      unauthorized: string
    }
    navigation: {
      home: string
      dashboard: string
      profile: string
      settings: string
      logout: string
    }
  }
  auth: {
    login: {
      title: string
      subtitle: string
      email: string
      password: string
      forgotPassword: string
      signUp: string
      socialLogin: string
    }
    register: {
      title: string
      firstName: string
      lastName: string
      confirmPassword: string
      terms: string
      privacy: string
    }
    errors: {
      invalidCredentials: string
      accountLocked: string
      emailNotVerified: string
      passwordTooWeak: string
      userExists: string
    }
  }
  dashboard: {
    widgets: {
      users: {
        title: string
        total: string
        active: string
        new: string
      }
      analytics: {
        title: string
        pageViews: string
        sessions: string
        bounceRate: string
      }
      sales: {
        title: string
        revenue: string
        orders: string
        conversion: string
      }
    }
    charts: {
      userGrowth: string
      revenueChart: string
      trafficSources: string
    }
  }
  forms: {
    user: {
      personalInfo: string
      firstName: string
      lastName: string
      email: string
      phone: string
      avatar: string
      dateOfBirth: string
      gender: string
      address: {
        street: string
        city: string
        state: string
        zipCode: string
        country: string
      }
    }
    validation: {
      fieldRequired: string
      invalidEmail: string
      passwordMismatch: string
      phoneInvalid: string
      dateInvalid: string
    }
  }
}

// âœ… Advanced i18n configuration with multiple backends
const i18nConfig = {
  debug: process.env.NODE_ENV === 'development',
  
  lng: 'en', // Default language
  fallbackLng: ['en', 'es', 'fr'], // Fallback chain
  
  // Language detection
  detection: {
    order: ['localStorage', 'navigator', 'htmlTag'],
    lookupLocalStorage: 'i18nextLng',
    caches: ['localStorage'],
    checkWhitelist: true,
  },
  
  // Interpolation options
  interpolation: {
    escapeValue: false, // React already escapes
    formatSeparator: ',',
    format: (value: any, format: string, lng?: string) => {
      if (format === 'uppercase') return value.toUpperCase()
      if (format === 'lowercase') return value.toLowerCase()
      if (format === 'currency') {
        return new Intl.NumberFormat(lng, {
          style: 'currency',
          currency: 'USD',
        }).format(value)
      }
      if (format === 'date') {
        return new Intl.DateTimeFormat(lng).format(new Date(value))
      }
      if (format === 'dateTime') {
        return new Intl.DateTimeFormat(lng, {
          dateStyle: 'medium',
          timeStyle: 'short',
        }).format(new Date(value))
      }
      if (format === 'number') {
        return new Intl.NumberFormat(lng).format(value)
      }
      if (format === 'percent') {
        return new Intl.NumberFormat(lng, {
          style: 'percent',
          maximumFractionDigits: 2,
        }).format(value / 100)
      }
      return value
    },
  },
  
  // Namespace configuration
  ns: ['common', 'auth', 'dashboard', 'forms'],
  defaultNS: 'common',
  
  // Backend configuration with chained backends
  backend: {
    backends: [
      LocalStorageBackend, // Primary: localStorage for offline support
      Backend, // Secondary: HTTP backend for fresh translations
    ],
    backendOptions: [
      {
        expirationTime: 7 * 24 * 60 * 60 * 1000, // 7 days
        versions: { en: 'v1.0', es: 'v1.0', fr: 'v1.0' },
      },
      {
        loadPath: '/locales/{{lng}}/{{ns}}.json',
        addPath: '/locales/add/{{lng}}/{{ns}}',
        allowMultiLoading: false,
        crossDomain: false,
        withCredentials: false,
        requestOptions: {
          mode: 'cors',
          credentials: 'same-origin',
          cache: 'default',
        },
        // Custom request headers
        customHeaders: {
          'Content-Type': 'application/json',
        },
      },
    ],
  },
  
  // React specific options
  react: {
    bindI18n: 'languageChanged',
    bindI18nStore: false,
    transEmptyNodeValue: '',
    transSupportBasicHtmlNodes: true,
    transKeepBasicHtmlNodesFor: ['br', 'strong', 'i', 'em', 'u', 'code', 'span'],
    useSuspense: false,
  },
  
  // Advanced features
  saveMissing: process.env.NODE_ENV === 'development',
  updateMissing: process.env.NODE_ENV === 'development',
  missingKeyHandler: (lng: string[], ns: string, key: string) => {
    if (process.env.NODE_ENV === 'development') {
      console.warn(`Missing translation key: ${ns}:${key} for language: ${lng.join(', ')}`)
    }
  },
  
  // Plural forms
  pluralSeparator: '_',
  contextSeparator: '_',
  
  // Key separator
  keySeparator: '.',
  nsSeparator: ':',
}

// âœ… Initialize i18n with advanced configuration
i18n
  .use(ChainedBackend)
  .use(LanguageDetector)
  .use(initReactI18next)
  .init(i18nConfig)

export default i18n

// âœ… Type-safe translation hooks
declare module 'react-i18next' {
  interface CustomTypeOptions {
    defaultNS: 'common'
    resources: TranslationResources
  }
}

export type TFunction = (key: keyof TranslationResources[keyof TranslationResources], options?: any) => string

// âœ… Enhanced translation hooks with type safety
export const useTypedTranslation = <T extends keyof TranslationResources>(
  ns?: T
) => {
  const { t, i18n, ready } = useTranslation(ns as string)
  
  return {
    t: t as TFunction,
    i18n,
    ready,
    changeLanguage: i18n.changeLanguage,
    language: i18n.language,
    languages: i18n.languages,
  }
}

// âœ… Context-aware translation hook
export const useContextualTranslation = (context: string) => {
  const { t, i18n } = useTranslation()
  
  const contextualT = (key: string, options?: any) => {
    const contextKey = `${context}.${key}`
    return t(contextKey, { ...options, defaultValue: t(key, options) })
  }
  
  return { t: contextualT, i18n }
}

// âœ… Language management utilities
export class LanguageManager {
  private static instance: LanguageManager
  private supportedLanguages = ['en', 'es', 'fr', 'de', 'it', 'pt', 'ru', 'zh', 'ja', 'ko']
  private rtlLanguages = ['ar', 'he', 'fa', 'ur']
  
  static getInstance(): LanguageManager {
    if (!LanguageManager.instance) {
      LanguageManager.instance = new LanguageManager()
    }
    return LanguageManager.instance
  }
  
  isSupported(language: string): boolean {
    return this.supportedLanguages.includes(language.split('-')[0])
  }
  
  isRTL(language: string): boolean {
    return this.rtlLanguages.includes(language.split('-')[0])
  }
  
  getLanguageInfo(language: string) {
    const lang = language.split('-')[0]
    const region = language.split('-')[1]
    
    return {
      code: lang,
      region,
      isRTL: this.isRTL(language),
      isSupported: this.isSupported(language),
      nativeName: this.getNativeName(lang),
      flag: this.getFlagEmoji(lang),
    }
  }
  
  private getNativeName(language: string): string {
    const names: Record<string, string> = {
      en: 'English',
      es: 'EspaÃ±ol',
      fr: 'FranÃ§ais',
      de: 'Deutsch',
      it: 'Italiano',
      pt: 'PortuguÃªs',
      ru: 'Ğ ÑƒÑÑĞºĞ¸Ğ¹',
      zh: 'ä¸­æ–‡',
      ja: 'æ—¥æœ¬èª',
      ko: 'í•œêµ­ì–´',
      ar: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
      he: '×¢×‘×¨×™×ª',
    }
    return names[language] || language
  }
  
  private getFlagEmoji(language: string): string {
    const flags: Record<string, string> = {
      en: 'ğŸ‡ºğŸ‡¸',
      es: 'ğŸ‡ªğŸ‡¸',
      fr: 'ğŸ‡«ğŸ‡·',
      de: 'ğŸ‡©ğŸ‡ª',
      it: 'ğŸ‡®ğŸ‡¹',
      pt: 'ğŸ‡µğŸ‡¹',
      ru: 'ğŸ‡·ğŸ‡º',
      zh: 'ğŸ‡¨ğŸ‡³',
      ja: 'ğŸ‡¯ğŸ‡µ',
      ko: 'ğŸ‡°ğŸ‡·',
      ar: 'ğŸ‡¸ğŸ‡¦',
      he: 'ğŸ‡®ğŸ‡±',
    }
    return flags[language] || 'ğŸŒ'
  }
  
  async changeLanguage(language: string): Promise<void> {
    if (!this.isSupported(language)) {
      console.warn(`Language ${language} is not supported`)
      return
    }
    
    try {
      await i18n.changeLanguage(language)
      
      // Update document direction for RTL languages
      document.documentElement.dir = this.isRTL(language) ? 'rtl' : 'ltr'
      document.documentElement.lang = language
      
      // Store preference
      localStorage.setItem('i18nextLng', language)
      
      // Trigger custom event for other components
      window.dispatchEvent(new CustomEvent('languageChanged', {
        detail: { language, languageInfo: this.getLanguageInfo(language) }
      }))
      
    } catch (error) {
      console.error('Failed to change language:', error)
    }
  }
  
  getAvailableLanguages() {
    return this.supportedLanguages.map(lang => ({
      code: lang,
      ...this.getLanguageInfo(lang),
    }))
  }
}

export const languageManager = LanguageManager.getInstance()
```

## Advanced Translation Components

**Sophisticated translation patterns with pluralization and formatting:**
```tsx
import React, { Suspense, useCallback, useEffect, useMemo, useState } from 'react'
import { Trans, useTranslation } from 'react-i18next'

// âœ… Advanced translation component with pluralization
interface TranslatedTextProps {
  i18nKey: string
  count?: number
  values?: Record<string, any>
  components?: Record<string, React.ReactElement>
  fallback?: string
  namespace?: string
  className?: string
  renderEmpty?: () => React.ReactNode
}

export const TranslatedText: React.FC<TranslatedTextProps> = ({
  i18nKey,
  count,
  values = {},
  components = {},
  fallback,
  namespace,
  className,
  renderEmpty,
}) => {
  const { t, ready } = useTranslation(namespace)
  
  if (!ready) {
    return <span className="translation-loading">...</span>
  }
  
  const translation = t(i18nKey, { count, ...values, defaultValue: fallback })
  
  if (!translation && renderEmpty) {
    return <>{renderEmpty()}</>
  }
  
  // Use Trans component if components are provided for rich text
  if (Object.keys(components).length > 0) {
    return (
      <Trans
        i18nKey={i18nKey}
        count={count}
        values={values}
        components={components}
        ns={namespace}
        className={className}
      />
    )
  }
  
  return <span className={className}>{translation}</span>
}

// âœ… Smart pluralization component
interface PluralTextProps {
  count: number
  i18nKey: string
  values?: Record<string, any>
  showCount?: boolean
  formatCount?: (count: number) => string
  namespace?: string
}

export const PluralText: React.FC<PluralTextProps> = ({
  count,
  i18nKey,
  values = {},
  showCount = true,
  formatCount,
  namespace,
}) => {
  const { t, i18n } = useTranslation(namespace)
  
  const formattedCount = useMemo(() => {
    if (formatCount) {
      return formatCount(count)
    }
    return new Intl.NumberFormat(i18n.language).format(count)
  }, [count, formatCount, i18n.language])
  
  const translation = t(i18nKey, { 
    count,
    ...values,
    formattedCount,
  })
  
  return (
    <span>
      {showCount && <span className="count">{formattedCount} </span>}
      {translation}
    </span>
  )
}

// âœ… Formatted number component with i18n
interface FormattedNumberProps {
  value: number
  style?: 'decimal' | 'currency' | 'percent'
  currency?: string
  minimumFractionDigits?: number
  maximumFractionDigits?: number
  className?: string
}

export const FormattedNumber: React.FC<FormattedNumberProps> = ({
  value,
  style = 'decimal',
  currency = 'USD',
  minimumFractionDigits,
  maximumFractionDigits,
  className,
}) => {
  const { i18n } = useTranslation()
  
  const formatted = useMemo(() => {
    const options: Intl.NumberFormatOptions = {
      style,
      minimumFractionDigits,
      maximumFractionDigits,
    }
    
    if (style === 'currency') {
      options.currency = currency
    }
    
    return new Intl.NumberFormat(i18n.language, options).format(value)
  }, [value, style, currency, minimumFractionDigits, maximumFractionDigits, i18n.language])
  
  return <span className={className}>{formatted}</span>
}

// âœ… Formatted date component with i18n
interface FormattedDateProps {
  date: Date | string | number
  dateStyle?: 'full' | 'long' | 'medium' | 'short'
  timeStyle?: 'full' | 'long' | 'medium' | 'short'
  relative?: boolean
  className?: string
}

export const FormattedDate: React.FC<FormattedDateProps> = ({
  date,
  dateStyle = 'medium',
  timeStyle,
  relative = false,
  className,
}) => {
  const { i18n } = useTranslation()
  
  const formatted = useMemo(() => {
    const dateObj = new Date(date)
    
    if (relative) {
      const rtf = new Intl.RelativeTimeFormat(i18n.language, { numeric: 'auto' })
      const diff = dateObj.getTime() - Date.now()
      const days = Math.round(diff / (1000 * 60 * 60 * 24))
      
      if (Math.abs(days) < 7) {
        return rtf.format(days, 'day')
      }
      if (Math.abs(days) < 30) {
        const weeks = Math.round(days / 7)
        return rtf.format(weeks, 'week')
      }
      if (Math.abs(days) < 365) {
        const months = Math.round(days / 30)
        return rtf.format(months, 'month')
      }
      const years = Math.round(days / 365)
      return rtf.format(years, 'year')
    }
    
    const options: Intl.DateTimeFormatOptions = {
      dateStyle,
      timeStyle,
    }
    
    return new Intl.DateTimeFormat(i18n.language, options).format(dateObj)
  }, [date, dateStyle, timeStyle, relative, i18n.language])
  
  return <span className={className}>{formatted}</span>
}

// âœ… Language switcher component
interface LanguageSwitcherProps {
  variant?: 'dropdown' | 'buttons' | 'flags'
  showFlags?: boolean
  showNativeNames?: boolean
  className?: string
  onLanguageChange?: (language: string) => void
}

export const LanguageSwitcher: React.FC<LanguageSwitcherProps> = ({
  variant = 'dropdown',
  showFlags = true,
  showNativeNames = true,
  className,
  onLanguageChange,
}) => {
  const { i18n } = useTranslation()
  const [isLoading, setIsLoading] = useState(false)
  
  const availableLanguages = languageManager.getAvailableLanguages()
  
  const handleLanguageChange = useCallback(async (language: string) => {
    if (language === i18n.language) return
    
    setIsLoading(true)
    try {
      await languageManager.changeLanguage(language)
      onLanguageChange?.(language)
    } catch (error) {
      console.error('Language change failed:', error)
    } finally {
      setIsLoading(false)
    }
  }, [i18n.language, onLanguageChange])
  
  if (variant === 'dropdown') {
    return (
      <div className={`language-switcher ${className || ''}`}>
        <select
          value={i18n.language}
          onChange={(e) => handleLanguageChange(e.target.value)}
          disabled={isLoading}
          className="language-select"
        >
          {availableLanguages.map(lang => (
            <option key={lang.code} value={lang.code}>
              {showFlags && lang.flag} {showNativeNames ? lang.nativeName : lang.code.toUpperCase()}
            </option>
          ))}
        </select>
        {isLoading && <span className="loading-indicator">âŸ³</span>}
      </div>
    )
  }
  
  if (variant === 'buttons') {
    return (
      <div className={`language-buttons ${className || ''}`}>
        {availableLanguages.map(lang => (
          <button
            key={lang.code}
            onClick={() => handleLanguageChange(lang.code)}
            disabled={isLoading}
            className={`language-btn ${i18n.language === lang.code ? 'active' : ''}`}
          >
            {showFlags && lang.flag} {showNativeNames ? lang.nativeName : lang.code.toUpperCase()}
          </button>
        ))}
        {isLoading && <span className="loading-indicator">âŸ³</span>}
      </div>
    )
  }
  
  if (variant === 'flags') {
    return (
      <div className={`language-flags ${className || ''}`}>
        {availableLanguages.map(lang => (
          <button
            key={lang.code}
            onClick={() => handleLanguageChange(lang.code)}
            disabled={isLoading}
            className={`flag-btn ${i18n.language === lang.code ? 'active' : ''}`}
            title={lang.nativeName}
          >
            {lang.flag}
          </button>
        ))}
        {isLoading && <span className="loading-indicator">âŸ³</span>}
      </div>
    )
  }
  
  return null
}

// âœ… Translation provider with error boundary
interface TranslationProviderProps {
  children: React.ReactNode
  fallback?: React.ReactNode
  onError?: (error: Error) => void
}

export class TranslationProvider extends React.Component<
  TranslationProviderProps,
  { hasError: boolean; error?: Error }
> {
  constructor(props: TranslationProviderProps) {
    super(props)
    this.state = { hasError: false }
  }
  
  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error }
  }
  
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Translation error:', error, errorInfo)
    this.props.onError?.(error)
  }
  
  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="translation-error">
          <h3>Translation Error</h3>
          <p>Failed to load translations. Please refresh the page.</p>
          <button onClick={() => window.location.reload()}>
            Refresh
          </button>
        </div>
      )
    }
    
    return (
      <Suspense fallback={<div className="translation-loading">Loading translations...</div>}>
        {this.props.children}
      </Suspense>
    )
  }
}

// âœ… Form validation with i18n
export const useTranslatedValidation = () => {
  const { t } = useTranslation('forms')
  
  return {
    required: (field: string) => t('validation.fieldRequired', { field }),
    email: () => t('validation.invalidEmail'),
    minLength: (min: number) => t('validation.minLength', { min }),
    maxLength: (max: number) => t('validation.maxLength', { max }),
    pattern: (pattern: string) => t('validation.pattern', { pattern }),
    passwordMismatch: () => t('validation.passwordMismatch'),
    phoneInvalid: () => t('validation.phoneInvalid'),
    dateInvalid: () => t('validation.dateInvalid'),
  }
}

// âœ… Rich text translation with markdown support
interface RichTranslationProps {
  i18nKey: string
  values?: Record<string, any>
  namespace?: string
  markdown?: boolean
  allowedTags?: string[]
}

export const RichTranslation: React.FC<RichTranslationProps> = ({
  i18nKey,
  values = {},
  namespace,
  markdown = false,
  allowedTags = ['strong', 'em', 'u', 'br', 'a', 'code'],
}) => {
  const { t } = useTranslation(namespace)
  
  const components = useMemo(() => {
    const comps: Record<string, React.ReactElement> = {}
    
    allowedTags.forEach(tag => {
      switch (tag) {
        case 'strong':
          comps.strong = <strong />
          comps.b = <strong />
          break
        case 'em':
          comps.em = <em />
          comps.i = <em />
          break
        case 'u':
          comps.u = <u />
          break
        case 'br':
          comps.br = <br />
          break
        case 'a':
          comps.a = <a href="#" />
          break
        case 'code':
          comps.code = <code />
          break
        default:
          comps[tag] = React.createElement(tag)
      }
    })
    
    return comps
  }, [allowedTags])
  
  if (markdown) {
    const translation = t(i18nKey, values)
    // Simple markdown to HTML conversion
    const htmlContent = translation
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
      .replace(/`(.*?)`/g, '<code>$1</code>')
      .replace(/\n/g, '<br />')
    
    return (
      <span 
        dangerouslySetInnerHTML={{ __html: htmlContent }}
      />
    )
  }
  
  return (
    <Trans
      i18nKey={i18nKey}
      values={values}
      components={components}
      ns={namespace}
    />
  )
}
```

## Translation Management System

**Advanced translation workflow with automation and validation:**
```tsx
import { z } from 'zod'

// âœ… Translation validation schemas
const TranslationValueSchema = z.string().min(1, 'Translation cannot be empty')

const TranslationFileSchema = z.record(
  z.string(),
  z.union([z.string(), z.record(z.string(), z.unknown())])
)

// âœ… Translation manager for runtime operations
export class TranslationManager {
  private static instance: TranslationManager
  private cache = new Map<string, any>()
  private loadingPromises = new Map<string, Promise<any>>()
  
  static getInstance(): TranslationManager {
    if (!TranslationManager.instance) {
      TranslationManager.instance = new TranslationManager()
    }
    return TranslationManager.instance
  }
  
  // âœ… Dynamic translation loading with caching
  async loadTranslations(
    language: string, 
    namespace: string, 
    force = false
  ): Promise<Record<string, any>> {
    const cacheKey = `${language}-${namespace}`
    
    if (!force && this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)
    }
    
    // Prevent duplicate requests
    if (this.loadingPromises.has(cacheKey)) {
      return this.loadingPromises.get(cacheKey)!
    }
    
    const loadingPromise = this.fetchTranslations(language, namespace)
    this.loadingPromises.set(cacheKey, loadingPromise)
    
    try {
      const translations = await loadingPromise
      this.cache.set(cacheKey, translations)
      return translations
    } catch (error) {
      console.error(`Failed to load translations for ${cacheKey}:`, error)
      throw error
    } finally {
      this.loadingPromises.delete(cacheKey)
    }
  }
  
  private async fetchTranslations(
    language: string, 
    namespace: string
  ): Promise<Record<string, any>> {
    const response = await fetch(`/locales/${language}/${namespace}.json`)
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: Failed to load ${language}/${namespace}`)
    }
    
    const data = await response.json()
    
    // Validate translation structure
    try {
      TranslationFileSchema.parse(data)
    } catch (error) {
      console.warn(`Invalid translation structure for ${language}/${namespace}:`, error)
    }
    
    return data
  }
  
  // âœ… Find missing translations
  async findMissingTranslations(
    sourceLanguage: string,
    targetLanguage: string,
    namespace?: string
  ): Promise<string[]> {
    const sourceTranslations = await this.loadTranslations(sourceLanguage, namespace || 'common')
    const targetTranslations = await this.loadTranslations(targetLanguage, namespace || 'common')
    
    const missingKeys: string[] = []
    
    const checkKeys = (obj: any, prefix = ''): void => {
      Object.keys(obj).forEach(key => {
        const fullKey = prefix ? `${prefix}.${key}` : key
        
        if (typeof obj[key] === 'object' && obj[key] !== null) {
          checkKeys(obj[key], fullKey)
        } else {
          if (!this.getNestedValue(targetTranslations, fullKey)) {
            missingKeys.push(fullKey)
          }
        }
      })
    }
    
    checkKeys(sourceTranslations)
    return missingKeys
  }
  
  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => current?.[key], obj)
  }
  
  // âœ… Translation statistics
  getTranslationStats(language: string, namespace: string): {
    totalKeys: number
    translatedKeys: number
    emptyKeys: number
    completionPercentage: number
  } {
    const cacheKey = `${language}-${namespace}`
    const translations = this.cache.get(cacheKey)
    
    if (!translations) {
      return { totalKeys: 0, translatedKeys: 0, emptyKeys: 0, completionPercentage: 0 }
    }
    
    let totalKeys = 0
    let translatedKeys = 0
    let emptyKeys = 0
    
    const countKeys = (obj: any): void => {
      Object.values(obj).forEach(value => {
        if (typeof value === 'object' && value !== null) {
          countKeys(value)
        } else {
          totalKeys++
          if (value && typeof value === 'string' && value.trim()) {
            translatedKeys++
          } else {
            emptyKeys++
          }
        }
      })
    }
    
    countKeys(translations)
    
    const completionPercentage = totalKeys > 0 ? (translatedKeys / totalKeys) * 100 : 0
    
    return {
      totalKeys,
      translatedKeys,
      emptyKeys,
      completionPercentage: Math.round(completionPercentage * 100) / 100,
    }
  }
}

export const translationManager = TranslationManager.getInstance()

// âœ… Testing utilities for i18n
export const I18nTestUtils = {
  createMockT: (translations: Record<string, string> = {}): typeof i18n.t => {
    return (key: string, options?: any) => {
      const translation = translations[key] || key
      
      // Handle interpolation
      if (options) {
        let result = translation
        Object.entries(options).forEach(([placeholder, value]) => {
          result = result.replace(new RegExp(`{{${placeholder}}}`, 'g'), String(value))
        })
        return result
      }
      
      return translation
    }
  },
  
  renderWithI18n: (component: React.ReactElement, translations: Record<string, any> = {}) => {
    const mockI18n = {
      language: 'en',
      languages: ['en'],
      t: I18nTestUtils.createMockT(translations.en || {}),
      exists: (key: string) => Boolean(translations.en?.[key]),
      changeLanguage: jest.fn().mockResolvedValue(undefined),
    }
    
    return {
      ...render(component),
      mockI18n,
    }
  },
}
```

## Best Practices Summary

**Key patterns for enterprise i18n applications:**

1. **Type Safety**: Use TypeScript interfaces for translation resources, implement type-safe translation hooks, validate translation keys at compile time.

2. **Performance**: Implement lazy loading for translation chunks, cache translations in localStorage, use optimized selectors and memoization.

3. **Architecture**: Organize translations by feature/domain, use namespace separation, implement fallback strategies for missing translations.

4. **User Experience**: Support RTL languages, implement proper pluralization, format numbers/dates according to locale, provide loading states.

5. **Development**: Create automated translation extraction tools, implement comprehensive testing strategies, use translation management systems.

6. **Maintenance**: Monitor translation completeness, track missing keys, validate translation files, implement automated quality checks.

7. **Advanced Features**: Support rich text translations with HTML/Markdown, implement context-aware translations, provide translation management tools.

8. **Error Handling**: Implement proper error boundaries, provide fallback mechanisms, handle network failures gracefully.

Always prioritize user experience with smooth language switching, maintain translation quality with proper validation, and optimize performance with efficient loading and caching strategies for scalable internationalization. 