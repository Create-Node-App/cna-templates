---
description: Advanced Zustand patterns for scalable state management, middleware composition, performance optimization, and complex async flows.
globs: '**/*.{ts,tsx,js,jsx}'
---

# Advanced Zustand State Management Patterns

## Store Architecture & Type Safety

**Enterprise-grade store structure:**
```typescript
import { create } from 'zustand'
import { subscribeWithSelector, devtools, persist, createJSONStorage } from 'zustand/middleware'
import { immer } from 'zustand/middleware/immer'
import { temporal } from 'zundo'

// ✅ Domain-specific store interfaces
interface User {
  id: string
  name: string
  email: string
  role: 'admin' | 'user' | 'moderator'
  preferences: UserPreferences
}

interface UserPreferences {
  theme: 'light' | 'dark' | 'auto'
  language: string
  notifications: {
    email: boolean
    push: boolean
    desktop: boolean
  }
}

// ✅ Store state and actions interface
interface UserStore {
  // State
  user: User | null
  isLoading: boolean
  error: string | null
  loginAttempts: number
  
  // Sync actions
  setUser: (user: User) => void
  clearUser: () => void
  updatePreferences: (preferences: Partial<UserPreferences>) => void
  incrementLoginAttempts: () => void
  resetLoginAttempts: () => void
  
  // Async actions
  login: (credentials: LoginCredentials) => Promise<void>
  logout: () => Promise<void>
  refreshToken: () => Promise<void>
  updateProfile: (updates: Partial<User>) => Promise<void>
}

// ✅ Advanced store with multiple middleware
export const useUserStore = create<UserStore>()(
  devtools(
    persist(
      subscribeWithSelector(
        temporal(
          immer((set, get) => ({
            // ✅ Initial state
            user: null,
            isLoading: false,
            error: null,
            loginAttempts: 0,
            
            // ✅ Sync actions with Immer for immutable updates
            setUser: (user) => set((state) => {
              state.user = user
              state.error = null
              state.loginAttempts = 0
            }),
            
            clearUser: () => set((state) => {
              state.user = null
            }),
            
            updatePreferences: (preferences) => set((state) => {
              if (state.user) {
                Object.assign(state.user.preferences, preferences)
              }
            }),
            
            incrementLoginAttempts: () => set((state) => {
              state.loginAttempts += 1
            }),
            
            resetLoginAttempts: () => set((state) => {
              state.loginAttempts = 0
            }),
            
            // ✅ Async actions with proper error handling
            login: async (credentials) => {
              set((state) => {
                state.isLoading = true
                state.error = null
              })
              
              try {
                const response = await authApi.login(credentials)
                
                set((state) => {
                  state.user = response.user
                  state.isLoading = false
                  state.loginAttempts = 0
                })
                
                // ✅ Side effects after state update
                analytics.track('User Logged In', { userId: response.user.id })
                
              } catch (error) {
                set((state) => {
                  state.isLoading = false
                  state.error = error.message
                  state.loginAttempts += 1
                })
                
                // ✅ Handle too many attempts
                if (get().loginAttempts >= 5) {
                  set((state) => {
                    state.error = 'Too many login attempts. Please try again later.'
                  })
                }
                
                throw error
              }
            },
            
            logout: async () => {
              try {
                await authApi.logout()
                set((state) => {
                  state.user = null
                  state.error = null
                })
              } catch (error) {
                console.error('Logout failed:', error)
                // Still clear user state on logout failure
                set((state) => {
                  state.user = null
                })
              }
            },
            
            refreshToken: async () => {
              try {
                const response = await authApi.refreshToken()
                set((state) => {
                  if (state.user) {
                    state.user = { ...state.user, ...response.user }
                  }
                })
              } catch (error) {
                // Token refresh failed, logout user
                set((state) => {
                  state.user = null
                  state.error = 'Session expired. Please log in again.'
                })
              }
            },
            
            updateProfile: async (updates) => {
              const currentUser = get().user
              if (!currentUser) return
              
              // ✅ Optimistic update
              const originalUser = currentUser
              set((state) => {
                if (state.user) {
                  Object.assign(state.user, updates)
                }
              })
              
              try {
                const updatedUser = await userApi.updateProfile(currentUser.id, updates)
                set((state) => {
                  state.user = updatedUser
                })
              } catch (error) {
                // ✅ Revert optimistic update on error
                set((state) => {
                  state.user = originalUser
                  state.error = error.message
                })
                throw error
              }
            }
          })),
          {
            // ✅ Temporal middleware for undo/redo
            limit: 10,
            include: (state, pastState) => state.user !== pastState.user
          }
        )
      ),
      {
        name: 'user-store',
        storage: createJSONStorage(() => localStorage),
        // ✅ Partial persistence (exclude sensitive data)
        partialize: (state) => ({
          user: state.user ? {
            ...state.user,
            // Exclude sensitive fields from persistence
            email: undefined
          } : null
        }),
        // ✅ Migration for backwards compatibility
        migrate: (persistedState: any, version: number) => {
          if (version < 2 && persistedState.user) {
            // Migrate old user structure
            persistedState.user.preferences = {
              theme: 'light',
              language: 'en',
              notifications: { email: true, push: true, desktop: false }
            }
          }
          return persistedState
        },
        version: 2
      }
    ),
    {
      name: 'user-store',
      // ✅ Custom serializer for devtools
      serialize: {
        options: {
          // Don't log sensitive information
          replacer: (key: string, value: any) => {
            if (key === 'email' || key === 'password') return '[REDACTED]'
            return value
          }
        }
      }
    }
  )
)
```

## Performance-Optimized Selectors

**Efficient state selection patterns:**
```typescript
// ✅ Shallow selectors for primitive values
export const useUser = () => useUserStore((state) => state.user)
export const useIsAuthenticated = () => useUserStore((state) => !!state.user)
export const useUserRole = () => useUserStore((state) => state.user?.role)
export const useIsLoading = () => useUserStore((state) => state.isLoading)

// ✅ Memoized computed selectors
const selectUserDisplayName = (state: UserStore) => 
  state.user ? `${state.user.name} (${state.user.role})` : 'Anonymous'

export const useUserDisplayName = () => useUserStore(selectUserDisplayName)

// ✅ Complex derived state with equality check
const selectUserPermissions = createSelector(
  [(state: UserStore) => state.user?.role],
  (role) => {
    if (!role) return []
    
    const permissions: Record<string, string[]> = {
      admin: ['read', 'write', 'delete', 'manage'],
      moderator: ['read', 'write', 'moderate'],
      user: ['read']
    }
    
    return permissions[role] || []
  }
)

export const useUserPermissions = () => useUserStore(selectUserPermissions)

// ✅ Custom equality function for object selections
export const useUserPreferences = () => 
  useUserStore((state) => state.user?.preferences, shallow)

// ✅ Reactive selectors with subscriptions
export const useAuthSubscription = (callback: (isAuth: boolean) => void) => {
  useEffect(() => {
    const unsubscribe = useUserStore.subscribe(
      (state) => state.user,
      (user) => callback(!!user),
      {
        equalityFn: (a, b) => !!a === !!b, // Only fire when auth status changes
        fireImmediately: true
      }
    )
    
    return unsubscribe
  }, [callback])
}
```

## Middleware Composition Patterns

**Advanced middleware combinations:**
```typescript
import { StateCreator } from 'zustand'
import { PersistOptions } from 'zustand/middleware'

// ✅ Custom middleware for API synchronization
const apiSync = <T extends object>(
  config: StateCreator<T, [], [], T>,
  apiEndpoint: string
): StateCreator<T, [], [], T> => (set, get, api) => {
  const state = config(set, get, api)
  
  // ✅ Auto-sync with server on state changes
  api.subscribe((newState, prevState) => {
    if (newState !== prevState) {
      debounce(() => {
        fetch(apiEndpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(newState)
        }).catch(console.error)
      }, 1000)()
    }
  })
  
  return state
}

// ✅ Custom validation middleware
const withValidation = <T extends object>(
  config: StateCreator<T, [], [], T>,
  validators: Record<keyof T, (value: any) => boolean>
): StateCreator<T, [], [], T> => (set, get, api) => {
  const state = config(
    (partial) => {
      if (typeof partial === 'function') {
        const newState = partial(get())
        
        // ✅ Validate before setting state
        for (const [key, validator] of Object.entries(validators)) {
          if (key in newState && !validator(newState[key as keyof T])) {
            console.warn(`Validation failed for ${key}:`, newState[key as keyof T])
            return
          }
        }
        
        set(newState)
      } else {
        // ✅ Validate partial updates
        for (const [key, validator] of Object.entries(validators)) {
          if (key in partial && !validator(partial[key as keyof T])) {
            console.warn(`Validation failed for ${key}:`, partial[key as keyof T])
            return
          }
        }
        
        set(partial)
      }
    },
    get,
    api
  )
  
  return state
}

// ✅ Shopping cart store with multiple middleware
interface CartItem {
  id: string
  name: string
  price: number
  quantity: number
}

interface CartStore {
  items: CartItem[]
  total: number
  addItem: (item: Omit<CartItem, 'quantity'>) => void
  removeItem: (id: string) => void
  updateQuantity: (id: string, quantity: number) => void
  clearCart: () => void
  checkout: () => Promise<void>
}

export const useCartStore = create<CartStore>()(
  devtools(
    persist(
      withValidation(
        apiSync(
          immer((set, get) => ({
            items: [],
            
            get total() {
              return get().items.reduce((sum, item) => sum + item.price * item.quantity, 0)
            },
            
            addItem: (newItem) => set((state) => {
              const existingItem = state.items.find(item => item.id === newItem.id)
              
              if (existingItem) {
                existingItem.quantity += 1
              } else {
                state.items.push({ ...newItem, quantity: 1 })
              }
            }),
            
            removeItem: (id) => set((state) => {
              state.items = state.items.filter(item => item.id !== id)
            }),
            
            updateQuantity: (id, quantity) => set((state) => {
              const item = state.items.find(item => item.id === id)
              if (item && quantity > 0) {
                item.quantity = quantity
              } else if (item && quantity <= 0) {
                state.items = state.items.filter(item => item.id !== id)
              }
            }),
            
            clearCart: () => set((state) => {
              state.items = []
            }),
            
            checkout: async () => {
              const items = get().items
              try {
                await api.checkout(items)
                set((state) => {
                  state.items = []
                })
              } catch (error) {
                throw error
              }
            }
          })),
          '/api/cart/sync'
        ),
        {
          // ✅ Validation rules
          items: (items: CartItem[]) => Array.isArray(items) && items.every(item => 
            item.quantity > 0 && item.price >= 0
          )
        }
      ),
      {
        name: 'cart-store',
        storage: createJSONStorage(() => sessionStorage) // Use session storage for cart
      }
    ),
    { name: 'cart-store' }
  )
)
```

## Complex State Management Patterns

**Multi-store coordination and advanced flows:**
```typescript
// ✅ Store composition for related domains
interface AppState {
  user: UserStore
  cart: CartStore
  notifications: NotificationStore
}

// ✅ Global app store that coordinates sub-stores
const createAppStore = () => {
  const userStore = useUserStore.getState()
  const cartStore = useCartStore.getState()
  const notificationStore = useNotificationStore.getState()
  
  // ✅ Cross-store reactions
  useUserStore.subscribe(
    (state) => state.user,
    (user) => {
      if (!user) {
        // ✅ Clear cart when user logs out
        cartStore.clearCart()
        notificationStore.clearAll()
      }
    }
  )
  
  return {
    user: userStore,
    cart: cartStore,
    notifications: notificationStore
  }
}

// ✅ Real-time sync store with WebSocket integration
interface RealtimeStore {
  isConnected: boolean
  lastSeen: Record<string, Date>
  connect: () => void
  disconnect: () => void
  updateLastSeen: (userId: string) => void
}

export const useRealtimeStore = create<RealtimeStore>((set, get) => {
  let ws: WebSocket | null = null
  
  return {
    isConnected: false,
    lastSeen: {},
    
    connect: () => {
      if (ws?.readyState === WebSocket.OPEN) return
      
      ws = new WebSocket(process.env.REACT_APP_WS_URL!)
      
      ws.onopen = () => set({ isConnected: true })
      ws.onclose = () => set({ isConnected: false })
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data)
        
        switch (data.type) {
          case 'USER_LAST_SEEN':
            set((state) => ({
              lastSeen: {
                ...state.lastSeen,
                [data.userId]: new Date(data.timestamp)
              }
            }))
            break
          
          case 'USER_STATUS_UPDATE':
            // ✅ Update user store from realtime data
            useUserStore.getState().setUser(data.user)
            break
        }
      }
    },
    
    disconnect: () => {
      ws?.close()
      set({ isConnected: false })
    },
    
    updateLastSeen: (userId) => {
      const now = new Date()
      set((state) => ({
        lastSeen: {
          ...state.lastSeen,
          [userId]: now
        }
      }))
      
      // ✅ Send to server via WebSocket
      if (ws?.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'UPDATE_LAST_SEEN',
          userId,
          timestamp: now.toISOString()
        }))
      }
    }
  }
})

// ✅ Background sync store for offline support
interface SyncStore {
  pendingActions: Array<{ id: string; action: string; data: any; timestamp: Date }>
  isOnline: boolean
  addPendingAction: (action: string, data: any) => void
  syncPendingActions: () => Promise<void>
  clearPendingActions: () => void
}

export const useSyncStore = create<SyncStore>((set, get) => ({
  pendingActions: [],
  isOnline: navigator.onLine,
  
  addPendingAction: (action, data) => {
    const id = Math.random().toString(36).substr(2, 9)
    
    set((state) => ({
      pendingActions: [
        ...state.pendingActions,
        { id, action, data, timestamp: new Date() }
      ]
    }))
  },
  
  syncPendingActions: async () => {
    const { pendingActions } = get()
    
    if (!pendingActions.length || !navigator.onLine) return
    
    try {
      const results = await Promise.allSettled(
        pendingActions.map(async ({ action, data }) => {
          return await api.syncAction(action, data)
        })
      )
      
      // ✅ Remove successfully synced actions
      const successfulIds = results
        .map((result, index) => result.status === 'fulfilled' ? pendingActions[index].id : null)
        .filter(Boolean)
      
      set((state) => ({
        pendingActions: state.pendingActions.filter(
          action => !successfulIds.includes(action.id)
        )
      }))
      
    } catch (error) {
      console.error('Sync failed:', error)
    }
  },
  
  clearPendingActions: () => set({ pendingActions: [] })
}))

// ✅ Listen to online/offline events
if (typeof window !== 'undefined') {
  window.addEventListener('online', () => {
    useSyncStore.getState().syncPendingActions()
  })
  
  window.addEventListener('offline', () => {
    useSyncStore.setState({ isOnline: false })
  })
}
```

## Testing Patterns

**Comprehensive store testing strategies:**
```typescript
import { renderHook, act } from '@testing-library/react'
import { beforeEach, describe, expect, it, vi } from 'vitest'

// ✅ Store testing utilities
const createMockStore = (initialState?: Partial<UserStore>) => {
  // Reset store before each test
  useUserStore.setState({
    user: null,
    isLoading: false,
    error: null,
    loginAttempts: 0,
    ...initialState
  })
  
  return useUserStore
}

describe('UserStore', () => {
  beforeEach(() => {
    vi.clearAllMocks()
    createMockStore()
  })
  
  // ✅ Test sync actions
  it('should set user correctly', () => {
    const mockUser: User = {
      id: '1',
      name: 'John Doe',
      email: 'john@example.com',
      role: 'user',
      preferences: {
        theme: 'light',
        language: 'en',
        notifications: { email: true, push: false, desktop: false }
      }
    }
    
    act(() => {
      useUserStore.getState().setUser(mockUser)
    })
    
    expect(useUserStore.getState().user).toEqual(mockUser)
    expect(useUserStore.getState().error).toBeNull()
    expect(useUserStore.getState().loginAttempts).toBe(0)
  })
  
  // ✅ Test async actions
  it('should handle login success', async () => {
    const mockCredentials = { email: 'test@example.com', password: 'password' }
    const mockUser = { id: '1', name: 'Test User', email: 'test@example.com' }
    
    // ✅ Mock API response
    vi.mocked(authApi.login).mockResolvedValue({ user: mockUser })
    
    await act(async () => {
      await useUserStore.getState().login(mockCredentials)
    })
    
    const state = useUserStore.getState()
    expect(state.user).toEqual(mockUser)
    expect(state.isLoading).toBe(false)
    expect(state.error).toBeNull()
    expect(authApi.login).toHaveBeenCalledWith(mockCredentials)
  })
  
  // ✅ Test error handling
  it('should handle login failure', async () => {
    const mockCredentials = { email: 'test@example.com', password: 'wrong' }
    const mockError = new Error('Invalid credentials')
    
    vi.mocked(authApi.login).mockRejectedValue(mockError)
    
    await act(async () => {
      try {
        await useUserStore.getState().login(mockCredentials)
      } catch (error) {
        // Expected to throw
      }
    })
    
    const state = useUserStore.getState()
    expect(state.user).toBeNull()
    expect(state.isLoading).toBe(false)
    expect(state.error).toBe('Invalid credentials')
    expect(state.loginAttempts).toBe(1)
  })
  
  // ✅ Test selectors
  it('should select user display name correctly', () => {
    const mockUser = { id: '1', name: 'John Doe', role: 'admin' } as User
    
    act(() => {
      useUserStore.getState().setUser(mockUser)
    })
    
    const { result } = renderHook(() => useUserDisplayName())
    expect(result.current).toBe('John Doe (admin)')
  })
  
  // ✅ Test store subscriptions
  it('should notify subscribers of state changes', () => {
    const mockCallback = vi.fn()
    
    const unsubscribe = useUserStore.subscribe(
      (state) => state.user,
      mockCallback
    )
    
    const mockUser = { id: '1', name: 'Test' } as User
    
    act(() => {
      useUserStore.getState().setUser(mockUser)
    })
    
    expect(mockCallback).toHaveBeenCalledWith(mockUser, null)
    
    unsubscribe()
  })
  
  // ✅ Test middleware behavior
  it('should persist state correctly', () => {
    const mockUser = { id: '1', name: 'John' } as User
    
    act(() => {
      useUserStore.getState().setUser(mockUser)
    })
    
    // ✅ Check localStorage was called
    expect(localStorage.setItem).toHaveBeenCalledWith(
      'user-store',
      expect.stringContaining('"user"')
    )
  })
})

// ✅ Integration test for multiple stores
describe('Store Integration', () => {
  it('should clear cart when user logs out', async () => {
    // ✅ Setup initial state
    act(() => {
      useUserStore.getState().setUser({ id: '1', name: 'Test' } as User)
      useCartStore.getState().addItem({ id: '1', name: 'Item', price: 10 })
    })
    
    expect(useCartStore.getState().items).toHaveLength(1)
    
    // ✅ Logout user
    await act(async () => {
      await useUserStore.getState().logout()
    })
    
    // ✅ Cart should be cleared
    expect(useCartStore.getState().items).toHaveLength(0)
  })
})
``` 