---
description: Expert-level React + Vite development guidelines with specific patterns, HMR optimization, and modern frontend architecture.
globs: **/*.{js,jsx,ts,tsx,css,scss}
---

# Frontend Stack Rules for React Vite Starter

## Vite-Specific Patterns

**Always leverage Vite's capabilities:**

```typescript
// ✅ Use import.meta for environment variables
const API_URL = import.meta.env.VITE_API_URL

// ✅ Dynamic imports for code splitting
const LazyComponent = React.lazy(() => import('./LazyComponent'))

// ✅ Vite's glob imports for dynamic loading
const modules = import.meta.glob('./modules/*.ts')

// ✅ Use import.meta.hot for HMR
if (import.meta.hot) {
  import.meta.hot.accept('./module', (newModule) => {
    // Handle hot update
  })
}
```

## React 18+ Modern Patterns

**Concurrent Features & Suspense:**
```tsx
// ✅ Use Suspense boundaries with error boundaries
<ErrorBoundary fallback={<ErrorFallback />}>
  <Suspense fallback={<ComponentSkeleton />}>
    <LazyFeature />
  </Suspense>
</ErrorBoundary>

// ✅ Use startTransition for non-urgent updates
const [isPending, startTransition] = useTransition()
startTransition(() => setSearchQuery(value))

// ✅ Defer values for better UX
const deferredQuery = useDeferredValue(searchQuery)
```

## TypeScript Integration

**Vite + React + TypeScript patterns:**
```typescript
// ✅ Define component props with interfaces
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'danger'
  size?: 'sm' | 'md' | 'lg'
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void
  children: React.ReactNode
}

// ✅ Use generic components when needed
interface ListProps<T> {
  items: T[]
  renderItem: (item: T, index: number) => React.ReactNode
  keyExtractor: (item: T) => string | number
}

// ✅ Proper event handlers typing
const handleInputChange = useCallback(
  (event: React.ChangeEvent<HTMLInputElement>) => {
    setValue(event.target.value)
  },
  []
)
```

## Performance & Bundle Optimization

**Vite-specific optimizations:**
```typescript
// ✅ Use Vite's pre-bundling for large dependencies
// vite.config.ts
optimizeDeps: {
  include: ['react', 'react-dom', 'react-router-dom'],
  exclude: ['@vite/client', '@vite/env']
}

// ✅ Code splitting by routes
const HomePage = lazy(() => import('../pages/HomePage'))
const ProfilePage = lazy(() => 
  import('../pages/ProfilePage').then(module => ({
    default: module.ProfilePage
  }))
)

// ✅ Preload critical routes
const preloadRoute = (routeImport: () => Promise<any>) => {
  const componentImport = routeImport()
  return componentImport
}
```

## SCSS/CSS Modules Patterns

```scss
// ✅ Use CSS custom properties for theming
:root {
  --color-primary: #007bff;
  --color-secondary: #6c757d;
  --spacing-unit: 0.25rem;
}

// ✅ BEM methodology with SCSS
.card {
  &__header {
    border-bottom: 1px solid var(--color-border);
    
    &--highlighted {
      background-color: var(--color-primary);
    }
  }
  
  &__body {
    padding: calc(var(--spacing-unit) * 4);
  }
}
```
4. Use proper caching strategies
5. Monitor performance metrics

## PWA Features

1. Implement proper service workers
2. Handle offline functionality
3. Implement proper caching
4. Follow PWA best practices
5. Test PWA features
