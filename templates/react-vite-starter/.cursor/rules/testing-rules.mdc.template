---
description: Comprehensive testing patterns for React + Vite applications using Vitest, Testing Library, and modern testing practices.
globs: **/*.{test,spec}.{js,jsx,ts,tsx}
---

# Testing Patterns for React Vite Applications

## Vitest + Testing Library Setup

**Essential test utilities:**
```typescript
// setupTests.ts
import '@testing-library/jest-dom'
import { cleanup } from '@testing-library/react'
import { afterEach, vi } from 'vitest'

// Cleanup after each test
afterEach(() => {
  cleanup()
})

// Mock IntersectionObserver
global.IntersectionObserver = vi.fn(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}))

// Mock ResizeObserver
global.ResizeObserver = vi.fn(() => ({
  observe: vi.fn(),
  unobserve: vi.fn(),
  disconnect: vi.fn(),
}))
```

## Component Testing Patterns

**Testing React components with user interactions:**
```tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { describe, it, expect, vi } from 'vitest'
import { SearchBox } from './SearchBox'

// ✅ Test user interactions, not implementation details
describe('SearchBox', () => {
  const user = userEvent.setup()
  
  it('calls onSearch with debounced value after user stops typing', async () => {
    const mockOnSearch = vi.fn()
    render(<SearchBox onSearch={mockOnSearch} />)
    
    const input = screen.getByRole('textbox', { name: /search/i })
    
    // Type quickly
    await user.type(input, 'react')
    
    // Wait for debounce
    await waitFor(() => {
      expect(mockOnSearch).toHaveBeenCalledWith('react')
    }, { timeout: 1000 })
    
    expect(mockOnSearch).toHaveBeenCalledTimes(1)
  })
  
  it('shows loading state during search', async () => {
    const mockOnSearch = vi.fn().mockImplementation(
      () => new Promise(resolve => setTimeout(resolve, 100))
    )
    
    render(<SearchBox onSearch={mockOnSearch} />)
    
    await user.click(screen.getByRole('button', { name: /search/i }))
    
    expect(screen.getByRole('button', { name: /searching/i })).toBeInTheDocument()
    
    await waitFor(() => {
      expect(screen.getByRole('button', { name: /search/i })).toBeInTheDocument()
    })
  })
})
```

## Custom Hook Testing

**Testing complex hooks in isolation:**
```tsx
import { renderHook, act } from '@testing-library/react'
import { describe, it, expect, vi } from 'vitest'
import { useApiData } from './useApiData'

// ✅ Mock fetch for consistent testing
const mockFetch = vi.fn()
global.fetch = mockFetch

describe('useApiData', () => {
  beforeEach(() => {
    mockFetch.mockClear()
  })
  
  it('fetches and returns data successfully', async () => {
    const mockData = { id: 1, name: 'Test' }
    mockFetch.mockResolvedValueOnce({
      ok: true,
      json: async () => mockData,
    })
    
    const { result } = renderHook(() => useApiData('/api/test'))
    
    expect(result.current.loading).toBe(true)
    expect(result.current.data).toBe(null)
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
    })
    
    expect(result.current.data).toEqual(mockData)
    expect(result.current.error).toBe(null)
  })
  
  it('handles fetch errors gracefully', async () => {
    const mockError = new Error('Network error')
    mockFetch.mockRejectedValueOnce(mockError)
    
    const { result } = renderHook(() => useApiData('/api/test'))
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
    })
    
    expect(result.current.error).toEqual(mockError)
    expect(result.current.data).toBe(null)
  })
  
  it('cancels request on unmount', () => {
    const { unmount } = renderHook(() => useApiData('/api/test'))
    
    unmount()
    
    // Verify AbortController.abort was called
    expect(mockFetch).toHaveBeenCalledWith(
      '/api/test',
      expect.objectContaining({
        signal: expect.any(AbortSignal)
      })
    )
  })
})
```

## Integration Testing Patterns

**Testing component integration with providers:**
```tsx
import { render, screen } from '@testing-library/react'
import { BrowserRouter } from 'react-router-dom'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { describe, it, expect } from 'vitest'
import { UserProfile } from './UserProfile'

// ✅ Create test wrapper for providers
const createTestWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  })
  
  return function TestWrapper({ children }: { children: React.ReactNode }) {
    return (
      <QueryClientProvider client={queryClient}>
        <BrowserRouter>
          {children}
        </BrowserRouter>
      </QueryClientProvider>
    )
  }
}

describe('UserProfile Integration', () => {
  it('displays user data when loaded successfully', async () => {
    const TestWrapper = createTestWrapper()
    
    render(
      <TestWrapper>
        <UserProfile userId="123" />
      </TestWrapper>
    )
    
    expect(screen.getByText(/loading/i)).toBeInTheDocument()
    
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument()
    })
    
    expect(screen.getByText('john@example.com')).toBeInTheDocument()
  })
})
```

## Mock Strategies

**Effective mocking patterns:**
```typescript
// ✅ Mock external dependencies
vi.mock('react-router-dom', () => ({
  ...vi.importActual('react-router-dom'),
  useNavigate: () => vi.fn(),
  useParams: () => ({ id: '123' }),
}))

// ✅ Mock API modules
vi.mock('../api/userService', () => ({
  fetchUser: vi.fn(),
  updateUser: vi.fn(),
}))

// ✅ Partial mocking for utilities
vi.mock('../utils/dateUtils', async () => {
  const actual = await vi.importActual('../utils/dateUtils')
  return {
    ...actual,
    formatDate: vi.fn(() => '2023-12-01'),
  }
})
```

## Performance Testing

**Testing performance-critical components:**
```tsx
import { render, screen } from '@testing-library/react'
import { describe, it, expect } from 'vitest'
import { VirtualizedList } from './VirtualizedList'

describe('VirtualizedList Performance', () => {
  it('renders large lists efficiently', () => {
    const items = Array.from({ length: 10000 }, (_, i) => ({
      id: i,
      name: `Item ${i}`,
    }))
    
    const startTime = performance.now()
    render(<VirtualizedList items={items} />)
    const renderTime = performance.now() - startTime
    
    // Should render in under 100ms
    expect(renderTime).toBeLessThan(100)
    
    // Only visible items should be in DOM
    const renderedItems = screen.getAllByTestId('list-item')
    expect(renderedItems.length).toBeLessThan(50)
  })
})
```

## Accessibility Testing

**Testing a11y compliance:**
```tsx
import { render } from '@testing-library/react'
import { axe, toHaveNoViolations } from 'jest-axe'
import { describe, it, expect } from 'vitest'

expect.extend(toHaveNoViolations)

describe('Button Accessibility', () => {
  it('has no accessibility violations', async () => {
    const { container } = render(
      <Button onClick={() => {}}>Click me</Button>
    )
    
    const results = await axe(container)
    expect(results).toHaveNoViolations()
  })
  
  it('supports keyboard navigation', () => {
    render(<Button onClick={() => {}}>Click me</Button>)
    
    const button = screen.getByRole('button')
    button.focus()
    
    expect(button).toHaveFocus()
    expect(button).toHaveAttribute('tabindex', '0')
  })
})
