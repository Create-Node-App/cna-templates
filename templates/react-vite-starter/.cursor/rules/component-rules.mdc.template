---
description: Comprehensive React component patterns, architecture, and best practices for maintainable Vite applications.
globs: **/*.{jsx,tsx}
---

# Component Architecture & Patterns for React Vite

## Component Structure Patterns

**Atomic Design Hierarchy:**
```tsx
// ✅ Atoms - Basic building blocks
interface ButtonProps {
  variant: 'primary' | 'secondary' | 'danger'
  size?: 'sm' | 'md' | 'lg'
  isLoading?: boolean
  children: React.ReactNode
  onClick: () => void
}

export const Button: React.FC<ButtonProps> = ({ 
  variant, 
  size = 'md', 
  isLoading, 
  children, 
  onClick 
}) => {
  return (
    <button 
      className={`btn btn--${variant} btn--${size}`}
      disabled={isLoading}
      onClick={onClick}
    >
      {isLoading ? <Spinner size="sm" /> : children}
    </button>
  )
}

// ✅ Molecules - Component combinations
export const SearchBox: React.FC<SearchBoxProps> = ({ onSearch }) => {
  const [query, setQuery] = useState('')
  const deferredQuery = useDeferredValue(query)
  
  useEffect(() => {
    if (deferredQuery) onSearch(deferredQuery)
  }, [deferredQuery, onSearch])
  
  return (
    <div className="search-box">
      <Input 
        value={query}
        onChange={setQuery}
        placeholder="Search..."
      />
      <Button variant="primary" onClick={() => onSearch(query)}>
        Search
      </Button>
    </div>
  )
}
```

## Component Composition Patterns

**Compound Components:**
```tsx
// ✅ Create flexible, composable interfaces
interface ModalContextType {
  isOpen: boolean
  close: () => void
}

const ModalContext = createContext<ModalContextType | null>(null)

export const Modal = {
  Root: ({ children, isOpen, onClose }: ModalRootProps) => (
    <ModalContext.Provider value={{ isOpen, close: onClose }}>
      {children}
    </ModalContext.Provider>
  ),
  
  Trigger: ({ children }: { children: React.ReactNode }) => {
    const { isOpen } = useContext(ModalContext)!
    return <>{children}</>
  },
  
  Content: ({ children }: { children: React.ReactNode }) => {
    const { isOpen, close } = useContext(ModalContext)!
    return isOpen ? (
      <Portal>
        <div className="modal-overlay" onClick={close}>
          <div className="modal-content" onClick={e => e.stopPropagation()}>
            {children}
          </div>
        </div>
      </Portal>
    ) : null
  }
}

// Usage:
<Modal.Root isOpen={showModal} onClose={() => setShowModal(false)}>
  <Modal.Trigger>
    <Button>Open Modal</Button>
  </Modal.Trigger>
  <Modal.Content>
    <h2>Modal Title</h2>
    <p>Modal content...</p>
  </Modal.Content>
</Modal.Root>
```

## Custom Hooks Patterns

**Extract logic into reusable hooks:**
```tsx
// ✅ Data fetching hook
function useApiData<T>(url: string) {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)
  
  useEffect(() => {
    const controller = new AbortController()
    
    fetch(url, { signal: controller.signal })
      .then(res => res.json())
      .then(setData)
      .catch(err => {
        if (err.name !== 'AbortError') setError(err)
      })
      .finally(() => setLoading(false))
      
    return () => controller.abort()
  }, [url])
  
  return { data, loading, error, refetch: () => {/* refetch logic */} }
}

// ✅ Local storage hook
function useLocalStorage<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch {
      return initialValue
    }
  })
  
  const setStoredValue = useCallback((newValue: T) => {
    setValue(newValue)
    window.localStorage.setItem(key, JSON.stringify(newValue))
  }, [key])
  
  return [value, setStoredValue] as const
}
```

## Error Handling Patterns

**Comprehensive error boundaries:**
```tsx
// ✅ Feature-level error boundary
interface ErrorBoundaryState {
  hasError: boolean
  error?: Error
}

export class FeatureErrorBoundary extends Component<
  PropsWithChildren<{}>, 
  ErrorBoundaryState
> {
  constructor(props: PropsWithChildren<{}>) {
    super(props)
    this.state = { hasError: false }
  }
  
  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error }
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Feature error:', error, errorInfo)
    // Send to error reporting service
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <div className="error-fallback">
          <h2>Something went wrong</h2>
          <button onClick={() => this.setState({ hasError: false })}>
            Try again
          </button>
        </div>
      )
    }
    
    return this.props.children
  }
}
```

## Performance Optimization Patterns

**Memoization strategies:**
```tsx
// ✅ Expensive calculations
const ExpensiveComponent = memo(({ data }: { data: ComplexData[] }) => {
  const processedData = useMemo(() => {
    return data
      .filter(item => item.active)
      .sort((a, b) => b.priority - a.priority)
      .slice(0, 100)
  }, [data])
  
  const handleItemClick = useCallback((id: string) => {
    // Handle click logic
  }, [])
  
  return (
    <div>
      {processedData.map(item => (
        <ItemComponent 
          key={item.id} 
          item={item}
          onClick={handleItemClick}
        />
      ))}
    </div>
  )
})

// ✅ Virtualization for large lists
import { FixedSizeList } from 'react-window'

const VirtualizedList = ({ items }: { items: any[] }) => (
  <FixedSizeList
    height={400}
    itemCount={items.length}
    itemSize={35}
    itemData={items}
  >
    {({ index, style, data }) => (
      <div style={style}>
        <ItemComponent item={data[index]} />
      </div>
    )}
  </FixedSizeList>
)
```
