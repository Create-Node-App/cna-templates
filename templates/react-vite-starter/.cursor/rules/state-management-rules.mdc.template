---
description: Modern state management patterns for React applications using hooks, context, and external libraries with TypeScript.
globs: **/*.{js,jsx,ts,tsx}
---

# State Management Architecture for React Applications

## React Built-in State Management

**useState patterns:**
```tsx
// ✅ Complex state with useReducer instead of multiple useState
interface FormState {
  values: Record<string, string>
  errors: Record<string, string>
  isSubmitting: boolean
  isDirty: boolean
}

type FormAction = 
  | { type: 'SET_FIELD'; field: string; value: string }
  | { type: 'SET_ERROR'; field: string; error: string }
  | { type: 'START_SUBMIT' }
  | { type: 'FINISH_SUBMIT' }
  | { type: 'RESET' }

function formReducer(state: FormState, action: FormAction): FormState {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        values: { ...state.values, [action.field]: action.value },
        errors: { ...state.errors, [action.field]: '' },
        isDirty: true,
      }
    case 'SET_ERROR':
      return {
        ...state,
        errors: { ...state.errors, [action.field]: action.error }
      }
    // ... other cases
    default:
      return state
  }
}

// Usage in component
function ContactForm() {
  const [state, dispatch] = useReducer(formReducer, {
    values: {},
    errors: {},
    isSubmitting: false,
    isDirty: false,
  })
  
  const handleFieldChange = useCallback((field: string, value: string) => {
    dispatch({ type: 'SET_FIELD', field, value })
  }, [])
  
  return (
    // Form JSX
  )
}
```

## Context API Patterns

**Proper context organization:**
```tsx
// ✅ Split contexts by concern and usage patterns
interface AuthContextType {
  user: User | null
  login: (email: string, password: string) => Promise<void>
  logout: () => void
  isLoading: boolean
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

// ✅ Custom hook for context consumption
export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}

// ✅ Provider component with optimized re-renders
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  
  // ✅ Memoize context value to prevent unnecessary re-renders
  const value = useMemo(() => ({
    user,
    isLoading,
    login: async (email: string, password: string) => {
      setIsLoading(true)
      try {
        const userData = await authService.login(email, password)
        setUser(userData)
      } finally {
        setIsLoading(false)
      }
    },
    logout: () => {
      setUser(null)
      authService.logout()
    },
  }), [user, isLoading])
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}
```

## Custom Hooks for State Logic

**Reusable state management hooks:**
```tsx
// ✅ Generic async state hook
function useAsyncState<T>() {
  const [state, setState] = useState<{
    data: T | null
    error: Error | null
    isLoading: boolean
  }>({
    data: null,
    error: null,
    isLoading: false,
  })
  
  const execute = useCallback(async (asyncFunction: () => Promise<T>) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }))
    
    try {
      const data = await asyncFunction()
      setState({ data, error: null, isLoading: false })
      return data
    } catch (error) {
      setState(prev => ({ 
        ...prev, 
        error: error as Error, 
        isLoading: false 
      }))
      throw error
    }
  }, [])
  
  return {
    ...state,
    execute,
    reset: () => setState({ data: null, error: null, isLoading: false })
  }
}

// ✅ Local storage state hook
function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error)
      return initialValue
    }
  })
  
  const setValue = useCallback((value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value
      setStoredValue(valueToStore)
      window.localStorage.setItem(key, JSON.stringify(valueToStore))
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error)
    }
  }, [key, storedValue])
  
  return [storedValue, setValue] as const
}

// ✅ Debounced state hook
function useDebouncedState<T>(initialValue: T, delay: number) {
  const [value, setValue] = useState<T>(initialValue)
  const [debouncedValue, setDebouncedValue] = useState<T>(initialValue)
  
  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay)
    return () => clearTimeout(timer)
  }, [value, delay])
  
  return [value, debouncedValue, setValue] as const
}
```

## State Synchronization Patterns

**Keep different state sources in sync:**
```tsx
// ✅ Sync state with URL parameters
function useUrlState(key: string, defaultValue: string = '') {
  const [searchParams, setSearchParams] = useSearchParams()
  
  const value = searchParams.get(key) ?? defaultValue
  
  const setValue = useCallback((newValue: string) => {
    setSearchParams(prev => {
      const newParams = new URLSearchParams(prev)
      if (newValue) {
        newParams.set(key, newValue)
      } else {
        newParams.delete(key)
      }
      return newParams
    })
  }, [key, setSearchParams])
  
  return [value, setValue] as const
}

// ✅ Sync state across tabs/windows
function useCrossBrowserState<T>(key: string, initialValue: T) {
  const [value, setValue] = useLocalStorage(key, initialValue)
  
  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === key && e.newValue) {
        setValue(JSON.parse(e.newValue))
      }
    }
    
    window.addEventListener('storage', handleStorageChange)
    return () => window.removeEventListener('storage', handleStorageChange)
  }, [key, setValue])
  
  return [value, setValue] as const
}
```

## Advanced State Patterns

**Complex state management patterns:**
```tsx
// ✅ State machine pattern for complex workflows
type CheckoutState = 
  | { status: 'idle' }
  | { status: 'collecting-info'; step: number }
  | { status: 'validating'; data: any }
  | { status: 'processing-payment'; data: any }
  | { status: 'completed'; orderId: string }
  | { status: 'error'; error: string }

type CheckoutAction =
  | { type: 'START_CHECKOUT' }
  | { type: 'NEXT_STEP'; data?: any }
  | { type: 'PREV_STEP' }
  | { type: 'SET_ERROR'; error: string }
  | { type: 'COMPLETE'; orderId: string }
  | { type: 'RESET' }

function checkoutReducer(
  state: CheckoutState, 
  action: CheckoutAction
): CheckoutState {
  switch (state.status) {
    case 'idle':
      if (action.type === 'START_CHECKOUT') {
        return { status: 'collecting-info', step: 1 }
      }
      break
      
    case 'collecting-info':
      if (action.type === 'NEXT_STEP') {
        if (state.step < 3) {
          return { ...state, step: state.step + 1 }
        } else {
          return { status: 'validating', data: action.data }
        }
      }
      break
      
    case 'validating':
      if (action.type === 'NEXT_STEP') {
        return { status: 'processing-payment', data: state.data }
      }
      break
      
    // ... other state transitions
  }
  
  // Handle global actions
  if (action.type === 'SET_ERROR') {
    return { status: 'error', error: action.error }
  }
  
  if (action.type === 'RESET') {
    return { status: 'idle' }
  }
  
  return state
}

// ✅ Optimistic updates pattern
function useOptimisticUpdates<T>(
  items: T[],
  updateFn: (id: string, updates: Partial<T>) => Promise<T>
) {
  const [optimisticItems, setOptimisticItems] = useState<T[]>(items)
  
  const updateItem = useCallback(async (id: string, updates: Partial<T>) => {
    // Optimistically update UI
    setOptimisticItems(prev => 
      prev.map(item => 
        item.id === id ? { ...item, ...updates } : item
      )
    )
    
    try {
      // Perform actual update
      const updatedItem = await updateFn(id, updates)
      
      // Replace optimistic update with real data
      setOptimisticItems(prev =>
        prev.map(item => item.id === id ? updatedItem : item)
      )
    } catch (error) {
      // Revert optimistic update on error
      setOptimisticItems(items)
      throw error
    }
  }, [items, updateFn])
  
  return [optimisticItems, updateItem] as const
}
```
