---
description: Advanced NestJS architectural patterns, dependency injection, decorators, and enterprise-level backend development practices.
globs: **/*.{ts,js}
---

# NestJS Architecture & Design Patterns

## Module Organization

**Feature-based modular architecture:**
```typescript
// ✅ Feature module structure
@Module({
  imports: [
    TypeOrmModule.forFeature([User, Profile]),
    forwardRef(() => AuthModule), // Handle circular dependencies
  ],
  controllers: [UserController],
  providers: [
    UserService,
    UserRepository,
    {
      provide: 'USER_CONFIG',
      useValue: { maxUsers: 1000 },
    },
    {
      provide: UserService,
      useFactory: (config: any, logger: Logger) => {
        return new UserService(config, logger)
      },
      inject: ['USER_CONFIG', Logger],
    },
  ],
  exports: [UserService, UserRepository], // Export what other modules need
})
export class UserModule {}

// ✅ Global modules for shared functionality
@Global()
@Module({
  providers: [
    {
      provide: 'DATABASE_CONNECTION',
      useFactory: async (configService: ConfigService) => {
        return createConnection({
          host: configService.get('DB_HOST'),
          port: configService.get('DB_PORT'),
          // ... other config
        })
      },
      inject: [ConfigService],
    },
    Logger,
  ],
  exports: ['DATABASE_CONNECTION', Logger],
})
export class CoreModule {}
```

## Advanced Dependency Injection

**Custom providers and injection patterns:**
```typescript
// ✅ Interface-based injection with custom tokens
export interface PaymentProcessor {
  processPayment(amount: number, token: string): Promise<PaymentResult>
}

export const PAYMENT_PROCESSOR = Symbol('PAYMENT_PROCESSOR')

@Injectable()
export class StripePaymentProcessor implements PaymentProcessor {
  async processPayment(amount: number, token: string): Promise<PaymentResult> {
    // Stripe implementation
  }
}

@Injectable()
export class PayPalPaymentProcessor implements PaymentProcessor {
  async processPayment(amount: number, token: string): Promise<PaymentResult> {
    // PayPal implementation
  }
}

// ✅ Factory provider for conditional injection
@Module({
  providers: [
    {
      provide: PAYMENT_PROCESSOR,
      useFactory: (configService: ConfigService): PaymentProcessor => {
        const provider = configService.get('PAYMENT_PROVIDER')
        switch (provider) {
          case 'stripe':
            return new StripePaymentProcessor()
          case 'paypal':
            return new PayPalPaymentProcessor()
          default:
            throw new Error(`Unknown payment provider: ${provider}`)
        }
      },
      inject: [ConfigService],
    },
  ],
  exports: [PAYMENT_PROCESSOR],
})
export class PaymentModule {}

// Usage in service
@Injectable()
export class OrderService {
  constructor(
    @Inject(PAYMENT_PROCESSOR) private paymentProcessor: PaymentProcessor,
  ) {}
  
  async processOrder(order: Order): Promise<void> {
    const result = await this.paymentProcessor.processPayment(
      order.total,
      order.paymentToken
    )
    // Handle result
  }
}
```

## Custom Decorators & Metadata

**Powerful decorator patterns:**
```typescript
// ✅ Custom authorization decorator
export const Roles = (...roles: string[]) => SetMetadata('roles', roles)
export const Public = () => SetMetadata('isPublic', true)

// ✅ Custom validation decorator
import { registerDecorator, ValidationOptions } from 'class-validator'

export function IsStrongPassword(validationOptions?: ValidationOptions) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'isStrongPassword',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: any) {
          return typeof value === 'string' && 
                 /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/.test(value)
        },
        defaultMessage() {
          return 'Password must contain at least 8 characters, including uppercase, lowercase, number and special character'
        }
      },
    })
  }
}

// ✅ Request context decorator
export const User = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest()
    const user = request.user
    
    return data ? user?.[data] : user
  },
)

// Usage in controller
@Post('profile')
@Roles('user', 'admin')
async updateProfile(
  @User('id') userId: string,
  @Body() updateDto: UpdateProfileDto,
) {
  return this.userService.updateProfile(userId, updateDto)
}
```

## Guards, Interceptors & Filters

**Request lifecycle management:**
```typescript
// ✅ Advanced authentication guard
@Injectable()
export class JwtAuthGuard implements CanActivate {
  constructor(
    private jwtService: JwtService,
    private userService: UserService,
    private configService: ConfigService,
  ) {}
  
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest()
    const token = this.extractTokenFromHeader(request)
    
    if (!token) {
      throw new UnauthorizedException('Token not provided')
    }
    
    try {
      const payload = await this.jwtService.verifyAsync(token, {
        secret: this.configService.get('JWT_SECRET'),
      })
      
      // ✅ Attach full user object to request
      request.user = await this.userService.findById(payload.sub)
      
      // ✅ Check if user is still active
      if (!request.user.isActive) {
        throw new UnauthorizedException('User account is disabled')
      }
      
      return true
    } catch (error) {
      throw new UnauthorizedException('Invalid token')
    }
  }
  
  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? []
    return type === 'Bearer' ? token : undefined
  }
}

// ✅ Role-based authorization guard
@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}
  
  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>('roles', [
      context.getHandler(),
      context.getClass(),
    ])
    
    if (!requiredRoles) {
      return true
    }
    
    const request = context.switchToHttp().getRequest()
    const user = request.user
    
    return requiredRoles.some((role) => user.roles?.includes(role))
  }
}

// ✅ Request logging interceptor
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  constructor(private logger: Logger) {}
  
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest()
    const { method, url, body, query, params } = request
    const userAgent = request.get('user-agent') || ''
    const ip = request.ip
    
    this.logger.log({
      message: 'Request received',
      method,
      url,
      userAgent,
      ip,
      body: this.sanitizeBody(body),
      query,
      params,
    })
    
    const now = Date.now()
    
    return next.handle().pipe(
      tap(() => {
        const response = context.switchToHttp().getResponse()
        const { statusCode } = response
        const responseTime = Date.now() - now
        
        this.logger.log({
          message: 'Request completed',
          method,
          url,
          statusCode,
          responseTime,
        })
      }),
      catchError((error) => {
        const responseTime = Date.now() - now
        
        this.logger.error({
          message: 'Request failed',
          method,
          url,
          error: error.message,
          responseTime,
        })
        
        throw error
      }),
    )
  }
  
  private sanitizeBody(body: any): any {
    if (!body) return body
    
    const sensitiveFields = ['password', 'token', 'secret']
    const sanitized = { ...body }
    
    sensitiveFields.forEach(field => {
      if (sanitized[field]) {
        sanitized[field] = '[REDACTED]'
      }
    })
    
    return sanitized
  }
}

// ✅ Global exception filter
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  constructor(private logger: Logger) {}
  
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp()
    const response = ctx.getResponse()
    const request = ctx.getRequest()
    
    let status = HttpStatus.INTERNAL_SERVER_ERROR
    let message = 'Internal server error'
    
    if (exception instanceof HttpException) {
      status = exception.getStatus()
      const exceptionResponse = exception.getResponse()
      message = typeof exceptionResponse === 'string' 
        ? exceptionResponse 
        : (exceptionResponse as any).message
    }
    
    const errorResponse = {
      statusCode: status,
      message,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
    }
    
    this.logger.error({
      ...errorResponse,
      stack: exception instanceof Error ? exception.stack : undefined,
    })
    
    response.status(status).json(errorResponse)
  }
}
```

## Database Integration Patterns

**TypeORM and database best practices:**
```typescript
// ✅ Custom repository pattern
@Injectable()
export class UserRepository extends Repository<User> {
  constructor(private dataSource: DataSource) {
    super(User, dataSource.createEntityManager())
  }
  
  async findActiveUsersWithPosts(): Promise<User[]> {
    return this.createQueryBuilder('user')
      .leftJoinAndSelect('user.posts', 'post')
      .where('user.isActive = :isActive', { isActive: true })
      .orderBy('user.createdAt', 'DESC')
      .getMany()
  }
  
  async getUserStats(userId: string): Promise<UserStats> {
    const result = await this.createQueryBuilder('user')
      .select([
        'COUNT(DISTINCT post.id) as postCount',
        'COUNT(DISTINCT follower.id) as followerCount',
        'COUNT(DISTINCT following.id) as followingCount',
      ])
      .leftJoin('user.posts', 'post')
      .leftJoin('user.followers', 'follower')
      .leftJoin('user.following', 'following')
      .where('user.id = :userId', { userId })
      .getRawOne()
    
    return {
      postCount: parseInt(result.postCount),
      followerCount: parseInt(result.followerCount),
      followingCount: parseInt(result.followingCount),
    }
  }
  
  async softDeleteWithRelations(userId: string): Promise<void> {
    await this.manager.transaction(async (entityManager) => {
      // Soft delete user
      await entityManager.softDelete(User, userId)
      
      // Handle related entities
      await entityManager.update(Post, 
        { authorId: userId }, 
        { isActive: false }
      )
      
      // Clean up sessions
      await entityManager.delete(UserSession, { userId })
    })
  }
}

// ✅ Database transaction service
@Injectable()
export class TransactionService {
  constructor(private dataSource: DataSource) {}
  
  async runInTransaction<T>(
    operation: (entityManager: EntityManager) => Promise<T>
  ): Promise<T> {
    const queryRunner = this.dataSource.createQueryRunner()
    
    await queryRunner.connect()
    await queryRunner.startTransaction()
    
    try {
      const result = await operation(queryRunner.manager)
      await queryRunner.commitTransaction()
      return result
    } catch (error) {
      await queryRunner.rollbackTransaction()
      throw error
    } finally {
      await queryRunner.release()
    }
  }
}
```

## Advanced Validation & DTOs

**Comprehensive data validation:**
```typescript
// ✅ Advanced DTO with custom validation
export class CreateUserDto {
  @IsNotEmpty()
  @IsString()
  @Length(2, 50)
  @Matches(/^[a-zA-Z\s]+$/, { 
    message: 'Name can only contain letters and spaces' 
  })
  name: string

  @IsEmail({}, { message: 'Please provide a valid email address' })
  @Transform(({ value }) => value.toLowerCase().trim())
  email: string

  @IsStrongPassword()
  password: string

  @IsOptional()
  @IsDateString()
  @ValidateIf(o => o.birthDate)
  @IsMinAge(18, { message: 'User must be at least 18 years old' })
  birthDate?: string

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  @ArrayMaxSize(5)
  interests?: string[]

  @ValidateNested()
  @Type(() => AddressDto)
  address: AddressDto
}

// ✅ Custom validation decorator
export function IsMinAge(minAge: number, validationOptions?: ValidationOptions) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'isMinAge',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [minAge],
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          if (!value) return true
          
          const [minAge] = args.constraints
          const birthDate = new Date(value)
          const today = new Date()
          const age = today.getFullYear() - birthDate.getFullYear()
          
          return age >= minAge
        },
      },
    })
  }
}

// ✅ Transformation and sanitization
@Injectable()
export class SanitizationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    if (typeof value === 'string') {
      // Remove potential XSS
      value = value.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      // Trim whitespace
      value = value.trim()
    }
    
    if (typeof value === 'object' && value !== null) {
      return this.sanitizeObject(value)
    }
    
    return value
  }
  
  private sanitizeObject(obj: any): any {
    const sanitized = {}
    
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'string') {
        sanitized[key] = value.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '').trim()
      } else if (typeof value === 'object' && value !== null) {
        sanitized[key] = this.sanitizeObject(value)
      } else {
        sanitized[key] = value
      }
    }
    
    return sanitized
  }
}
```

## Performance & Caching

**Optimization strategies:**
```typescript
// ✅ Redis caching service
@Injectable()
export class CacheService {
  constructor(@Inject('REDIS_CLIENT') private redis: Redis) {}
  
  async get<T>(key: string): Promise<T | null> {
    const cached = await this.redis.get(key)
    return cached ? JSON.parse(cached) : null
  }
  
  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    await this.redis.setex(key, ttl, JSON.stringify(value))
  }
  
  async invalidatePattern(pattern: string): Promise<void> {
    const keys = await this.redis.keys(pattern)
    if (keys.length > 0) {
      await this.redis.del(...keys)
    }
  }
  
  // ✅ Cache decorator
  cache(ttl: number = 3600) {
    return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
      const originalMethod = descriptor.value
      
      descriptor.value = async function (...args: any[]) {
        const cacheKey = `${target.constructor.name}:${propertyKey}:${JSON.stringify(args)}`
        
        let result = await this.cacheService.get(cacheKey)
        if (result === null) {
          result = await originalMethod.apply(this, args)
          await this.cacheService.set(cacheKey, result, ttl)
        }
        
        return result
      }
      
      return descriptor
    }
  }
}

// Usage
@Injectable()
export class UserService {
  constructor(private cacheService: CacheService) {}
  
  @CacheService.prototype.cache(1800) // Cache for 30 minutes
  async getPopularUsers(): Promise<User[]> {
    // Expensive database operation
    return this.userRepository.findPopularUsers()
  }
}
```
